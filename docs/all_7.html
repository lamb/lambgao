
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-04-10-gae-java-sdk-1.7.7-release.html">GAE Java 1.7.7 发布</a></h1>
			<p class="meta"><time datetime="2013-04-10T11:16:34+08:00" 
			pubdate data-updated="true">2013/4/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>The Sockets API, which allows applications to make outgoing TCP connections and send/receive UDP packets to the Internet using both IPv4 and IPv6, is now available as an experimental feature. </li>
<li>The Java runtime now defaults to Java7. If you still need to use the Java6 runtime, please use the --use_java6 flag when deploying your app. We encourage you to move to Java7 as soon as possible.</li>
<li>Billing enabled apps will no longer be subject to a $2.10 minimum weekly spend. Instead, apps will only be charged for their actual usage.</li>
<li>Fixed an issue where Datastore auto ids assigned by the scattered id policy were too large to be represented as floating point numbers in the SDK.</li>
<li><p>Fixed an issue with sort by doc_id not translating correctly causing InvalidRequest errors in the Search API</p>

<ul>
<li><a href="https://code.google.com/p/googleappengine/issues/detail?id=8958">https://code.google.com/p/googleappengine/issues/detail?id=8958</a></li>
</ul></li>
</ul>

<ol>
<li>终于支持 Sockets API 了，不过目前还是实验特性</li>
<li>默认运行环境升级到了 Java7</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-29-zookeeper-znode-type.html">ZooKeeper 节点类型</a></h1>
			<p class="meta"><time datetime="2013-03-29T11:10:19+08:00" 
			pubdate data-updated="true">2013/3/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>ZooKeeper 节点是有生命周期的，这取决于节点的类型。在 ZooKeeper 中，节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），以及时序节点（SEQUENTIAL ），具体在节点创建过程中，一般是组合使用，可以生成以下 4 种节点类型。</p>

<h3 id="toc_0">持久节点（PERSISTENT）</h3>

<p>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。</p>

<h3 id="toc_1">持久顺序节点（PERSISTENT_SEQUENTIAL）</h3>

<p>这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。</p>

<h3 id="toc_2">临时节点（EPHEMERAL）</h3>

<p>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。</p>

<h3 id="toc_3">临时顺序节点（EPHEMERAL_SEQUENTIAL）</h3>

<p>可以用来实现分布式锁</p>

<p>客户端调用create()方法创建名为“_locknode_/guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。<br/>
客户端调用getChildren(“_locknode_”)方法来获取所有已经创建的子节点，注意，这里不注册任何Watcher。<br/>
客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点序号最小，那么就认为这个客户端获得了锁。<br/>
如果在步骤3中发现自己并非所有子节点中最小的，说明自己还没有获取到锁。此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时注册事件监听。<br/>
之后当这个被关注的节点被移除了，客户端会收到相应的通知。这个时候客户端需要再次调用getChildren(“_locknode_”)方法来获取所有已经创建的子节点，确保自己确实是最小的节点了，然后进入步骤3。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-19-zoundry-raven.html">Zoundry Raven: ’Nonetype’ object has no attribute ‘tagName’</a></h1>
			<p class="meta"><time datetime="2013-03-19T11:08:44+08:00" 
			pubdate data-updated="true">2013/3/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Zoundry Raven 是个不错的离线博客客户端，今天试用时发现一个问题，在打开文章的时候会出现：’Nonetype’ object has no attribute ‘tagName’</p>

<p>环境：Win7 32位，IE9 </p>

<p>解决：在“程序和功能” -&gt; “查看已安装的更新”中找到并卸载 IE9，重启。</p>

<p>应该是 Zoundry Raven 用到了 IE 的组件，而 IE9 不兼容造成的。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-18-xmpp-simple-irc-psyc.html">即时消息协议预研</a></h1>
			<p class="meta"><time datetime="2013-03-18T11:00:44+08:00" 
			pubdate data-updated="true">2013/3/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>选取了主流的四种即时消息协议作为预研对象，分别描述了这四种消息技术的原理、适用场景以及限制。</p>

<h3 id="toc_0">XMPP</h3>

<p>XMPP（The Extensible Messaging and Presence Protocol，可扩展的消息通讯与呈现协议），前身是开源即时消息协议 <a href="http://www.jabber.org/">Jabber</a>，现在已经被 IETF 标准化（<a href="http://www.ietf.org/rfc/rfc3920.txt">RFC 3920</a>）。</p>

<p>应用非常广泛，可选择的实现很多，<a href="http://www.igniterealtime.org/projects/openfire/">Openfire</a> 是目前比较成熟的。</p>

<p><img src="https://py8ifw.dm1.livefilestore.com/y1pIDQtf-tFsJZ_2e0f4a6C02OuBYE5Qr2WpFLYgQoc_wXaRB_vz13zpAoNPkbaY7KD6Sr7bqPtYwldqB6lQTV6Gq758-fbIQl8/xmpp.gif?psid=1" alt="XMPP"/></p>

<h3 id="toc_1">SIMPLE</h3>

<p>SIMPLE（SIP for Instant Messaging and Presence Leveraging Extensions，基于 SIP 的即时消息与呈现扩展），IBM/微软主推的即时消息协议，虽然 Java 有相关 JSRs（164、165）定义了接口，但没有找到适合的实现。</p>

<p><img src="https://py8ifw.dm1.livefilestore.com/y1p4KVz3qLNvK7CoVUFkHOnnPMV0zNntw81J_c2uC5PDkoVycAhsBO-mFG_nbNwV1TNoPBO_UP6o738vPOvdVys_95bMuYHQanE/simple.png?psid=1" alt="SIMPLE"/></p>

<p>各实体功能如下：</p>

<ul>
<li>Presence Service：接收、存储和分发 presence information。Presence Service 既可以是一个物理实体上的 server，也可以只是 presentity 和 watcher 之间的直接通信。在具体实现中前者比较常见，后者是 P2P 的模式</li>
<li>Presentity：用于提供 presence information 给 Presence Service</li>
<li>Watcher：向 Presence Service 请求获取 Presentity 的 presence information 或者自身的 watcher information</li>
<li>Principal：指单个的人、程序或者设备，也可以是人、程序、设备的集合体。对于 Presence Service 来说，各个 Principal 是不同的</li>
<li>Presence User Agent：为 Principal 提供手段来操作 0 个或者多个 Presentity，Principal 操作 Presence User Agent 改变 Presentity 的状态。是 Principal 和 Presentity 交互的 interface</li>
<li>Watcher User Agent：类似 Presence User Agent，Principal 通过其来操作 0 个或多个 Watcher，Watcher 收到 Presentity 的新状态之后也通过 Watcher User Agent 呈现给 Principal</li>
<li>Presence Protocol：定义了 Presentity 和 Presence Service，Watcher 和 Presence Service 之间交换消息的一组标准</li>
<li>在具体的实现中最常见的是把 Presence Service 实现为一个 Presence Server，Presence User Agent 和 Presentity 组合在一起，Watcher 和 Watcher User Agent 组合在一起，由一个终端来同时支持这两种组合体，这样，一个终端就既能订阅别人的也能发布自己的 presence information</li>
</ul>

<h3 id="toc_2">IRC</h3>

<p>IRC（Internet Relay Chat，互联网中继聊天协议），以服务器中转为原理进行消息转发，机制成熟稳定，应用广泛，可选择的实现较多。</p>

<p><img src="https://py8ifw.dm1.livefilestore.com/y1pYk_HjXE41e-TbezFqQ9VdnWRBcaLlNfkC5_lIfnE7ZKOkLkV20-JdTwxV-3AIbyRetleM8LCZxXFOWV-WpaSmqbIaXbp03UN/irc.png?psid=1" alt="IRC"/></p>

<p>A作为客户端连接到了服务器 S1 的 ChannelX 频道，B 作为客户端连接到了服务器 S2 的 ChannelX 频道，此时 A 发消息后通过 S1 转发给 S2，然后 S2 有把消息发送给了 B。</p>

<p>其中频道是一个广播组，用户可以进入频道，也可以离开频道。当一个用户在频道里发消息时，频道里的其他所有用户都能够收到该消息。当第一个用户进入频道，频道被创建，当最后一个用户离开此频道时，频道被销毁。</p>

<p>在 IRC 服务器网络中，频道由这些服务器共同维护，频道相当于一条通信管道，将所有开通此项频道的服务器贯穿起来，消息在这个管道中流通。</p>

<h3 id="toc_3">PSYC</h3>

<p>PSYC（Protocol for SYnchronous Conferencing，同步会话协议），设计用来取代 IRC，兼容 IRC/XMPP 客户端，据称其可以无限扩容，弥补 IRC/XMPP 中使用 s2s 后服务器网络拓扑膨胀时性能急剧下降的缺陷。</p>

<p>比较新，应用较少，可选择的实现较少。<a href="http://about.psyc.eu/Comparison">http://about.psyc.eu/Comparison</a>。</p>

<h3 id="toc_4">结论</h3>

<p>可选择 XMPP 作为即时消息底层支持协议，Openfire 作为实现。</p>

<p>在单机 Openfire 不能满足用户数时可考虑使用 Openfire Connection Manager 模块增加客户端连接数；配置 Openfire 集群增加整体容量。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-13-irc-intro.html">互联网中继聊天协议（IRC）</a></h1>
			<p class="meta"><time datetime="2013-03-13T10:57:26+08:00" 
			pubdate data-updated="true">2013/3/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>IRC是Internet Relay Chat的英文缩写，中文一般称为互联网中继聊天。它是由芬兰人Jarkko Oikarinen于1988年首创的一种网络聊天协议。经过十年的发展，目前世界上有超过60个国家提供了IRC的服务。在人气最旺的EFnet上，您可以看到上万的使用者在同一时间使用IRC。很多人称其为继bbs后的一种即时闲聊方式，相比于bbs来说，它有着更直观，友好的界面，在这里你可以畅所欲言、而且可以表现动作化，是故使众多的网虫们留连忘返。 </p>

<p>相比于ICQ来说，它更具人性化，而且是即时式的聊天，更接近真实的聊天情景。下面看IRC的工作原理。 IRC的工作原理非常简单，您只要在自己的PC上运行客户端软件，然后通过因特网以IRC协议连接到一台IRC服务器上即可。它的特点是速度非常之快，聊天时几乎没有延迟的现象，并且只占用很小的带宽资源。所有用户可以在一个被称为“Channel(频道)”的地方就某一话题进行交谈或密谈。每个IRC的使用者都有一个Nickname(昵称)，所有的沟通就在他们所在的Channel内以不同的Nickname进行交谈。</p>

<h3 id="toc_0">1. 中转</h3>

<p>理解IRC原理的关键就是理解其&quot;中转&quot;功能。什么是中转呢?我们来做一个比较说明。假设，A与B要交谈。如果不采用中转，那么A直接建立一条到达B的通信隧道，二者通过这条通信隧道进行信息交流，信息流的方向为:A-B和B-A;如果采用中转，则需要有一个第三方来担任中转角色，设为C，A建立一条到达C的通信隧道，B也建立一条到达C的通信隧道，然后A与B通过C来间接进行通信，信息流的方向为:A-C-B和B-C-A。C就起着A与B间的中转站的作用。中转有什么优点呢?中转的最大优点是使“群聊”能够方便地进行。恰当地说，中转模式为信息广播提供了方便。我们来举例子。假设A，B和D三者要一起聊天。如果没有C的中转，那么A要将所说的每句话分别发给B和D;如果有C做中转，那么A将所说的话发给C，然后C将A的话分别发给B和D。可见，当没有中转时，每个参与聊天的计算机都要执行信息广播的任务，当存在中转时，信息广播的任务全由中转者来执行。中转站C的存在使得信息交流过程中的工作任务发生分离，可以把网络环境好、机器配置高的计算机作为中转站来提供服务功能。这就形成了IRC的服务器-客户端模型，聊天者作为客户端，连接到中转站服务器上。</p>

<h3 id="toc_1">2. 服务器网络</h3>

<p>在上面的例子里，只有一个中转者C来承担服务。当聊天者数量很多时，会使C不堪重负。解决的办法是，使用多个服务器，服务器之间互相连接成网络，把聊天者分散到各个服务器上。服务器网络以树型结构互相连通。聊天者可以任选一个服务器连接。举例来说，在北京建立一个IRC服务器，称为BJ，在上海建立一个IRC服务器，称为SH，然后将BJ和SH连接起来，组成一个只有两个服务器的IRC网络。北京的用户连接到BJ上，上海的用户连接到SH上，这样北京的用户就可以与上海的用户聊天了。其他地区的用户可以根据地理位置的远近选择使用BJ或SH服务器。概括地说，聊天网络上的每个服务器都是一个中转站，当它从一个服务器或客户收到一条消息时，就将该消息转发给其它服务器，同时也根据具体情况，决定是否将消息转发给连接到自己的用户。</p>

<h3 id="toc_2">3. 频道</h3>

<p>频道的本质是广播组。用户可以进入一个频道，也可以离开一个频道。当一个用户朝频道说话时，频道里的其他用户都能收到他的话(由服务器中转)。当第一个用户进入频道时，频道被创建，当最后一个用户离开频道时，频道被取消。因此，从用户的角度看，频道就是聊天室。下面说说频道之所以被称为“频道”的原因。如果一个聊天网络有多个服务器，频道要由服务器共同维护。举一个例子。有三个服务器，连接方式为A-B-C。在服务器A上，有第一个用户进入#IRC频道，这时，服务器A上即创建频道&quot;#IRC&quot;，A将频道&quot;IRC&quot;的创建消息发给B和C。由于B和C上都没有用户位于#IRC频道，因此不执行任何操作。在这以后，服务器C上有一个用户进入#IRC频道，此时服务器C上也创建频道&quot;#IRC&quot;，C将&quot;#IRC&quot;的创建消息发给A和B。之后，需要执行以下操作:B上建立频道&quot;#IRC&quot;并将A与C的&quot;#IRC&quot;频道连接起来，组成一个统一的#IRC。现在，虽然B上没有用户位于#IRC频道内，但是B上也开通了#IRC频道。可见，频道好像一条通信管道，将所有开通此频道的服务器贯穿起来，信息流在这个管道中流通。</p>

<h3 id="toc_3">4. 请求与应答</h3>

<p>IRC上的信息交流采用请求与应答的模式。请求是由服务器或客户端发出的，其目的是请求(另)一个服务器执行某个操作或提供某些信息;应答是服务器对一个请求的回应信息。请求通常被称为命令;由于对每种应答都规定了一个三位数字做标识，应答也称为数字应答(numeric reply)。</p>

<p>转自：<a href="http://202.194.28.9:8002/jxzy/refs/htmlfiles/protocol/protocol00055.htm">http://202.194.28.9:8002/jxzy/refs/htmlfiles/protocol/protocol00055.htm</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-07-activemq-jdbc-master-slave.html">ActiveMQ JDBC 主从集群</a></h1>
			<p class="meta"><time datetime="2013-03-07T10:51:38+08:00" 
			pubdate data-updated="true">2013/3/7</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>从 ActiveMQ 4.1 版本开始支持 JDBC 主从集群。</p>

<p>如果你正在使用纯 JDBC 以及非高性能日志，那可以认为数据库是一个存在单点故障的地方。</p>

<p>如果你的应用没有高性能需求，那单一数据库的方式是最容易备份与管理的。（译注：可以理解为使用 JDBC 主从集群使用单一数据库容易配置）</p>

<h3 id="toc_0">启动</h3>

<p>当你使用 JDBC 作为数据源时，你可以使用主从方式进行 ActiveMQ 集群，运行多个代理如下图。</p>

<p>启动时，一个主代理将从数据库获取排它锁——所有其他的从代理将暂停服务，等待获取锁。</p>

<p><img src="https://pyqebw.dm1.livefilestore.com/y1ppjaNmr4-UPWlDqz6BgkecpHO2OIn8ytlTKciI3lsulh6WymOj5EP6-Bly1ki0KJ7IaiKlI63AsnVdmzkztl9oSQYOQ5y3LPX/Startup.png?psid=1" alt="Startup"/></p>

<p>客户端应该使用故障转移传输来连接 ActiveMQ 服务代理。例如使用如下形式的 URL：</p>

<pre><code>failover:(tcp://broker1:61616,tcp://broker2:61616,tcp://broker3:61616)
</code></pre>

<p>主代理必须启动传输连接器后客户端才能连接到，详见文末配置示例。（译注：获取排它锁后，主代理才会启动传输连接器）</p>

<h3 id="toc_1">主代理故障</h3>

<p>当主代理丢失数据库连接或丢失排它锁时，主代理将被关闭。当主代理关闭或故障时，其他任一从代理将获取到排它锁，拓扑逻辑如下图：</p>

<p><img src="https://pyqebw.dm1.livefilestore.com/y1p_vnTTWIQEcYk-YF0FsJRZU_FpdFUKrsMZabyM0MFh4Hk5OjWRJ69dWXulblEjHuOfENQtc8Yf1Tc4iG0NB8tphs8oAq0D1N_/MasterFailed.png?psid=1" alt="MasterFailed"/></p>

<p>一旦某一从代理获取了数据库排它锁，则它将成为主代理，并启用传输连接器。</p>

<p>客户端丢失对已经停止服务的代理，并使用故障转移传输尝试连接其他代理——唯一可用的就是刚才新启的主代理。（译注：客户端应该是逐一尝试，因为此时客户端并不知道哪个地址的代理成为了主代理）</p>

<h3 id="toc_2">主代理重启</h3>

<p>任何时刻你都可以重启集群中已经挂了的代理，重启后拓扑逻辑如下图：</p>

<p><img src="https://pyqebw.dm1.livefilestore.com/y1ppjaNmr4-UPV02ix2WOrBAAzaTjhgLNEdJLliIf3eqhBX-lOg1LfC7M5aS8ST8-LAuC8iMane3psWUYpjXIeerTbrQOUJKc9L/MasterRestarted.png?psid=1" alt="MasterRestarted"/></p>

<h3 id="toc_3">配置 JDBC 主从</h3>

<p>使用 <jdbcPersistenceAdapter/> 避免高性能日志，从而使用默认的 JDBC 主从配置。你只需启动多个代理并配置客户端 URLs 来连接该主从集群。</p>

<p>这些代理都会尝试获取数据库表排它锁，并且只有一个代理会获取到从而成为主代理。</p>

<p>如下的配置示例展示了如何配置 ActiveMQ JDBC 主从集群：</p>

<pre><code>&lt;beans&gt;
 
  &lt;!-- Allows us to use system properties as variables in this configuration file --&gt;
  &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;/&gt;
   
  &lt;broker xmlns=&quot;http://activemq.apache.org/schema/core&quot;&gt;
 
    &lt;destinationPolicy&gt;
      &lt;policyMap&gt;&lt;policyEntries&gt;
         
          &lt;policyEntry topic=&quot;FOO.&gt;&quot;&gt;
            &lt;dispatchPolicy&gt;
              &lt;strictOrderDispatchPolicy /&gt;
            &lt;/dispatchPolicy&gt;
            &lt;subscriptionRecoveryPolicy&gt;
              &lt;lastImageSubscriptionRecoveryPolicy /&gt;
            &lt;/subscriptionRecoveryPolicy&gt;
          &lt;/policyEntry&gt;
 
      &lt;/policyEntries&gt;&lt;/policyMap&gt;
    &lt;/destinationPolicy&gt;
   
   
    &lt;persistenceAdapter&gt;
        &lt;jdbcPersistenceAdapter dataDirectory=&quot;${activemq.base}/activemq-data&quot;/&gt;
 
        &lt;!-- 
        &lt;jdbcPersistenceAdapter dataDirectory=&quot;activemq-data&quot; dataSource=&quot;#oracle-ds&quot;/&gt;
        --&gt;
    &lt;/persistenceAdapter&gt;
   
    &lt;transportConnectors&gt;
       &lt;transportConnector name=&quot;default&quot; uri=&quot;tcp://localhost:61616&quot;/&gt;
    &lt;/transportConnectors&gt;
     
  &lt;/broker&gt;
   
  &lt;!--  This xbean configuration file supports all the standard spring xml configuration options --&gt;
   
  &lt;!-- Postgres DataSource Sample Setup --&gt;
  &lt;!-- 
  &lt;bean id=&quot;postgres-ds&quot; class=&quot;org.postgresql.ds.PGPoolingDataSource&quot;&gt;
    &lt;property name=&quot;serverName&quot; value=&quot;localhost&quot;/&gt;
    &lt;property name=&quot;databaseName&quot; value=&quot;activemq&quot;/&gt;
    &lt;property name=&quot;portNumber&quot; value=&quot;0&quot;/&gt;
    &lt;property name=&quot;user&quot; value=&quot;activemq&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt;
    &lt;property name=&quot;dataSourceName&quot; value=&quot;postgres&quot;/&gt;
    &lt;property name=&quot;initialConnections&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;maxConnections&quot; value=&quot;10&quot;/&gt;
  &lt;/bean&gt;
  --&gt;
   
  &lt;!-- MySql DataSource Sample Setup --&gt;
  &lt;!-- 
  &lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;activemq&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt;
    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;
  &lt;/bean&gt;
  --&gt; 
    
  &lt;!-- Oracle DataSource Sample Setup --&gt;
  &lt;!--
  &lt;bean id=&quot;oracle-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;oracle.jdbc.driver.OracleDriver&quot;/&gt;
    &lt;property name=&quot;url&quot; value=&quot;jdbc:oracle:thin:@localhost:1521:AMQDB&quot;/&gt;
    &lt;property name=&quot;username&quot; value=&quot;scott&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;tiger&quot;/&gt;
    &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt;
  &lt;/bean&gt;
  --&gt;
       
  &lt;!-- Embedded Derby DataSource Sample Setup --&gt;
  &lt;!-- 
  &lt;bean id=&quot;derby-ds&quot; class=&quot;org.apache.derby.jdbc.EmbeddedDataSource&quot;&gt;
    &lt;property name=&quot;databaseName&quot; value=&quot;derbydb&quot;/&gt;
    &lt;property name=&quot;createDatabase&quot; value=&quot;create&quot;/&gt;
  &lt;/bean&gt;
  --&gt; 
 
&lt;/beans&gt;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-05-hello-world.html">为什么这段代码输出的是”Hello World”</a></h1>
			<p class="meta"><time datetime="2013-03-05T15:36:51+08:00" 
			pubdate data-updated="true">2013/3/5</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Stackoverlfow.com上有一篇有趣的讨论帖：</p>

<p>在这篇帖子里提到了如下的程序：</p>

<pre><code>import java.util.*;
 
public class HelloWorld{
 
    public static String randomString(int i)
    {
        Random ran = new Random(i);
        StringBuilder sb = new StringBuilder();
        for (int n = 0; ; n++)
        {
            int k = ran.nextInt(27);
            if (k == 0)
                break;
 
            sb.append((char)(&#39;`&#39; + k));
        }
 
        return sb.toString();
    }
 
    public static void main(String[] args){
        System.out.println(randomString(-229985452)+&quot; &quot;+randomString(-147909649));
    }
 
}
</code></pre>

<p>明明是在程序里使用了java.util.Ramdom()函数产生随机数，为什么每次打出的结果都是Hello world? 各位程序员，你们怎么看？请务必要独立思考后再看下面的内容哦~</p>

<p>--------------- 独立思考的分割线 ---------------</p>

<p>OK，假如你通过独立思考了以后有了答案，那么可以参照一下下面的各种理解，这些都是来自stackoverflow对此问题的回复。</p>

<p>首先看一下这个程序的工作原理：</p>

<p>通过这句命令首先得到的六个数是:</p>

<p>8 5 12 12 15 0</p>

<p>然后，通过new Random(-147909649).nextInt(27)得到的6个数是：</p>

<p>23 15 18 12 4 0</p>

<p>这样一来，根据：sb.append((char) (‘`’+n)); 得到：</p>

<p>8 + 96 = 104 --&gt; h <br/>
5 + 96 = 101 --&gt; e <br/>
12 + 96 = 108 --&gt; l <br/>
12 + 96 = 108 --&gt; l <br/>
15 + 96 = 111 --&gt; o <br/>
23 + 96 = 119 --&gt; w <br/>
15 + 96 = 111 --&gt; o <br/>
18 + 96 = 114 --&gt; r <br/>
12 + 96 = 108 --&gt; l <br/>
4 + 96 = 100 --&gt; d</p>

<p>整个程序的执行就是这样。</p>

<p>关于这个程序的运行原理的解释，最置顶的一个回复如下：</p>

<p>“如果java.util.Random是被一个具体的数字做为“随机数种子”而实例化（在本例中是-229985452和-147909649），那么该实例就会以这个随机数种子作为随机算法产生随机数的基础。</p>

<p>使用同样的种子实例化的Random对象，每次运行时将会遵循同一种模式，产生同样的序列。”<br/>
这就是为什么每次运行该程序都会产生同样的结果的原理啦~</p>

<p>当然，关于这个话题，高手林立的Stackoverflow上是不缺乏懂行的专家和见解的。其实对于这个帖子本身，很快就有人论坛上提出了，这不是一个新鲜的问题，之前的某个帖子已经很详细地说明了原理：</p>

<p>参见：<a href="http://stackoverflow.com/questions/8044570/why-does-the-use-of-random-with-a-hardcoded-seed-always-produce-the-same-results">stackoverflow.com/questions/8044570/why-does-the-use-of-random-with-a-hardcoded-seed-always-produce-the-same-results</a></p>

<p>还有的人就非常精辟地指出了，这是计算机所谓的“伪随机数”问题（详细见扩展阅读），更有部分Geek的回复者从计算机理论和概率论的角度说明了，应该如何找到这些神奇的“随机数种子”。能够把这么一个原意为搞笑的帖子发展到理论的高度~，相信这应该也是计算机科学家的境界和觉悟了吧！</p>

<h4 id="toc_0">扩展阅读：计算机伪随机数问题</h4>

<p>随机数在计算机科学和计算机应用中都扮演非常重要的角色（例如通信、安全、密码等方面）。但是，由于计算机本身的结构和原理，实际上是无法产生出所谓的“绝对随机数”的。也就是说，计算机所产生的随机数，实际上是有某种规律或者模式的“伪随机数”（Pseudo random number)。</p>

<p>如何用计算机程序产生高质量随机数，这是计算机理论科学中的一个非常重要的课题。尤其是在复杂的计算环境下的高质量随机数的产生，需要牵涉到非常高深的计算科学和数学方面的理论研究。</p>

<p>在计算机随机数产生的理论研究上，美籍华人姚期智（目前任职于清华大学）是世界顶尖的专家。正是因为他在计算理论和伪随机数产生方面多项贡献，于2000年获得了ACM图灵奖，这也是计算机科学领域的最高奖项。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-02-22-log4j-2.html">Log4j 2 介绍</a></h1>
			<p class="meta"><time datetime="2013-02-22T15:44:19+08:00" 
			pubdate data-updated="true">2013/2/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">关于Log4j 2</h3>

<p>Log4j 2 是Log4j的升级版，与之前的版本Log4j 1.x相比、有重大的改进，在修正了Logback固有的架构问题的同时，改进了许多Logback所具有的功能。</p>

<p>Log4j 2的特性以及改进有：</p>

<ul>
<li>API分离：Log4j将API与实现分离开来。开发人员现在可以很清楚地知道能够使用哪些没有兼容问题的类和方法，同时又允许通过自己实现来增强功能。</li>
<li>改进的性能：Log4j 2的性能在某些关键领域比Log4j 1.x更快，而且大多数情况下与Logback相当。更多的信息请参考性能。</li>
<li>多个API支持：Log4j 2提供最棒的性能的同时，还支持SLF4J和公共日志记录API。</li>
<li>自动配置加载：像Logback一样，一旦配置发生改变，Log4j 2可以自动载入这些更改后的配置信息，又与Logback不同，配置发生改变时不会丢失任何日志事件。</li>
<li>高级过滤功能：与Logback类似，Log4j 2可以支持基于上下文数据、标记，正则表达式以及日志事件中的其他组件的过滤。Log4j 2 能够专门指定适用于所有的事件，无论这些事件在传入Loggers之前还是正在传给 appenders。另外，过滤器还可以与Loggers关联起来。与Logback不同的是，Filter公共类可以用于任何情况。</li>
<li>插件架构：所有可以配置的组件都以Log4j插件的形式来定义。同样地，不需要修改任何Log4j代码就可以创建新的Appender、Layout、Pattern Convert 等等。Log4j自动识别预定义的插件，如果在配置中引用到这些插件，Log4j就自动载入使用。</li>
<li>属性支持：属性可以在配置文件中引用，也可以直接替代或传入潜在的组件，属性在这些组件中能够动态解析。属性可以是配置文件，系统属性，环境变量，线程上下文映射以及事件中的数据中定义的值。用户可以通过增加自己的Lookup插件来定制自己的属性。</li>
</ul>

<h3 id="toc_1">文档</h3>

<p>Log4j 2用户文档可在<a href="http://logging.apache.org/log4j/2.x/manual/index.html">这里</a>在线阅读，或下载成<a href="http://logging.apache.org/log4j/2.x/log4j-users-guide.pdf">PDF</a>格式。</p>

<h3 id="toc_2">要求</h3>

<p>Log4j 2至少要求安装Java 5，然而使用Java 6的增强功能可以提高性能。有些特性需要一些可选的依赖，这些依赖在相关特性的文档中有说明。</p>

<h3 id="toc_3">资讯</h3>

<p>Log4j 2现在已经可以测试。API与Log4j 1.x 不兼容，不过通过适配器可以继续使用Log4j 1.x API。 适配器同样适用于Commons Logging和SLF4J.</p>

<h3 id="toc_4">以前的发布</h3>

<p>以前的Apache log4j发布可以从<a href="http://archive.apache.org/dist/logging/log4j">archive repository</a>找到。</p>

<h3 id="toc_5">Log4j 2.x的构建与安装</h3>

<h4 id="toc_6">构建</h4>

<p>Log 4j 运行在Apache 软件基金会下的代码仓库中。<a href="http://logging.apache.org/log4j/2.x/source-repository.html">Log4j 代码仓库</a>可以找到如何获取当前绝大多的源代码的细节。可以根据<a href="http://logging.apache.org/log4j/2.x/download.html">Log4j下载说明</a>下载最新的源代码</p>

<p>Log4j 2.x 使用Maven 2或3作为生成工具。在root目录中仅运行”mvn install”就可以生成Log4j.</p>

<h4 id="toc_7">程序中如何使用</h4>

<p>在你的程序中使用Log4j之前必须确保API和Core jars 在程序的classpath中。使用Maven将下面的依赖加入pom.xml.</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
&lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
&lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependecies&gt;
</code></pre>

<h4 id="toc_8">Apache 公共日志记录</h4>

<p>公共日志记录在许多组件中使用，不同的组建可以选择特定的日志记录的实现。为了把这些组件的日志功能集成到Log4j 2，需要加入下面的依赖，而且不能删除Commons Logging jar</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j.adapters&lt;/groupId&gt;
&lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependecies&gt;
</code></pre>

<h4 id="toc_9">SLF4J</h4>

<p>SLF4J是另一个受欢迎的日志记录API，通过加入下面的依赖以及SLF4J依赖就可以将其绑定到Log4j 2.</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j.adapters&lt;/groupId&gt;
&lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependecies&gt;
</code></pre>

<h4 id="toc_10">发布更改记录</h4>

<ul>
<li><a href="http://logging.apache.org/log4j/2.x/jira-report.html#a1.0-alpha1">JIRA更改记录</a></li>
<li><a href="http://logging.apache.org/log4j/2.x/changes-report.html#a1.0-alpha1">Manual更改记录</a></li>
</ul>

<h4 id="toc_11">升级注意事项</h4>

<p>Apache Log4j 2不支持兼容老版本。如果要升级到Log4j 2请铭记下列几条：</p>

<ul>
<li>需要Java 5</li>
<li>简化了XML配置，不兼容logj4 1.x。</li>
<li>不支持属性文件配置</li>
<li>支持JSON配置</li>
<li>虽然Log4j 2不能与Log4j 1.x直接兼容，但是可以通过自带兼容桥梁来降低升级带来的代码更改。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-01-12-java-oom.html">诊断Java.lang.OutOfMemoryError（OOM）</a></h1>
			<p class="meta"><time datetime="2013-01-12T11:38:50+08:00" 
			pubdate data-updated="true">2013/1/12</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在跟踪性能问题时，堆内存是首先应该被监控的最重要的组件之一。一旦堆内存的实际使用量超过其所允许的堆空间，就会产生堆内存压力。而这将导致频繁的全面垃圾回收事件，垃圾回收将窃取CPU周期，轻则导致响应时间延迟，重则导致必须重新启动Java虚拟机才能解决的内存溢出错误。</p>

<h3 id="toc_0">内存溢出错误（OOM）</h3>

<p>当我运行应用时，出现了如下异常：</p>

<ul>
<li>java.lang.OutOfMemoryError: GC overhead limit exceeded[7,9]</li>
<li>java.lang.OutOfMemoryError: Java heap space</li>
</ul>

<p>第一条信息意味着，出于某种原因，垃圾收集器每次执行都花费了大量时间但只回收了很少量的内存，当我删除了如下代码后：</p>

<pre><code>System.gc();
</code></pre>

<p>第一条信息消失了，取而代之的，系统出现了第二条信息。很明显堆内存空间依然存在问题。下面是我调查问题的步骤：</p>

<ol>
<li>添加下面的Java启动参数</li>
<li>-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps

<ul>
<li>系统会生成gc.log文件</li>
</ul></li>
<li>-XX:+HeapDumpOnOutOfMemoryError

<ul>
<li>系统会生成堆内存转储文件</li>
</ul></li>
<li>分析日志文件:</li>
<li>使用常规的文本编辑器查看gc.log 文件。</li>
<li>使用 Eclipse Memory Analyzer 查看 堆内存转储文件 (例如, java_xxx.hprof)</li>
</ol>

<p>请注意，本文所讨论的所有虚拟机参数都是基于Hotspot虚拟机的。</p>

<p>Java命令行参数说明:</p>

<ul>
<li>-XX:+PrintGCDetails

<ul>
<li>打印更多的关于垃圾收集的信息。</li>
</ul></li>
<li>-XX:+PrintGCTimeStamps

<ul>
<li>打印从HotSpot 虚拟机开始执行直至垃圾收集事件发生所花费的时间（以秒为单位）。</li>
</ul></li>
<li>-Xloggc:gc.log

<ul>
<li>在每次垃圾收集时打印堆内存以及垃圾收集的信息。</li>
</ul></li>
</ul>

<p>在JDeveloper中可以按照如下方式设定：</p>

<ol>
<li>右键选择你的项目（例如ViewController），显示出菜单</li>
<li>选择Project Properties…</li>
<li>选择Run/Debug/Profile</li>
<li>选择你Run Configuration(例如, Default)</li>
<li>点击Edit按钮</li>
<li>在Java虚拟机参数栏位设定 -Xloggc:gc.log -XX:-PrintGCDetails</li>
</ol>

<p>运行你的应用并重现内存溢出异常，系统将会生成日志文件gc.log，<br/>
我的是在如下目录：</p>

<pre><code>…/system11.1.1.5.37.60.13/DefaultDomain
</code></pre>

<p>因为我的Web应用是部署在集成的WLS中，并且通过DefaultDomain来执行。<br/>
所以，想要理解gc.log文件的格式，请参考关联阅读[5,15]。</p>

<p>不过，gc.log文件并不能真正的帮到我们，因为他只是简要的打印了堆内存问题，</p>

<p>但并没有指出问题出在哪。<br/>
接下来我要做的是添加如下参数，并重新执行服务。<br/>
<strong>-XX:+HeapDumpOnOutOfMemoryError</strong><br/>
当服务发生堆内存错误时，会生成java_pid30835.hprof文件。</p>

<h3 id="toc_1">Eclise内存分析器（Eclipse Memory Analyzer）</h3>

<p>堆内存转储文件由HPROF（堆内存和CPU分析工具）生成，堆内存转储文件是2进制格式的，因此必须使用Eclpse Memory Analyzer 来查看。</p>

<p>你可以通过Eclipse Update manager 来安装Eclipse MAT，选择”General Purpose Tools “并安装”Memory Analyser (Incubation)”以及”Memory Analyser (Charts)”。</p>

<p>安装之后，双击堆内存转储文件并且选择”Leak Suspects Report”</p>

<p>Eclipse MAT会显示图表以及问题的嫌疑人：</p>

<h3 id="toc_2">调整堆内存空间</h3>

<p>如果你观察到垃圾收集日志文件中有内存溢出错误，那么可以尝试将Java堆内存空间调整为你能够分配给Java虚拟机的物理内存空间的80%，基于具体是老年代空间还是永久代空间发生内存溢出，你可以像这样调整内存空间。</p>

<ul>
<li>针对老年代发生内存溢出

<ul>
<li>increase -Xms and -Xmx</li>
</ul></li>
<li>针对永久代发生内存溢出

<ul>
<li>increase -XX:PermSize and -XX:MaxPermSize</li>
</ul></li>
</ul>

<p>参考文献：</p>

<ul>
<li><a href="http://www.vogella.de/articles/Eclipse/article.html#updatemanager">Eclipse Update Manager</a></li>
<li><a href="http://www.vogella.de/articles/EclipseMemoryAnalyser/article.html">Eclipse Memory Analyzer</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java Hotspot VM Options</a></li>
<li><a href="http://xmlandmore.blogspot.com/2011/04/integrated-weblogic-server-wls.html">Integrated WebLogic Server (WLS)</a></li>
<li><a href="http://java.sun.com/docs/hotspot/gc1.4.2/example.html">Diagnosing a Garbage Collection problem</a></li>
<li><a href="http://www.oracle.com/technetwork/java/faq-140837.html">Frequently Asked Questions about Garbage Collection</a></li>
<li><a href="http://stackoverflow.com/questions/1393486/what-means-the-error-message-java-lang-outofmemoryerror-gc-overhead-limit-excee">GC Overhead Limit Exceeded</a></li>
<li><a href="http://java.sun.com/developer/technicalArticles/Programming/HPROF.html">HPROF: A Heap/CPU Profiling Tool in J2SE 5.0</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#par_gc.oom">Java SE 6 HotSpottm Virtual Machine Garbage Collection Tuning</a></li>
<li>Java Performance by Charlie Hunt and Binu John</li>
<li><a href="http://xmlandmore.blogspot.com/2012/01/understanding-garbage-collection.html">Understanding Garbage Collection</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java HotSpot VM Options</a></li>
<li><a href="http://www.tagtraum.com/gcviewer.html">GCViewer</a> (a free open source tool)</li>
<li><a href="http://xmlandmore.blogspot.com/2012/03/understanding-garbage-collector-output.html">Understanding Garbage Collector Output of Hotspot VM</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-01-11-how-deep-unit-test.html">单元测试要做多深？——测试驱动开发（TDD)引发的争论</a></h1>
			<p class="meta"><time datetime="2013-01-11T13:05:38+08:00" 
			pubdate data-updated="true">2013/1/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>著名的IT技术问答网站www.stackoverflow.com上浮现了这么一篇有趣的贴子：</p>

<p><a href="http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests">单元测试要做多深？</a></p>

<p>发问的人是一个注册ID为：<a href="http://stackoverflow.com/users/1116/john-nolan">John Nolan</a> 的用户，TA问到：</p>

<p>“我发现驱动测试开发需要花很多时间才能把测试环境设置好，而我又是个懒人，希望代码写得尽可能越少越好。一般来说我在操作的时候会先测试构造函数是否设置了所有属性，但是这样做是不是有点儿太过了？</p>

<p>所以我的问题是：你们在写单元测试代码的时候，一般都把粒度控制到什么级别啊？</p>

<p>..还有，有没有那种测试过度的案例啊？”</p>

<p>目前，对于该问题置顶的回复，是大名鼎鼎的敏捷领袖 <a href="http://stackoverflow.com/users/13842/kent-beck">Kent Beck</a> , 他的观点是：</p>

<p>“我拿了工资是要去写运行良好的程序，而不是为了测试。所以我的观点是，在可信任的范围内，测试得越少越好（译注： 猜想Kent的意思应该是“单元测试要集中自己没有把握的地方，对于自己认为没有问题、可以信任的代码，测试越少越好。毕竟开发不能为了单元测试而去做单元测试”） 。如果我不是那种经常容易犯低级错误（比如什么在构造函数里错误设置了属性）的人，那我就不会去每次写代码测试它。我更倾向于去测试那些逻辑错误，所以，当我在处理比较复杂的逻辑条件的时候，我会非常小心谨慎。当我在一个团队里编程时，我会调整我的策略，我会非常小心地去测试那些大家写的，容易出错的代码。</p>

<p>当然，基于我上述的观点，不同的人会有不同的看法。不过，如果真要为“测试工作怎样才能最好地适用于编码内循环”这个问题找答案，目前也没有人能给出真正成熟的见解。鉴于这种情形，我认为我的的观点还是可以立足的。从现在起的10到20年间，还会有更多的统一理论教导我们应该写哪些测试，不应该写哪些测试，以及二者有何区别。同时，各种说法的试验也都在进行当中。”</p>

<p>大牛的观点自然是相当火爆的，Kent Beck自己做为XP和TDD的创始人，貌似对自己的领域唱出了反调！下面毫无疑问地跟帖无数，褒贬不一，在此就不一一翻译了。感兴趣的同学可以去原文围观。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-12-26-building-mobile-applications.html">打造企业级应用：HTML5，Hybrid，Native Dilemma之间的对比</a></h1>
			<p class="meta"><time datetime="2012-12-26T23:59:26+08:00" 
			pubdate data-updated="true">2012/12/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这篇文章主要关于如何开发企业级移动应用。今天我读了Charlie的关于<a href="http://www.geekwire.com/2012/apps-cross-platform/">移动应用开发的文章</a>，并且从企业的角度分析了hybrid应用的情况。</p>

<h3 id="toc_0">总览</h3>

<p>最近我关于开发企业级移动应用的交谈大部分都是以“我是否该用Hybrid或者Native”这样的问题开始。是的，很多组织出于成本上的考虑对“Hybrid”方式很感兴趣，但依我之见，任何决定都应以用户为导向而非成本。所以，要得出这个答案要这么去想“怎么才能给最终用户最好的用户体验”，而不是一直问“我们怎么才能降低成本”。不光企业级应用，所有应用都是这样的。</p>

<p>另外，从企业的角度来说，我认为达到终端独立是另一种降低成本和将来达到投资目的的方式。所以，选HTML5，Hybrid还是Native只是决定选择的一个因素，这里还有一些当你讨论移动策略时要考虑的因素：</p>

<p><img src="/resource/image/2012-12-26-building-mobile-applications/vs.jpg" alt="对比图片"/></p>

<p>设想阶段要考虑的：<br/>
1. 目标用户分析<br/>
2. 以一个简单的框架开始，像Forrester的POST approach<br/>
3. 差距分析和组合合理化</p>

<p>为移动应用的开发和分发制定策略<br/>
1. 移动web/纯HTML/JSS<br/>
2. Hybrid 应用（本地中的HTML5/JS应用，像Phone Gap 或者Titanium中的本地部分或插件）<br/>
3. 本地应用</p>

<p>关于通用服务层的考虑：<br/>
1. 创建或实现一个可扩展的通用服务层<br/>
2. 在服务层和传统系统之间实现一个可扩展的中间层<br/>
3. 确立保准（就像用REST）<br/>
4. 为媒体分发确定和整合内容分发网络</p>

<p>测试模型<br/>
1. 安全和性能<br/>
2. 基于设备的测试</p>

<p>提交管理<br/>
1. 支付模型<br/>
2. 已提交模型的跟踪<br/>
3. 分析<br/>
4. 反馈跟踪<br/>
5. 继续开发</p>

<p>好了，这些就是移动开发策略的一部分，尤其当你讨论企业移动应用时，移动终端独立是关键点，开发者要理解使产品有逻辑性和数据的有效性对多种终端的必要性。</p>

<p>在你周围已经存在的数据和智能中，REST已经成为越来越多的创建公共服务层的默认选择。</p>

<h3 id="toc_1">Hybrid 对 Native</h3>

<p>现在关于Hybrid和Native，下面是我看到的主要的利弊两方面的东西：</p>

<h4 id="toc_2">Hybrid 应用</h4>

<p>有利的方面：<br/>
* 不需要为某一特定平台开发<br/>
* 更好的投资回报率，代码可在多个平台重复使用<br/>
* 仍可以访问设备的某些特性<br/>
* 可以打包到另外的渠道</p>

<p>不足的方面：<br/>
* 特殊化的UI很难做<br/>
* 响应不够快，且不像纯本地应用那样富含多种特性<br/>
* 当实现特定的最优化的特性时，可以遇到限制。</p>

<h4 id="toc_3">本地应用</h4>

<p>有利的方面：<br/>
* 高度订制，能满足边界条件。<br/>
* 很高的可用性。</p>

<p>不足的方面：<br/>
* 平台的多样性<br/>
* 对每个平台的投入<br/>
* 没有统一的代码库及重用性</p>

<h3 id="toc_4">更多</h3>

<p>当你在考虑企业级移动应用时，再说一次，别在是用Hybrid还是Native之间考虑了。</p>

<p>从中间件的角度</p>

<ol>
<li><p>选择一种策略，以使存储、计算你的移动应用的资源可以在移动设备，本地存储和云计算设施中实现。</p></li>
<li><p>在移动应用间连接，通信，代理时使用代理服务，</p>

<ul>
<li>在代理的最上层自定义实现，就像Windows Azure Service Bus</li>
<li>创建面向web架构的移动应用，就像Marlabs Matrix平台</li>
<li>第三方移动中间平台，像Syclo等</li>
</ul></li>
<li><p>如果需要支持多种认证机制，像Azure Federated Authentication.，那就用基于联合的云认证服务。</p></li>
<li><p>采用基于push通知服务的云服务从你的移动设备发送和接受消息。</p></li>
<li><p>选择一个支持比特率传输视频内容的合适的内容分发网络，例如Azure CDN或者Limelight True Reach API.</p></li>
<li><p>使APIs支持扩展，跟踪，反馈。</p></li>
</ol>

<p>提交管理包括为支付模型，使用追踪，分析和支持反馈制定一个合适的策略。提交管理应该保证：<br/>
* 提交应用到应用商店时要有最少的条件<br/>
* 适当听取用户的建议—反馈和评分应用来确定哪些可要哪些可不要<br/>
* 发布和更新要符合用户的期望</p>

<p>所以，编码快乐！</p>

<p>英文原文： <a href="http://css.dzone.com/articles/building-mobile-applications">Building Mobile App for Enterprise</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-12-03-java-objects-memory-structure.html">Java对象内存结构</a></h1>
			<p class="meta"><time datetime="2012-12-03T23:21:51+08:00" 
			pubdate data-updated="true">2012/12/3</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Java程序员有时还是希望能知道一个Java对象到底用了多少内存的。不过这个问题的答案并不简单。</p>

<p>首先要区分清楚的是shallow size和deep size。Shallow size是指对象自身占用的内存大小，其引用对象的大小不算在内。而deep size，则是自身所占内存大小和其递归引用的所有对象所占内存大小的总和。大多数情况下，你会希望获得一个对象的deep size，但是为了知道这个值，首先要知道怎么算shallow size，下面我来介绍一下。</p>

<p>有人抱怨JVM规范中没有针对运行时Java对象的内存结构的说明，这也就是说JVM供应商可以按照自己的需要来实现这一点。后果就是，同一个类在不同的JVM上运行的实例对象占用的内存大小会有差别。好在是世界上大部分人（包括我在内）都使用Sun HotSpot虚拟机，这就大大简化了这个问题。我们接下来的讨论也会基于32位的Sun公司的JVM。下面我介绍一些规则来辅助解释JVM如何组织对象在内存中的布局的。</p>

<h3 id="toc_0">没有实例属性的类的内存布局</h3>

<p>在Sun JVM中，（除了数组之外的）对象都有两个机器字（words）的头部。第一个字中包含这个对象的标示哈希码以及其他一些类似锁状态和等标识信息，第二个字中包含一个指向对象的类的引用。另外，任何对象都是8个字节为粒度进行对齐的。这就是对象内存布局的第一个规则：</p>

<p>规则1：任何对象都是8个字节为粒度进行对齐的。</p>

<p>比如，如果调用new Object()，由于Object类并没有其他没有其他可存储的成员，那么仅仅使用堆中的8个字节来保存两个字的头部即可。</p>

<h3 id="toc_1">继承了Object的类的内存布局</h3>

<p>除了上面所说的8个字节的头部，类属性紧随其后。属性通常根据其大小来排列。例如，整型（int）以4个字节为单位对齐，长整型（long）以8个字节为单位对齐。这里是出于性能考虑而这么设计的：通常情况下，如果数据以4字节为单位对齐，那么从内存中读4字节的数据并写入到处理器的4字节寄存器是性价比更高的。</p>

<p>为了节省内存，Sun VM并没有按照属性声明时的顺序来进行内存布局。实际上，属性在内存中按照下面的顺序来组织：</p>

<ol>
<li><p>双精度型（doubles）和长整型（longs）</p></li>
<li><p>整型（ints）和浮点型（floats）</p></li>
<li><p>短整型（shorts）和字符型（chars）</p></li>
<li><p>布尔型（booleans）和字节型（bytes）</p></li>
<li><p>引用类型（references）</p></li>
</ol>

<p>内存使用率会通过这个机制得到优化。例如，如下声明一个类：</p>

<pre><code>class MyClass {
 
       byte a;
 
       int c;
 
       boolean d;
 
       long e;
 
       Object f;          
 
}
</code></pre>

<p>如果JVM并没有打乱属性的声明顺序，其对象内存布局将会是下面这个样子：</p>

<pre><code>[HEADER:  8 bytes]  8
[a:       1 byte ]  9
[padding: 3 bytes] 12
[c:       4 bytes] 16
[d:       1 byte ] 17
[padding: 7 bytes] 24
[e:       8 bytes] 32
[f:       4 bytes] 36
[padding: 4 bytes] 40
</code></pre>

<p>此时，用于占位的14个字节是浪费的，这个对象一共使用了40个字节的内存空间。但是，如果用上面的规则对这些对象重新排序，其内存结果会变成下面这个样子：</p>

<pre><code>[HEADER:  8 bytes]  8
[e:       8 bytes] 16
[c:       4 bytes] 20
[a:       1 byte ] 21
[d:       1 byte ] 22
[padding: 2 bytes] 24
[f:       4 bytes] 28
[padding: 4 bytes] 32
</code></pre>

<p>这次，用于占位的只有6个字节，这个对象使用了32个字节的内存空间。</p>

<p>因此，对象内存布局的第二个规则是：</p>

<p>规则2：类属性按照如下优先级进行排列：长整型和双精度类型；整型和浮点型；字符和短整型；字节类型和布尔类型，最后是引用类型。这些属性都按照各自的单位对齐。</p>

<p>现在我们知道如何计算一个继承了Object的类的实例的内存大小了。下面这个例子用来做下练习: java.lang.Boolean。这是其内存布局：</p>

<pre><code>[HEADER:  8 bytes]  8
[value:   1 byte ]  9
[padding: 7 bytes] 16
</code></pre>

<p>Boolean类的实例占用16个字节的内存！惊讶吧？（别忘了最后用来占位的7个字节）。</p>

<h3 id="toc_2">继承其他类的子类的内存布局</h3>

<p>JVM所遵守的下面3个规则用来组织有父类的类的成员。对象内存布局的规则3如下：</p>

<p>规则3：不同类继承关系中的成员不能混合排列。首先按照规则2处理父类中的成员，接着才是子类的成员。</p>

<p>举例如下：</p>

<pre><code>class A {
   long a;
   int b;
   int c;
}
 
class B extends A {
   long d;
}
</code></pre>

<p>类B的实例在内存中的存储如下：</p>

<pre><code>[HEADER:  8 bytes]  8
[a:       8 bytes] 16
[b:       4 bytes] 20
[c:       4 bytes] 24
[d:       8 bytes] 32
</code></pre>

<p>如果父类中的成员的大小无法满足4个字节这个基本单位，那么下一条规则就会起作用：</p>

<p>规则4：当父类中最后一个成员和子类第一个成员的间隔如果不够4个字节的话，就必须扩展到4个字节的基本单位。</p>

<p>举例如下：</p>

<pre><code>class A {
   byte a;
}
 
class B {
   byte b;
}
[HEADER:  8 bytes]  8
[a:       1 byte ]  9
[padding: 3 bytes] 12
[b:       1 byte ] 13
[padding: 3 bytes] 16
</code></pre>

<p>注意到成员a被扩充了3个字节以保证和成员b之间的间隔是4个字节。这个空间不能被类B使用，因此被浪费了。</p>

<p>最后一条规则在下面情况下用来节省一些空间：如果子类成员是长整型或双精度类型，并且父类并没有用完8个字节。</p>

<p>规则5：如果子类第一个成员是一个双精度或者长整型，并且父类并没有用完8个字节，JVM会破坏规则2，按照整形（int），短整型（short），字节型（byte），引用类型（reference）的顺序，向未填满的空间填充。</p>

<p>举例如下：</p>

<pre><code>class A {
  byte a;
}
 
class B {
  long b;
  short c;  
  byte d;
}
</code></pre>

<p>其内存布局如下：</p>

<pre><code>[HEADER:  8 bytes]  8
[a:       1 byte ]  9
[padding: 3 bytes] 12
[c:       2 bytes] 14
[d:       1 byte ] 15
[padding: 1 byte ] 16
[b:       8 bytes] 24
</code></pre>

<p>在第12字节处，类A“结束”的地方，JVM没有遵守规则2，而是在长整型之前插入一个短整型和一个字节型成员，这样可以避免浪费3个字节。</p>

<h3 id="toc_3">数组的内存布局</h3>

<p>数组有一个额外的头部成员，用来存放“长度”变量。数组元素以及数组本身，跟其他常规对象同样，都需要遵守8个字节的边界规则。</p>

<p>下面是一个有3个元素的字节数组的内存布局：<br/>
<code><br/>
[HEADER:  12 bytes] 12<br/>
[[0]:      1 byte ] 13<br/>
[[1]:      1 byte ] 14<br/>
[[2]:      1 byte ] 15<br/>
[padding:  1 byte ] 16<br/>
</code></p>

<p>下面是一个有3个元素的长整型数字的内存布局：</p>

<pre><code>[HEADER:  12 bytes] 12
[padding:  4 bytes] 16
[[0]:      8 bytes] 24
[[1]:      8 bytes] 32
[[2]:      8 bytes] 40
</code></pre>

<h3 id="toc_4">内部类的内存布局</h3>

<p><a href="/2012-11-22-inner-classes-static-and-non-static.html">非静态内部类</a>（Non-static inner classes）有一个额外的“隐藏”成员，这个成员是一个指向外部类的引用变量。这个成员是一个普通引用，因此遵守引用内存布局的规则。内部类因此有4个字节的额外开销。</p>

<p>最后的一点想法</p>

<p>我们已经学习了在32位Sun JVM中如何计算Java对象的shallow size。知道内存是如何组织的有助于理解类实例占用的内存数。</p>

<p>英文原文：<a href="http://www.codeinstructions.com/2008/12/java-objects-memory-structure.html">Code Instructions</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-12-01-eclipse-plugin.html">Eclipse 插件开发</a></h1>
			<p class="meta"><time datetime="2012-12-01T22:50:33+08:00" 
			pubdate data-updated="true">2012/12/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>《<a href="http://book.douban.com/subject/1933347/">ECLIPSE插件开发(原书第3版)</a>》是一本由两位长期从事Java商业软件开发的技术专家编写的关于开发Eclipse商业插件的指南。本书主要介绍了开发Eclipse商业插件的完整过程，并从标准窗口小部件工具集、命令与操作、视图、透视图、实现帮助、国际化等方面对创建Eclipse商业插件进行了详细描述。本书既包含了开发Eclipse插件的基础理论，也涵盖了大量关于Eclipse插件开发的细节，并且提供了详细的示例代码、相关的程序列表、图表、屏幕截图等。</p>

<p>本书不仅适用于Eclipse插件开发的初学者，对于Eclipse商业软件开发人员也有很高的参考价值。</p>

<p>面向Eclipse 4的新版本”<a href="http://www.amazon.com/Eclipse-Plug-ins-4th-Edition-Series/dp/0321774159/ref=sr_1_3?ie=UTF8&amp;qid=1357042883&amp;sr=8-3&amp;keywords=eclipse+4">Eclipse Plugins(4th edition)</a>“会在2013年7月发布。</p>

<p>开发入门可以参考一下的文章</p>

<p><a href="http://www.ibm.com/developerworks/cn/java/l-eclipse-plugin/">Eclipse 简介和插件开发</a></p>

<p><a href="http://www.cnblogs.com/liuzhuo">Eclipse插件开发之基础篇</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-11-29-sqlite-use-in-android.html">SQLite在Android中的使用</a></h1>
			<p class="meta"><time datetime="2012-11-29T22:43:24+08:00" 
			pubdate data-updated="true">2012/11/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>严谨一点说，SQLite在Android设备中可以被当做是一种数据存储方法或者干脆就是一个数据库</p>

<p>正如其他大多数平台一样，Android 也提供了几种方法用来保存数据，使得这些数据即使在程序结束以后依然不会丢失。这些方法有：文本文件-可以保存在应用程序自己的目录下(【译者注】安装的每个app都会在/data/data/目录下创建个文件夹，名字和应用程序中AndroidManifest.xml文件中的package一样)，也可以保存在SDcard中；Preferences也是一种经常使用的数据存储方法，因为它们对于用户而言是透明的，并且从应用安装的时候就存在了；另外，如果放宽点说的话，Assets也可以用来存储一些只读数据。Assets是指那些在assets目录下的文件，这些文件在你将你的应用编译打包之前就要存在，并且可以在应用程序运行的时候被访问到。以后我会更加详细的聊聊这些方法的细节。</p>

<p>然而，有时候我们需要对保存的数据进行一些复杂的操作，或者数据量很大，超出了文本文件和Preference的性能能hold住的范围，所以需要一些更加高效的方法来管理。这时就需要一个移动平台上的数据库闪亮登场了。</p>

<p>从Android1.5（代号Cupcake）开始，Android就自带SQLite（版本3.5.9+）了。如果你对SQLite不熟悉的话，就把它当成是一个独立的，无需服务进程，支持事务处理，可以使用SQL语言的数据库。尽管SQLite也有它的不足之处，但是在Android开发者的武器库里，可以算是个杀手锏了。</p>

<p>本文中，我主要介绍在Android中使用SQLite的方法，着重介绍它的管理操作，具体而言，就是创建和更新(update)（【译者注】这里说的更新操作不是说使用update语句更新数据库数据的操作，而是修改数据库结构的操作，本文中的update和upgrade都是这个意思，为避免混淆，后注原英文使用动词），而不是那些运行时的操作。</p>

<h3 id="toc_0">管理SQLite</h3>

<p>我们可以从创建一个继承自SQLiteOpenHelper的类来管理SQLite开始探讨这一话题，这个类有一个构造方法和另外两个必须实现的方法，onCreate和onUpgrade方法.</p>

<p>很自然的，这些方法中第一个被执行的就是构造方法，在构造函数中调用父类的构造方法，同时传入四个参数：</p>

<ul>
<li>Context， 这表示应用程序的上下文，在构造函数中保存住，对以后的其他操作有用。</li>
<li>数据库名称，就是个文件名，表示数据库物理文件名称的字符串。</li>
<li>游标factory，如果提供的话，可以用来创建游标。</li>
<li>数据库版本，这是你的数据库的版本（用一个整数表示），稍后我会讨论这个参数的细节。初始值为1。</li>
</ul>

<p>在我们的例子中，我们的四个参数如下面代码所示：</p>

<pre><code>class DB extends SQLiteOpenHelper {
 
  final static int DB_VERSION = 1;
  final static String DB_NAME = &quot;mydb.s3db&quot;;
  Context context;
 
  public DB(Context context) {
      super(context, DB_NAME, null, DB_VERSION);
      // Store the context for later use
      this.context = context;
}
</code></pre>

<p>构造函数做两件事情，首先，检查数据库是否存在，如果不存在，则调用onCreate方法创建数据库。然后，如果数据库已经存在了，那么就检查数据库版本是否和构造函数中传入的数据库版本值一致，从而决定数据库是不是已经更新(updated)过了，如果需要更新，则调用onUpgrade方法。</p>

<p>另外，如上所述，我们已经知道onCreate方法只有当数据库不存在的时候才会被调用，因此如果你想在程序安装以后第一次运行时做什么操作的话，这个方法倒不失为一个很方便的手段，你可以在这个方法中调用任何其他方法，比如说许可协议说明对话框。</p>

<p>让我们回头看看数据库本身，因为本文只是一个说明性质的文章，因此这里我只是创建一个简单的雇员信息数据库，创建数据库的SQL脚本如下所示：</p>

<pre><code>CREATE TABLE employees (
 _id INTEGER PRIMARY KEY AUTOINCREMENT,
 name TEXT NOT NULL,
 ext TEXT NOT NULL,
 mob TEXT NOT NULL,
 age INTEGER NOT NULL DEFAULT &#39;0&#39;
);
</code></pre>

<p>我们可以很容易的用hard coding的方式将创建脚本写死在代码中，一行对应一行，代码如下：</p>

<pre><code>@Override
public void onCreate(SQLiteDatabase database) {
    database.execSQL(       
 &quot;CREATE TABLE employees ( _id INTEGER PRIMARY KEY &quot;
    + &quot;AUTOINCREMENT, name TEXT NOT NULL, ext TEXT NOT NULL, &quot;
    + &quot;mob TEXT NOT NULL, age INTEGER NOT NULL DEFAULT &#39;0&#39;)&quot;);
}
</code></pre>

<p>但正如你所想的那样，当数据库大小达到了某个值，或者复杂性达到了某个程度时，这种做法就会非常不灵活，因此理想的做法是将SQL脚本放到一个asset文件中。如果这样做的话，你需要写一个方法从assets目录中读取SQL脚本，然后执行它：</p>

<pre><code>@Override
public void onCreate(SQLiteDatabase database) {
    executeSQLScript(database, &quot;create.sql&quot;);
}
 
private void executeSQLScript(SQLiteDatabase database, string dbname){
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        byte buf[] = new byte[1024];
        int len;
        AssetManager assetManager = context.getAssets();
        InputStream inputStream = null;
 
        try{
            inputStream = assetManager.open(dbname);
            while ((len = inputStream.read(buf)) != -1) {
                   outputStream.write(buf, 0, len);
                }
            outputStream.close();
            inputStream.close();
                String[] createScript = outputStream.toString().split(&quot;;&quot;);
                for (int i = 0; i &lt; createScript.length; i++) {
                    String sqlStatement = createScript[i].trim();
                    // TODO You may want to parse out comments here
                    if (sqlStatement.length() &gt; 0) {
                        database.execSQL(sqlStatement + &quot;;&quot;);
                    }
            }
       } catch (IOException e){
            // TODO Handle Script Failed to Load
        } catch (SQLException e) {
            // TODO Handle Script Failed to Execute
       }
}
</code></pre>

<p>如果是为了创建一个简单数据库的话，这种方法比简单的逐行执行SQL语句来的复杂的多，但是一旦数据库结果变得更复杂或者你想预先写好创建脚本时，这种方法将会使你获益良多。同时你也看到我将执行SQL语句的代码抽象到了一个独立executeSQLScript方法中，这样它可以在其他情况下复用，这一点我在本文后面的代码会证实到的。<br/>
（【译者注】这里原作者没有说创建了DB类以后该如何使用DB类来创建数据库，但既然这是个入门级的说明文，应该假设读者没有使用过SQLite，在下一小节的代码中有这样的代码：<br/>
DB db = new DB(this);<br/>
SQLiteDatabase qdb = db.getReadableDatabase();<br/>
也可以使用getWritableDatabase(); 得到可以写入的数据库，这里Android会自己根据需要创建数据库，如果数据库文件不存在的话就创建，如果数据库文件已经存在的话，那么Android自己会根据数据库文件中的version信息和DB类构造函数中传入的Version信息对比，如果值不一样的话，会自己调用onUpgrade（）方法更新数据库。因此onCreate方法和onUpgrade方法都不是由用户手动调用的。<br/>
这两句话可以加在Activity的onCreate方法中，或者onResume方法也是个不错的选择，执行完这句话后，在Android系统的/data/data/package_name/databases目录下就可以看到你创建的数据库文件，文件名就是上面代码中的DB_NAME的值，用DDMS拿出来以后可以用图形化工具打开看看，图形化工具可以使用有免费开源的sqliteman，在<a href="http://sqliteman.com/page/4.html%E4%B8%8B%E8%BD%BD%EF%BC%9B%E5%8F%A6%E5%A4%96%E8%BF%98%E6%9C%89firefox%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%9Asqlite">http://sqliteman.com/page/4.html下载；另外还有firefox的插件：sqlite</a> manager可以使用）</p>

<h3 id="toc_1">与数据库交互</h3>

<p>现在数据库已经创建好了，下面我想和它进行交互。一个简单的操作步骤：<br/>
第一步是打开数据库，有两种方法可以做到这点：使用getReadableDatabase()方法或者getWritableDatabase()方法。前者速度快，占用资源少，可以用来做除了写数据库和修改数据库之外的所有操作；后者主要用来做insert, update等操作。<br/>
在Android系统中，查询结果集作为一个Cursor对象返回，可以调用query()或者rawQuery()方法执行一次查询，例如，下面的两个方法返回的结果完全相同：</p>

<pre><code>DB db = new DB(this);
SQLiteDatabase qdb = db.getReadableDatabase();
Cursor recordset1 =  qdb.query(&quot;mytable&quot;, null, null, null, null, null, null);
Cursor recordset2 = qdb.rawQuery(&quot;SELECT * FROM mytable&quot;, null);
</code></pre>

<p>第一个查询调用使用了一堆参数，他们分别是数据表名称，一个列名数组, WHERE子句，选择参数数组，GROUP BY子句，HAVING子句以及ORDER BY子句。可以注意到，把这么多参数都设置为null，其作用和你用通配符代替这些参数的效果是一样的，如果你不需要给这些参数赋值，你干脆就不要用这种包含那么多参数的方法。</p>

<p>这里大多数参数对于熟悉SQL语句的人来说相当的直白。不过这个选择参数数组需要一点点说明，它是一个字符串数组，在查询方法中，WHERE子句中可以包含‘？’，然后在查询时，所有问号依次被选择参数数组中的值替换，比如选择参数数组中的第一个值替换掉WHERE子句中第一个‘？’。</p>

<p>再看看rawQuery()方法，它只需要两个参数，第一个是SQL查询语句，第二个是选择参数数组-它的作用和query方法中的一样。选择参数数组一般和复杂的查询一起使用，比如说使用到JOIN操作的时候。（【译者注】这里原作者说到做连接操作，我们知道sqlite仅支持左连接，而且当left join时，连接条件不在where子句中，因此这里应该指select x1, x2 from tables1, tables 2 where table1.?=tables2.? 这样的连接操作。实际上，我觉得这样的设计应该是为了不需要每次查询都要拼接查询语句字符串，比如说写个select * from tablename where name = ?, 这个?每次查询都不一样，这样可以通过选择参数数组中的值来替换?，而不需要每次都”select * from tablename where name = ‘“+Michael+”’” 这样拼接字符串，Java中拼接字符串的代价是比较高的，特别是查询条件比较多的时候，连续的几次字符串+操作会创建一堆String对象）。</p>

<h3 id="toc_2">数据库更新(Upgrades)</h3>

<p>再回到数据库管理上来，让我们看一下有点小复杂的情况，数据库更新。经过一段时间的使用和开发，应用程序往往会发生变化，也许会添加新的功能，也许做了某些优化。这些变化也许需要数据库结构发生变化，并且在数据库更新代码中，通过数据库版本这个值来反映出这次更新。</p>

<p>在更新数据库时有个潜在问题，那就是有可能导致先前版本的数据库数据丢失。另外，一旦我们的应用版本超过了两个，我们不能武断的假设用户总是已经更新到最新的版本了，比如说现在发布的版本是version3.0，那么不能假设所有用户都已经更新到version2.0了，所以我们的更新操作不能是简单的从一个版本更新到下一本版本。</p>

<p>那么怎么处理这种问题呢？我们已经知道当有一个新版本数据库的时候，onUpgrade()方法就会被调用，所以理想的做法是我们在这个方法中判断数据库版本，决定执行一段或者多段更新脚本。</p>

<p>让我们看一下我们的例子中，在2.0版本中要做哪些修改:</p>

<ul>
<li>电话号码格式标准化（分机号，手机号），将电话号码存到一张独立的“numbers”数据表。</li>
<li>在雇员数据表中增加一个薪水字段。</li>
</ul>

<p>以版本1数据库为更新点，可以通过下面的SQL脚本实现更新数据库操作，并且将原来版本中的数据导入到新版本数据库中。</p>

<pre><code>CREATE TABLE numbers (
   _id INTEGER PRIMARY KEY AUTOINCREMENT,
   employid INTEGER NOT NULL,
   number TEXT NOT NULL,
   ntype INTEGER NOT NULL DEFAULT &#39;0&#39;
);
CREATE INDEX employid ON numbers(employid);
 
INSERT INTO numbers (employid, number, ntype) SELECT _id, ext, 0    FROM employees;
INSERT INTO numbers (employid, number, ntype) SELECT _id, mob, 1    FROM employees;
 
CREATE TABLE temp (
     _id INTEGER PRIMARY KEY AUTOINCREMENT,
     name TEXT NOT NULL,
     salary INTEGER NOT NULL DEFAULT &#39;0&#39;
);
INSERT INTO temp (_id, name) SELECT _id, name FROM employees;
 
DROP TABLE employees;
ALTER TABLE temp RENAME TO employees;
</code></pre>

<p>显然，对数据库结构的修改越复杂，SQL脚本写的就越复杂。同时在对SQL的支持上，SQLite与其他数据库相比有更多限制，因此有些时候你需要做些workaround绕过这些限制，举个例子，在上面的更新(update)脚本中，我不得不创建一张临时表作为SQLite不支持DROP COLUMN语句的workaround。</p>

<p>现在已经有更新（upgrade）数据库的SQL脚本了，下一步是就如何在onUpgrade方法中调用SQL脚本，下面给一个实现方法：</p>

<pre><code>@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {      
if (newVersion &gt; oldVersion) {
    switch (oldVersion) {
        case 1:
            executeSQLScript(database, &quot;update_v2.sql&quot;);
        case 2:
            executeSQLScript(database, &quot;update_v3.sql&quot;);
    }
}
}
</code></pre>

<p>在这段代码中有两个地方值得注意。：第一件是我在代码里判断新数据库的版本号是不是比旧数据库版本号大，因为onUpdategrade()方法只要两个版本不一致时都会被调用，所以也有可能导致回滚到旧版本的情况。我们的代码不希望看到这种情况，但是实际上应该考虑这种情况并且加上相应的处理代码。</p>

<p>第二件是在case分支语句中没有break。这是因为每个分支中的SQL语句都是简单的从一个版本更新(updates)到下一个版本，这样的话，如果要从版本1更新(upgrade)到版本3的时候，首先会执行从版本1更新(upgrade)到版本2的脚本，然后再执行从版本2更新(upgrade)到版本3的脚本。如果数据库已经是版本2了，那么只会执行版本2到版本3的更新(upgrade)脚本。</p>

<p>这样的话，每次你更新(upgrade)数据库时，只需要考虑从最近的版本更新到新版本需要对数据库结构做哪些修改，写出相应脚本，就可以处理从任何一个版本升级的情况了。当然，在Java代码中我们还需要更新DB_VERION的值还有其他受数据库结构变化影响的代码。<br/>
结论<br/>
在Android平台的数据持久化方法中，SQLite有着很好数据存储和管理能力，是个不错的选择。然而，和使用其他任何一种数据库一样，需要小心管理，特别是当数据库结构发生变化时更需要小心再小心。</p>

<p>最后，将部分应用逻辑写到SQL脚本中（【译者注】比如在本文例子中从旧数据库中读取数据存到新数据表中这些操作都是用SQL脚本完成的）并且保存到文件中是个简单高效的方法。这种方法让开发人员不需要在程序中写非常复杂的代码处理每次更新(upgrade)，可以将主要精力放在应用的业务逻辑上。</p>

<p>英文原文：<a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html">Gilles Debunne</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-11-22-inner-classes-static-and-non-static.html">嵌套类：静态嵌套类和非静态嵌套类</a></h1>
			<p class="meta"><time datetime="2012-11-22T23:50:10+08:00" 
			pubdate data-updated="true">2012/11/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="http://en.wikipedia.org/wiki/Inner_class">内部类</a>在维基百科的定义为:  面向对象编程中，内部类（又叫做嵌套类）是在另一个类或者接口中进行声明的类。内部类不同于子类（subclass）。（译者注：wiki的注解有误，内部类和嵌套类并不完全等同，详见下文。）</p>

<p>在Java中，上面的定义可以如下示例：</p>

<pre><code>public final class Clazz {
  private final class InnerClazz implements Runnable {
        public InnerClazz() {
        }
 
        @Override
        public void run() {
            System.out.println(&quot;Hello world&quot;);
        }
  }
 
  public Clazz() {
  }
 
  public Runnable getRunnable(){
        return new InnerClazz();
  }
}
</code></pre>

<p>上面这个示例除了声明了一个内部类之外，没做其他任何事情。我举这个例子是想强调嵌套类和内部类的不同，因为不是所有的程序员都理解这一点。</p>

<h3 id="toc_0">内部类（Inner class）</h3>

<p>上面的示例代码中声明了一个内部类“InnerClazz”。每次调用getRunnable方法的时候InnerClazz类的实例就会被创建出来。如果你在FindBugs中调试这段代码，你会看到下面这条警告信息：<br/>
SIC：应该是个静态内部类(SIC_INNER_SHOULD_BE_STATIC) 。<br/>
这个类是一个由其外部对象创建的内部类，但是它没有使用内置的指向外部对象的引用。这个引用可以使得内部类实例更大，并且可以使得外部对象的生存期尽可能长。如果可能，这个类应该被定义成静态的。</p>

<p>这条警告信息很明确：内部类会保留一个指向其父类的引用，因此只要InnerClazz类被引用了，其父类就不能被JVM的垃圾回收机制自动垃圾回收（内部类和其父类的引用关系是很稳固的，你可以通过<a href="/2012-12-03-java-objects-memory-structure.html">内存管理</a>这篇文章了解更多）。如果你想使用这个引用，下面这种嵌套类是非常有用的：</p>

<pre><code>public final class Clazz {
    private final class InnerClazz implements Runnable {
        public InnerClazz() {
        }
 
        @Override
        public void run() {
          // print the value of a member of its &quot;parent&quot; class
          // it&#39;s possible because the inner class has an implicit reference
          // on the Clazz instance
          System.out.println(_currentNumber);
        }
    }
 
     private int _currentNumber = 0;
 
     public Clazz() {
     }
 
     public Runnable getRunnable() {
            _currentNumber++;
            return new InnerClazz();
     }
}
</code></pre>

<h3 id="toc_1">非内部类的嵌套类（Nested but not inner class）</h3>

<p>如果你并不需要保留Clazz实例和InnerClazz实例之间的非常稳固的引用关系，那么就将InnerClazz声明为一个静态成员类（下面的例子中的NestedNotInnerClazz类）。</p>

<pre><code>public final class Clazz {
     // static keyword is added
    static private final class NestedNotInnerClazz implements Runnable {
        public NestedNotInnerClazz() {
        }
 
        @Override
        public void run() {
          System.out.println(&quot;Hello world&quot;);
        }
    }
 
    public Clazz() {
    }
 
    public Runnable getRunnable(){
        return new NestedNotInnerClazz();
    }
}
</code></pre>

<p>瞧瞧，多简单啊。。</p>

<p>英文原文：<a href="http://www.coderfriendly.com/2009/06/27/inner-classes-static-and-non-static/">Coder Friendly</a></p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_8.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_6.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2018-12-31-life-2018.html">2018 总结 - 凤凰项目</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-12-31-life-2017.html">2017 总结 - 乘风破浪</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-06-24-ios-arm.html">iOS开发 - 制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-10-wechat-redenvelop-tweak-for-non-jailbroken-iphone.html">不越狱iOS自动抢红包</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-01-continuous-deployment-at-instagram.html">Instagram 是如何做持续部署的</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>