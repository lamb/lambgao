
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-05-hello-world.html">为什么这段代码输出的是”Hello World”</a></h1>
			<p class="meta"><time datetime="2013-03-05T15:36:51+08:00" 
			pubdate data-updated="true">2013/3/5</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Stackoverlfow.com上有一篇有趣的讨论帖：</p>

<p>在这篇帖子里提到了如下的程序：</p>

<pre><code>import java.util.*;
 
public class HelloWorld{
 
    public static String randomString(int i)
    {
        Random ran = new Random(i);
        StringBuilder sb = new StringBuilder();
        for (int n = 0; ; n++)
        {
            int k = ran.nextInt(27);
            if (k == 0)
                break;
 
            sb.append((char)(&#39;`&#39; + k));
        }
 
        return sb.toString();
    }
 
    public static void main(String[] args){
        System.out.println(randomString(-229985452)+&quot; &quot;+randomString(-147909649));
    }
 
}
</code></pre>

<p>明明是在程序里使用了java.util.Ramdom()函数产生随机数，为什么每次打出的结果都是Hello world? 各位程序员，你们怎么看？请务必要独立思考后再看下面的内容哦~</p>

<p>--------------- 独立思考的分割线 ---------------</p>

<p>OK，假如你通过独立思考了以后有了答案，那么可以参照一下下面的各种理解，这些都是来自stackoverflow对此问题的回复。</p>

<p>首先看一下这个程序的工作原理：</p>

<p>通过这句命令首先得到的六个数是:</p>

<p>8 5 12 12 15 0</p>

<p>然后，通过new Random(-147909649).nextInt(27)得到的6个数是：</p>

<p>23 15 18 12 4 0</p>

<p>这样一来，根据：sb.append((char) (‘`’+n)); 得到：</p>

<p>8 + 96 = 104 --&gt; h <br/>
5 + 96 = 101 --&gt; e <br/>
12 + 96 = 108 --&gt; l <br/>
12 + 96 = 108 --&gt; l <br/>
15 + 96 = 111 --&gt; o <br/>
23 + 96 = 119 --&gt; w <br/>
15 + 96 = 111 --&gt; o <br/>
18 + 96 = 114 --&gt; r <br/>
12 + 96 = 108 --&gt; l <br/>
4 + 96 = 100 --&gt; d</p>

<p>整个程序的执行就是这样。</p>

<p>关于这个程序的运行原理的解释，最置顶的一个回复如下：</p>

<p>“如果java.util.Random是被一个具体的数字做为“随机数种子”而实例化（在本例中是-229985452和-147909649），那么该实例就会以这个随机数种子作为随机算法产生随机数的基础。</p>

<p>使用同样的种子实例化的Random对象，每次运行时将会遵循同一种模式，产生同样的序列。”<br/>
这就是为什么每次运行该程序都会产生同样的结果的原理啦~</p>

<p>当然，关于这个话题，高手林立的Stackoverflow上是不缺乏懂行的专家和见解的。其实对于这个帖子本身，很快就有人论坛上提出了，这不是一个新鲜的问题，之前的某个帖子已经很详细地说明了原理：</p>

<p>参见：<a href="http://stackoverflow.com/questions/8044570/why-does-the-use-of-random-with-a-hardcoded-seed-always-produce-the-same-results">stackoverflow.com/questions/8044570/why-does-the-use-of-random-with-a-hardcoded-seed-always-produce-the-same-results</a></p>

<p>还有的人就非常精辟地指出了，这是计算机所谓的“伪随机数”问题（详细见扩展阅读），更有部分Geek的回复者从计算机理论和概率论的角度说明了，应该如何找到这些神奇的“随机数种子”。能够把这么一个原意为搞笑的帖子发展到理论的高度~，相信这应该也是计算机科学家的境界和觉悟了吧！</p>

<h4 id="toc_0">扩展阅读：计算机伪随机数问题</h4>

<p>随机数在计算机科学和计算机应用中都扮演非常重要的角色（例如通信、安全、密码等方面）。但是，由于计算机本身的结构和原理，实际上是无法产生出所谓的“绝对随机数”的。也就是说，计算机所产生的随机数，实际上是有某种规律或者模式的“伪随机数”（Pseudo random number)。</p>

<p>如何用计算机程序产生高质量随机数，这是计算机理论科学中的一个非常重要的课题。尤其是在复杂的计算环境下的高质量随机数的产生，需要牵涉到非常高深的计算科学和数学方面的理论研究。</p>

<p>在计算机随机数产生的理论研究上，美籍华人姚期智（目前任职于清华大学）是世界顶尖的专家。正是因为他在计算理论和伪随机数产生方面多项贡献，于2000年获得了ACM图灵奖，这也是计算机科学领域的最高奖项。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-02-22-log4j-2.html">Log4j 2 介绍</a></h1>
			<p class="meta"><time datetime="2013-02-22T15:44:19+08:00" 
			pubdate data-updated="true">2013/2/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">关于Log4j 2</h3>

<p>Log4j 2 是Log4j的升级版，与之前的版本Log4j 1.x相比、有重大的改进，在修正了Logback固有的架构问题的同时，改进了许多Logback所具有的功能。</p>

<p>Log4j 2的特性以及改进有：</p>

<ul>
<li>API分离：Log4j将API与实现分离开来。开发人员现在可以很清楚地知道能够使用哪些没有兼容问题的类和方法，同时又允许通过自己实现来增强功能。</li>
<li>改进的性能：Log4j 2的性能在某些关键领域比Log4j 1.x更快，而且大多数情况下与Logback相当。更多的信息请参考性能。</li>
<li>多个API支持：Log4j 2提供最棒的性能的同时，还支持SLF4J和公共日志记录API。</li>
<li>自动配置加载：像Logback一样，一旦配置发生改变，Log4j 2可以自动载入这些更改后的配置信息，又与Logback不同，配置发生改变时不会丢失任何日志事件。</li>
<li>高级过滤功能：与Logback类似，Log4j 2可以支持基于上下文数据、标记，正则表达式以及日志事件中的其他组件的过滤。Log4j 2 能够专门指定适用于所有的事件，无论这些事件在传入Loggers之前还是正在传给 appenders。另外，过滤器还可以与Loggers关联起来。与Logback不同的是，Filter公共类可以用于任何情况。</li>
<li>插件架构：所有可以配置的组件都以Log4j插件的形式来定义。同样地，不需要修改任何Log4j代码就可以创建新的Appender、Layout、Pattern Convert 等等。Log4j自动识别预定义的插件，如果在配置中引用到这些插件，Log4j就自动载入使用。</li>
<li>属性支持：属性可以在配置文件中引用，也可以直接替代或传入潜在的组件，属性在这些组件中能够动态解析。属性可以是配置文件，系统属性，环境变量，线程上下文映射以及事件中的数据中定义的值。用户可以通过增加自己的Lookup插件来定制自己的属性。</li>
</ul>

<h3 id="toc_1">文档</h3>

<p>Log4j 2用户文档可在<a href="http://logging.apache.org/log4j/2.x/manual/index.html">这里</a>在线阅读，或下载成<a href="http://logging.apache.org/log4j/2.x/log4j-users-guide.pdf">PDF</a>格式。</p>

<h3 id="toc_2">要求</h3>

<p>Log4j 2至少要求安装Java 5，然而使用Java 6的增强功能可以提高性能。有些特性需要一些可选的依赖，这些依赖在相关特性的文档中有说明。</p>

<h3 id="toc_3">资讯</h3>

<p>Log4j 2现在已经可以测试。API与Log4j 1.x 不兼容，不过通过适配器可以继续使用Log4j 1.x API。 适配器同样适用于Commons Logging和SLF4J.</p>

<h3 id="toc_4">以前的发布</h3>

<p>以前的Apache log4j发布可以从<a href="http://archive.apache.org/dist/logging/log4j">archive repository</a>找到。</p>

<h3 id="toc_5">Log4j 2.x的构建与安装</h3>

<h4 id="toc_6">构建</h4>

<p>Log 4j 运行在Apache 软件基金会下的代码仓库中。<a href="http://logging.apache.org/log4j/2.x/source-repository.html">Log4j 代码仓库</a>可以找到如何获取当前绝大多的源代码的细节。可以根据<a href="http://logging.apache.org/log4j/2.x/download.html">Log4j下载说明</a>下载最新的源代码</p>

<p>Log4j 2.x 使用Maven 2或3作为生成工具。在root目录中仅运行”mvn install”就可以生成Log4j.</p>

<h4 id="toc_7">程序中如何使用</h4>

<p>在你的程序中使用Log4j之前必须确保API和Core jars 在程序的classpath中。使用Maven将下面的依赖加入pom.xml.</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
&lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
&lt;artifactId&gt;log4j-core&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependecies&gt;
</code></pre>

<h4 id="toc_8">Apache 公共日志记录</h4>

<p>公共日志记录在许多组件中使用，不同的组建可以选择特定的日志记录的实现。为了把这些组件的日志功能集成到Log4j 2，需要加入下面的依赖，而且不能删除Commons Logging jar</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j.adapters&lt;/groupId&gt;
&lt;artifactId&gt;log4j-jcl&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependecies&gt;
</code></pre>

<h4 id="toc_9">SLF4J</h4>

<p>SLF4J是另一个受欢迎的日志记录API，通过加入下面的依赖以及SLF4J依赖就可以将其绑定到Log4j 2.</p>

<pre><code>&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.apache.logging.log4j.adapters&lt;/groupId&gt;
&lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt;
&lt;version&gt;2.0-beta3&lt;/version&gt;
&lt;/dependency&gt;
&lt;/dependecies&gt;
</code></pre>

<h4 id="toc_10">发布更改记录</h4>

<ul>
<li><a href="http://logging.apache.org/log4j/2.x/jira-report.html#a1.0-alpha1">JIRA更改记录</a></li>
<li><a href="http://logging.apache.org/log4j/2.x/changes-report.html#a1.0-alpha1">Manual更改记录</a></li>
</ul>

<h4 id="toc_11">升级注意事项</h4>

<p>Apache Log4j 2不支持兼容老版本。如果要升级到Log4j 2请铭记下列几条：</p>

<ul>
<li>需要Java 5</li>
<li>简化了XML配置，不兼容logj4 1.x。</li>
<li>不支持属性文件配置</li>
<li>支持JSON配置</li>
<li>虽然Log4j 2不能与Log4j 1.x直接兼容，但是可以通过自带兼容桥梁来降低升级带来的代码更改。</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-01-12-java-oom.html">诊断Java.lang.OutOfMemoryError（OOM）</a></h1>
			<p class="meta"><time datetime="2013-01-12T11:38:50+08:00" 
			pubdate data-updated="true">2013/1/12</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在跟踪性能问题时，堆内存是首先应该被监控的最重要的组件之一。一旦堆内存的实际使用量超过其所允许的堆空间，就会产生堆内存压力。而这将导致频繁的全面垃圾回收事件，垃圾回收将窃取CPU周期，轻则导致响应时间延迟，重则导致必须重新启动Java虚拟机才能解决的内存溢出错误。</p>

<h3 id="toc_0">内存溢出错误（OOM）</h3>

<p>当我运行应用时，出现了如下异常：</p>

<ul>
<li>java.lang.OutOfMemoryError: GC overhead limit exceeded[7,9]</li>
<li>java.lang.OutOfMemoryError: Java heap space</li>
</ul>

<p>第一条信息意味着，出于某种原因，垃圾收集器每次执行都花费了大量时间但只回收了很少量的内存，当我删除了如下代码后：</p>

<pre><code>System.gc();
</code></pre>

<p>第一条信息消失了，取而代之的，系统出现了第二条信息。很明显堆内存空间依然存在问题。下面是我调查问题的步骤：</p>

<ol>
<li>添加下面的Java启动参数</li>
<li>-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintGCTimeStamps

<ul>
<li>系统会生成gc.log文件</li>
</ul></li>
<li>-XX:+HeapDumpOnOutOfMemoryError

<ul>
<li>系统会生成堆内存转储文件</li>
</ul></li>
<li>分析日志文件:</li>
<li>使用常规的文本编辑器查看gc.log 文件。</li>
<li>使用 Eclipse Memory Analyzer 查看 堆内存转储文件 (例如, java_xxx.hprof)</li>
</ol>

<p>请注意，本文所讨论的所有虚拟机参数都是基于Hotspot虚拟机的。</p>

<p>Java命令行参数说明:</p>

<ul>
<li>-XX:+PrintGCDetails

<ul>
<li>打印更多的关于垃圾收集的信息。</li>
</ul></li>
<li>-XX:+PrintGCTimeStamps

<ul>
<li>打印从HotSpot 虚拟机开始执行直至垃圾收集事件发生所花费的时间（以秒为单位）。</li>
</ul></li>
<li>-Xloggc:gc.log

<ul>
<li>在每次垃圾收集时打印堆内存以及垃圾收集的信息。</li>
</ul></li>
</ul>

<p>在JDeveloper中可以按照如下方式设定：</p>

<ol>
<li>右键选择你的项目（例如ViewController），显示出菜单</li>
<li>选择Project Properties…</li>
<li>选择Run/Debug/Profile</li>
<li>选择你Run Configuration(例如, Default)</li>
<li>点击Edit按钮</li>
<li>在Java虚拟机参数栏位设定 -Xloggc:gc.log -XX:-PrintGCDetails</li>
</ol>

<p>运行你的应用并重现内存溢出异常，系统将会生成日志文件gc.log，<br/>
我的是在如下目录：</p>

<pre><code>…/system11.1.1.5.37.60.13/DefaultDomain
</code></pre>

<p>因为我的Web应用是部署在集成的WLS中，并且通过DefaultDomain来执行。<br/>
所以，想要理解gc.log文件的格式，请参考关联阅读[5,15]。</p>

<p>不过，gc.log文件并不能真正的帮到我们，因为他只是简要的打印了堆内存问题，</p>

<p>但并没有指出问题出在哪。<br/>
接下来我要做的是添加如下参数，并重新执行服务。<br/>
<strong>-XX:+HeapDumpOnOutOfMemoryError</strong><br/>
当服务发生堆内存错误时，会生成java_pid30835.hprof文件。</p>

<h3 id="toc_1">Eclise内存分析器（Eclipse Memory Analyzer）</h3>

<p>堆内存转储文件由HPROF（堆内存和CPU分析工具）生成，堆内存转储文件是2进制格式的，因此必须使用Eclpse Memory Analyzer 来查看。</p>

<p>你可以通过Eclipse Update manager 来安装Eclipse MAT，选择”General Purpose Tools “并安装”Memory Analyser (Incubation)”以及”Memory Analyser (Charts)”。</p>

<p>安装之后，双击堆内存转储文件并且选择”Leak Suspects Report”</p>

<p>Eclipse MAT会显示图表以及问题的嫌疑人：</p>

<h3 id="toc_2">调整堆内存空间</h3>

<p>如果你观察到垃圾收集日志文件中有内存溢出错误，那么可以尝试将Java堆内存空间调整为你能够分配给Java虚拟机的物理内存空间的80%，基于具体是老年代空间还是永久代空间发生内存溢出，你可以像这样调整内存空间。</p>

<ul>
<li>针对老年代发生内存溢出

<ul>
<li>increase -Xms and -Xmx</li>
</ul></li>
<li>针对永久代发生内存溢出

<ul>
<li>increase -XX:PermSize and -XX:MaxPermSize</li>
</ul></li>
</ul>

<p>参考文献：</p>

<ul>
<li><a href="http://www.vogella.de/articles/Eclipse/article.html#updatemanager">Eclipse Update Manager</a></li>
<li><a href="http://www.vogella.de/articles/EclipseMemoryAnalyser/article.html">Eclipse Memory Analyzer</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java Hotspot VM Options</a></li>
<li><a href="http://xmlandmore.blogspot.com/2011/04/integrated-weblogic-server-wls.html">Integrated WebLogic Server (WLS)</a></li>
<li><a href="http://java.sun.com/docs/hotspot/gc1.4.2/example.html">Diagnosing a Garbage Collection problem</a></li>
<li><a href="http://www.oracle.com/technetwork/java/faq-140837.html">Frequently Asked Questions about Garbage Collection</a></li>
<li><a href="http://stackoverflow.com/questions/1393486/what-means-the-error-message-java-lang-outofmemoryerror-gc-overhead-limit-excee">GC Overhead Limit Exceeded</a></li>
<li><a href="http://java.sun.com/developer/technicalArticles/Programming/HPROF.html">HPROF: A Heap/CPU Profiling Tool in J2SE 5.0</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#par_gc.oom">Java SE 6 HotSpottm Virtual Machine Garbage Collection Tuning</a></li>
<li>Java Performance by Charlie Hunt and Binu John</li>
<li><a href="http://xmlandmore.blogspot.com/2012/01/understanding-garbage-collection.html">Understanding Garbage Collection</a></li>
<li><a href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html">Java HotSpot VM Options</a></li>
<li><a href="http://www.tagtraum.com/gcviewer.html">GCViewer</a> (a free open source tool)</li>
<li><a href="http://xmlandmore.blogspot.com/2012/03/understanding-garbage-collector-output.html">Understanding Garbage Collector Output of Hotspot VM</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-01-11-how-deep-unit-test.html">单元测试要做多深？——测试驱动开发（TDD)引发的争论</a></h1>
			<p class="meta"><time datetime="2013-01-11T13:05:38+08:00" 
			pubdate data-updated="true">2013/1/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>著名的IT技术问答网站www.stackoverflow.com上浮现了这么一篇有趣的贴子：</p>

<p><a href="http://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests">单元测试要做多深？</a></p>

<p>发问的人是一个注册ID为：<a href="http://stackoverflow.com/users/1116/john-nolan">John Nolan</a> 的用户，TA问到：</p>

<p>“我发现驱动测试开发需要花很多时间才能把测试环境设置好，而我又是个懒人，希望代码写得尽可能越少越好。一般来说我在操作的时候会先测试构造函数是否设置了所有属性，但是这样做是不是有点儿太过了？</p>

<p>所以我的问题是：你们在写单元测试代码的时候，一般都把粒度控制到什么级别啊？</p>

<p>..还有，有没有那种测试过度的案例啊？”</p>

<p>目前，对于该问题置顶的回复，是大名鼎鼎的敏捷领袖 <a href="http://stackoverflow.com/users/13842/kent-beck">Kent Beck</a> , 他的观点是：</p>

<p>“我拿了工资是要去写运行良好的程序，而不是为了测试。所以我的观点是，在可信任的范围内，测试得越少越好（译注： 猜想Kent的意思应该是“单元测试要集中自己没有把握的地方，对于自己认为没有问题、可以信任的代码，测试越少越好。毕竟开发不能为了单元测试而去做单元测试”） 。如果我不是那种经常容易犯低级错误（比如什么在构造函数里错误设置了属性）的人，那我就不会去每次写代码测试它。我更倾向于去测试那些逻辑错误，所以，当我在处理比较复杂的逻辑条件的时候，我会非常小心谨慎。当我在一个团队里编程时，我会调整我的策略，我会非常小心地去测试那些大家写的，容易出错的代码。</p>

<p>当然，基于我上述的观点，不同的人会有不同的看法。不过，如果真要为“测试工作怎样才能最好地适用于编码内循环”这个问题找答案，目前也没有人能给出真正成熟的见解。鉴于这种情形，我认为我的的观点还是可以立足的。从现在起的10到20年间，还会有更多的统一理论教导我们应该写哪些测试，不应该写哪些测试，以及二者有何区别。同时，各种说法的试验也都在进行当中。”</p>

<p>大牛的观点自然是相当火爆的，Kent Beck自己做为XP和TDD的创始人，貌似对自己的领域唱出了反调！下面毫无疑问地跟帖无数，褒贬不一，在此就不一一翻译了。感兴趣的同学可以去原文围观。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-12-26-building-mobile-applications.html">打造企业级应用：HTML5，Hybrid，Native Dilemma之间的对比</a></h1>
			<p class="meta"><time datetime="2012-12-26T23:59:26+08:00" 
			pubdate data-updated="true">2012/12/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这篇文章主要关于如何开发企业级移动应用。今天我读了Charlie的关于<a href="http://www.geekwire.com/2012/apps-cross-platform/">移动应用开发的文章</a>，并且从企业的角度分析了hybrid应用的情况。</p>

<h3 id="toc_0">总览</h3>

<p>最近我关于开发企业级移动应用的交谈大部分都是以“我是否该用Hybrid或者Native”这样的问题开始。是的，很多组织出于成本上的考虑对“Hybrid”方式很感兴趣，但依我之见，任何决定都应以用户为导向而非成本。所以，要得出这个答案要这么去想“怎么才能给最终用户最好的用户体验”，而不是一直问“我们怎么才能降低成本”。不光企业级应用，所有应用都是这样的。</p>

<p>另外，从企业的角度来说，我认为达到终端独立是另一种降低成本和将来达到投资目的的方式。所以，选HTML5，Hybrid还是Native只是决定选择的一个因素，这里还有一些当你讨论移动策略时要考虑的因素：</p>

<p><img src="/resource/image/2012-12-26-building-mobile-applications/vs.jpg" alt="对比图片"/></p>

<p>设想阶段要考虑的：<br/>
1. 目标用户分析<br/>
2. 以一个简单的框架开始，像Forrester的POST approach<br/>
3. 差距分析和组合合理化</p>

<p>为移动应用的开发和分发制定策略<br/>
1. 移动web/纯HTML/JSS<br/>
2. Hybrid 应用（本地中的HTML5/JS应用，像Phone Gap 或者Titanium中的本地部分或插件）<br/>
3. 本地应用</p>

<p>关于通用服务层的考虑：<br/>
1. 创建或实现一个可扩展的通用服务层<br/>
2. 在服务层和传统系统之间实现一个可扩展的中间层<br/>
3. 确立保准（就像用REST）<br/>
4. 为媒体分发确定和整合内容分发网络</p>

<p>测试模型<br/>
1. 安全和性能<br/>
2. 基于设备的测试</p>

<p>提交管理<br/>
1. 支付模型<br/>
2. 已提交模型的跟踪<br/>
3. 分析<br/>
4. 反馈跟踪<br/>
5. 继续开发</p>

<p>好了，这些就是移动开发策略的一部分，尤其当你讨论企业移动应用时，移动终端独立是关键点，开发者要理解使产品有逻辑性和数据的有效性对多种终端的必要性。</p>

<p>在你周围已经存在的数据和智能中，REST已经成为越来越多的创建公共服务层的默认选择。</p>

<h3 id="toc_1">Hybrid 对 Native</h3>

<p>现在关于Hybrid和Native，下面是我看到的主要的利弊两方面的东西：</p>

<h4 id="toc_2">Hybrid 应用</h4>

<p>有利的方面：<br/>
* 不需要为某一特定平台开发<br/>
* 更好的投资回报率，代码可在多个平台重复使用<br/>
* 仍可以访问设备的某些特性<br/>
* 可以打包到另外的渠道</p>

<p>不足的方面：<br/>
* 特殊化的UI很难做<br/>
* 响应不够快，且不像纯本地应用那样富含多种特性<br/>
* 当实现特定的最优化的特性时，可以遇到限制。</p>

<h4 id="toc_3">本地应用</h4>

<p>有利的方面：<br/>
* 高度订制，能满足边界条件。<br/>
* 很高的可用性。</p>

<p>不足的方面：<br/>
* 平台的多样性<br/>
* 对每个平台的投入<br/>
* 没有统一的代码库及重用性</p>

<h3 id="toc_4">更多</h3>

<p>当你在考虑企业级移动应用时，再说一次，别在是用Hybrid还是Native之间考虑了。</p>

<p>从中间件的角度</p>

<ol>
<li><p>选择一种策略，以使存储、计算你的移动应用的资源可以在移动设备，本地存储和云计算设施中实现。</p></li>
<li><p>在移动应用间连接，通信，代理时使用代理服务，</p>

<ul>
<li>在代理的最上层自定义实现，就像Windows Azure Service Bus</li>
<li>创建面向web架构的移动应用，就像Marlabs Matrix平台</li>
<li>第三方移动中间平台，像Syclo等</li>
</ul></li>
<li><p>如果需要支持多种认证机制，像Azure Federated Authentication.，那就用基于联合的云认证服务。</p></li>
<li><p>采用基于push通知服务的云服务从你的移动设备发送和接受消息。</p></li>
<li><p>选择一个支持比特率传输视频内容的合适的内容分发网络，例如Azure CDN或者Limelight True Reach API.</p></li>
<li><p>使APIs支持扩展，跟踪，反馈。</p></li>
</ol>

<p>提交管理包括为支付模型，使用追踪，分析和支持反馈制定一个合适的策略。提交管理应该保证：<br/>
* 提交应用到应用商店时要有最少的条件<br/>
* 适当听取用户的建议—反馈和评分应用来确定哪些可要哪些可不要<br/>
* 发布和更新要符合用户的期望</p>

<p>所以，编码快乐！</p>

<p>英文原文： <a href="http://css.dzone.com/articles/building-mobile-applications">Building Mobile App for Enterprise</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-12-03-java-objects-memory-structure.html">Java对象内存结构</a></h1>
			<p class="meta"><time datetime="2012-12-03T23:21:51+08:00" 
			pubdate data-updated="true">2012/12/3</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Java程序员有时还是希望能知道一个Java对象到底用了多少内存的。不过这个问题的答案并不简单。</p>

<p>首先要区分清楚的是shallow size和deep size。Shallow size是指对象自身占用的内存大小，其引用对象的大小不算在内。而deep size，则是自身所占内存大小和其递归引用的所有对象所占内存大小的总和。大多数情况下，你会希望获得一个对象的deep size，但是为了知道这个值，首先要知道怎么算shallow size，下面我来介绍一下。</p>

<p>有人抱怨JVM规范中没有针对运行时Java对象的内存结构的说明，这也就是说JVM供应商可以按照自己的需要来实现这一点。后果就是，同一个类在不同的JVM上运行的实例对象占用的内存大小会有差别。好在是世界上大部分人（包括我在内）都使用Sun HotSpot虚拟机，这就大大简化了这个问题。我们接下来的讨论也会基于32位的Sun公司的JVM。下面我介绍一些规则来辅助解释JVM如何组织对象在内存中的布局的。</p>

<h3 id="toc_0">没有实例属性的类的内存布局</h3>

<p>在Sun JVM中，（除了数组之外的）对象都有两个机器字（words）的头部。第一个字中包含这个对象的标示哈希码以及其他一些类似锁状态和等标识信息，第二个字中包含一个指向对象的类的引用。另外，任何对象都是8个字节为粒度进行对齐的。这就是对象内存布局的第一个规则：</p>

<p>规则1：任何对象都是8个字节为粒度进行对齐的。</p>

<p>比如，如果调用new Object()，由于Object类并没有其他没有其他可存储的成员，那么仅仅使用堆中的8个字节来保存两个字的头部即可。</p>

<h3 id="toc_1">继承了Object的类的内存布局</h3>

<p>除了上面所说的8个字节的头部，类属性紧随其后。属性通常根据其大小来排列。例如，整型（int）以4个字节为单位对齐，长整型（long）以8个字节为单位对齐。这里是出于性能考虑而这么设计的：通常情况下，如果数据以4字节为单位对齐，那么从内存中读4字节的数据并写入到处理器的4字节寄存器是性价比更高的。</p>

<p>为了节省内存，Sun VM并没有按照属性声明时的顺序来进行内存布局。实际上，属性在内存中按照下面的顺序来组织：</p>

<ol>
<li><p>双精度型（doubles）和长整型（longs）</p></li>
<li><p>整型（ints）和浮点型（floats）</p></li>
<li><p>短整型（shorts）和字符型（chars）</p></li>
<li><p>布尔型（booleans）和字节型（bytes）</p></li>
<li><p>引用类型（references）</p></li>
</ol>

<p>内存使用率会通过这个机制得到优化。例如，如下声明一个类：</p>

<pre><code>class MyClass {
 
       byte a;
 
       int c;
 
       boolean d;
 
       long e;
 
       Object f;          
 
}
</code></pre>

<p>如果JVM并没有打乱属性的声明顺序，其对象内存布局将会是下面这个样子：</p>

<pre><code>[HEADER:  8 bytes]  8
[a:       1 byte ]  9
[padding: 3 bytes] 12
[c:       4 bytes] 16
[d:       1 byte ] 17
[padding: 7 bytes] 24
[e:       8 bytes] 32
[f:       4 bytes] 36
[padding: 4 bytes] 40
</code></pre>

<p>此时，用于占位的14个字节是浪费的，这个对象一共使用了40个字节的内存空间。但是，如果用上面的规则对这些对象重新排序，其内存结果会变成下面这个样子：</p>

<pre><code>[HEADER:  8 bytes]  8
[e:       8 bytes] 16
[c:       4 bytes] 20
[a:       1 byte ] 21
[d:       1 byte ] 22
[padding: 2 bytes] 24
[f:       4 bytes] 28
[padding: 4 bytes] 32
</code></pre>

<p>这次，用于占位的只有6个字节，这个对象使用了32个字节的内存空间。</p>

<p>因此，对象内存布局的第二个规则是：</p>

<p>规则2：类属性按照如下优先级进行排列：长整型和双精度类型；整型和浮点型；字符和短整型；字节类型和布尔类型，最后是引用类型。这些属性都按照各自的单位对齐。</p>

<p>现在我们知道如何计算一个继承了Object的类的实例的内存大小了。下面这个例子用来做下练习: java.lang.Boolean。这是其内存布局：</p>

<pre><code>[HEADER:  8 bytes]  8
[value:   1 byte ]  9
[padding: 7 bytes] 16
</code></pre>

<p>Boolean类的实例占用16个字节的内存！惊讶吧？（别忘了最后用来占位的7个字节）。</p>

<h3 id="toc_2">继承其他类的子类的内存布局</h3>

<p>JVM所遵守的下面3个规则用来组织有父类的类的成员。对象内存布局的规则3如下：</p>

<p>规则3：不同类继承关系中的成员不能混合排列。首先按照规则2处理父类中的成员，接着才是子类的成员。</p>

<p>举例如下：</p>

<pre><code>class A {
   long a;
   int b;
   int c;
}
 
class B extends A {
   long d;
}
</code></pre>

<p>类B的实例在内存中的存储如下：</p>

<pre><code>[HEADER:  8 bytes]  8
[a:       8 bytes] 16
[b:       4 bytes] 20
[c:       4 bytes] 24
[d:       8 bytes] 32
</code></pre>

<p>如果父类中的成员的大小无法满足4个字节这个基本单位，那么下一条规则就会起作用：</p>

<p>规则4：当父类中最后一个成员和子类第一个成员的间隔如果不够4个字节的话，就必须扩展到4个字节的基本单位。</p>

<p>举例如下：</p>

<pre><code>class A {
   byte a;
}
 
class B {
   byte b;
}
[HEADER:  8 bytes]  8
[a:       1 byte ]  9
[padding: 3 bytes] 12
[b:       1 byte ] 13
[padding: 3 bytes] 16
</code></pre>

<p>注意到成员a被扩充了3个字节以保证和成员b之间的间隔是4个字节。这个空间不能被类B使用，因此被浪费了。</p>

<p>最后一条规则在下面情况下用来节省一些空间：如果子类成员是长整型或双精度类型，并且父类并没有用完8个字节。</p>

<p>规则5：如果子类第一个成员是一个双精度或者长整型，并且父类并没有用完8个字节，JVM会破坏规则2，按照整形（int），短整型（short），字节型（byte），引用类型（reference）的顺序，向未填满的空间填充。</p>

<p>举例如下：</p>

<pre><code>class A {
  byte a;
}
 
class B {
  long b;
  short c;  
  byte d;
}
</code></pre>

<p>其内存布局如下：</p>

<pre><code>[HEADER:  8 bytes]  8
[a:       1 byte ]  9
[padding: 3 bytes] 12
[c:       2 bytes] 14
[d:       1 byte ] 15
[padding: 1 byte ] 16
[b:       8 bytes] 24
</code></pre>

<p>在第12字节处，类A“结束”的地方，JVM没有遵守规则2，而是在长整型之前插入一个短整型和一个字节型成员，这样可以避免浪费3个字节。</p>

<h3 id="toc_3">数组的内存布局</h3>

<p>数组有一个额外的头部成员，用来存放“长度”变量。数组元素以及数组本身，跟其他常规对象同样，都需要遵守8个字节的边界规则。</p>

<p>下面是一个有3个元素的字节数组的内存布局：<br/>
<code><br/>
[HEADER:  12 bytes] 12<br/>
[[0]:      1 byte ] 13<br/>
[[1]:      1 byte ] 14<br/>
[[2]:      1 byte ] 15<br/>
[padding:  1 byte ] 16<br/>
</code></p>

<p>下面是一个有3个元素的长整型数字的内存布局：</p>

<pre><code>[HEADER:  12 bytes] 12
[padding:  4 bytes] 16
[[0]:      8 bytes] 24
[[1]:      8 bytes] 32
[[2]:      8 bytes] 40
</code></pre>

<h3 id="toc_4">内部类的内存布局</h3>

<p><a href="/2012-11-22-inner-classes-static-and-non-static.html">非静态内部类</a>（Non-static inner classes）有一个额外的“隐藏”成员，这个成员是一个指向外部类的引用变量。这个成员是一个普通引用，因此遵守引用内存布局的规则。内部类因此有4个字节的额外开销。</p>

<p>最后的一点想法</p>

<p>我们已经学习了在32位Sun JVM中如何计算Java对象的shallow size。知道内存是如何组织的有助于理解类实例占用的内存数。</p>

<p>英文原文：<a href="http://www.codeinstructions.com/2008/12/java-objects-memory-structure.html">Code Instructions</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-12-01-eclipse-plugin.html">Eclipse 插件开发</a></h1>
			<p class="meta"><time datetime="2012-12-01T22:50:33+08:00" 
			pubdate data-updated="true">2012/12/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>《<a href="http://book.douban.com/subject/1933347/">ECLIPSE插件开发(原书第3版)</a>》是一本由两位长期从事Java商业软件开发的技术专家编写的关于开发Eclipse商业插件的指南。本书主要介绍了开发Eclipse商业插件的完整过程，并从标准窗口小部件工具集、命令与操作、视图、透视图、实现帮助、国际化等方面对创建Eclipse商业插件进行了详细描述。本书既包含了开发Eclipse插件的基础理论，也涵盖了大量关于Eclipse插件开发的细节，并且提供了详细的示例代码、相关的程序列表、图表、屏幕截图等。</p>

<p>本书不仅适用于Eclipse插件开发的初学者，对于Eclipse商业软件开发人员也有很高的参考价值。</p>

<p>面向Eclipse 4的新版本”<a href="http://www.amazon.com/Eclipse-Plug-ins-4th-Edition-Series/dp/0321774159/ref=sr_1_3?ie=UTF8&amp;qid=1357042883&amp;sr=8-3&amp;keywords=eclipse+4">Eclipse Plugins(4th edition)</a>“会在2013年7月发布。</p>

<p>开发入门可以参考一下的文章</p>

<p><a href="http://www.ibm.com/developerworks/cn/java/l-eclipse-plugin/">Eclipse 简介和插件开发</a></p>

<p><a href="http://www.cnblogs.com/liuzhuo">Eclipse插件开发之基础篇</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-11-29-sqlite-use-in-android.html">SQLite在Android中的使用</a></h1>
			<p class="meta"><time datetime="2012-11-29T22:43:24+08:00" 
			pubdate data-updated="true">2012/11/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>严谨一点说，SQLite在Android设备中可以被当做是一种数据存储方法或者干脆就是一个数据库</p>

<p>正如其他大多数平台一样，Android 也提供了几种方法用来保存数据，使得这些数据即使在程序结束以后依然不会丢失。这些方法有：文本文件-可以保存在应用程序自己的目录下(【译者注】安装的每个app都会在/data/data/目录下创建个文件夹，名字和应用程序中AndroidManifest.xml文件中的package一样)，也可以保存在SDcard中；Preferences也是一种经常使用的数据存储方法，因为它们对于用户而言是透明的，并且从应用安装的时候就存在了；另外，如果放宽点说的话，Assets也可以用来存储一些只读数据。Assets是指那些在assets目录下的文件，这些文件在你将你的应用编译打包之前就要存在，并且可以在应用程序运行的时候被访问到。以后我会更加详细的聊聊这些方法的细节。</p>

<p>然而，有时候我们需要对保存的数据进行一些复杂的操作，或者数据量很大，超出了文本文件和Preference的性能能hold住的范围，所以需要一些更加高效的方法来管理。这时就需要一个移动平台上的数据库闪亮登场了。</p>

<p>从Android1.5（代号Cupcake）开始，Android就自带SQLite（版本3.5.9+）了。如果你对SQLite不熟悉的话，就把它当成是一个独立的，无需服务进程，支持事务处理，可以使用SQL语言的数据库。尽管SQLite也有它的不足之处，但是在Android开发者的武器库里，可以算是个杀手锏了。</p>

<p>本文中，我主要介绍在Android中使用SQLite的方法，着重介绍它的管理操作，具体而言，就是创建和更新(update)（【译者注】这里说的更新操作不是说使用update语句更新数据库数据的操作，而是修改数据库结构的操作，本文中的update和upgrade都是这个意思，为避免混淆，后注原英文使用动词），而不是那些运行时的操作。</p>

<h3 id="toc_0">管理SQLite</h3>

<p>我们可以从创建一个继承自SQLiteOpenHelper的类来管理SQLite开始探讨这一话题，这个类有一个构造方法和另外两个必须实现的方法，onCreate和onUpgrade方法.</p>

<p>很自然的，这些方法中第一个被执行的就是构造方法，在构造函数中调用父类的构造方法，同时传入四个参数：</p>

<ul>
<li>Context， 这表示应用程序的上下文，在构造函数中保存住，对以后的其他操作有用。</li>
<li>数据库名称，就是个文件名，表示数据库物理文件名称的字符串。</li>
<li>游标factory，如果提供的话，可以用来创建游标。</li>
<li>数据库版本，这是你的数据库的版本（用一个整数表示），稍后我会讨论这个参数的细节。初始值为1。</li>
</ul>

<p>在我们的例子中，我们的四个参数如下面代码所示：</p>

<pre><code>class DB extends SQLiteOpenHelper {
 
  final static int DB_VERSION = 1;
  final static String DB_NAME = &quot;mydb.s3db&quot;;
  Context context;
 
  public DB(Context context) {
      super(context, DB_NAME, null, DB_VERSION);
      // Store the context for later use
      this.context = context;
}
</code></pre>

<p>构造函数做两件事情，首先，检查数据库是否存在，如果不存在，则调用onCreate方法创建数据库。然后，如果数据库已经存在了，那么就检查数据库版本是否和构造函数中传入的数据库版本值一致，从而决定数据库是不是已经更新(updated)过了，如果需要更新，则调用onUpgrade方法。</p>

<p>另外，如上所述，我们已经知道onCreate方法只有当数据库不存在的时候才会被调用，因此如果你想在程序安装以后第一次运行时做什么操作的话，这个方法倒不失为一个很方便的手段，你可以在这个方法中调用任何其他方法，比如说许可协议说明对话框。</p>

<p>让我们回头看看数据库本身，因为本文只是一个说明性质的文章，因此这里我只是创建一个简单的雇员信息数据库，创建数据库的SQL脚本如下所示：</p>

<pre><code>CREATE TABLE employees (
 _id INTEGER PRIMARY KEY AUTOINCREMENT,
 name TEXT NOT NULL,
 ext TEXT NOT NULL,
 mob TEXT NOT NULL,
 age INTEGER NOT NULL DEFAULT &#39;0&#39;
);
</code></pre>

<p>我们可以很容易的用hard coding的方式将创建脚本写死在代码中，一行对应一行，代码如下：</p>

<pre><code>@Override
public void onCreate(SQLiteDatabase database) {
    database.execSQL(       
 &quot;CREATE TABLE employees ( _id INTEGER PRIMARY KEY &quot;
    + &quot;AUTOINCREMENT, name TEXT NOT NULL, ext TEXT NOT NULL, &quot;
    + &quot;mob TEXT NOT NULL, age INTEGER NOT NULL DEFAULT &#39;0&#39;)&quot;);
}
</code></pre>

<p>但正如你所想的那样，当数据库大小达到了某个值，或者复杂性达到了某个程度时，这种做法就会非常不灵活，因此理想的做法是将SQL脚本放到一个asset文件中。如果这样做的话，你需要写一个方法从assets目录中读取SQL脚本，然后执行它：</p>

<pre><code>@Override
public void onCreate(SQLiteDatabase database) {
    executeSQLScript(database, &quot;create.sql&quot;);
}
 
private void executeSQLScript(SQLiteDatabase database, string dbname){
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        byte buf[] = new byte[1024];
        int len;
        AssetManager assetManager = context.getAssets();
        InputStream inputStream = null;
 
        try{
            inputStream = assetManager.open(dbname);
            while ((len = inputStream.read(buf)) != -1) {
                   outputStream.write(buf, 0, len);
                }
            outputStream.close();
            inputStream.close();
                String[] createScript = outputStream.toString().split(&quot;;&quot;);
                for (int i = 0; i &lt; createScript.length; i++) {
                    String sqlStatement = createScript[i].trim();
                    // TODO You may want to parse out comments here
                    if (sqlStatement.length() &gt; 0) {
                        database.execSQL(sqlStatement + &quot;;&quot;);
                    }
            }
       } catch (IOException e){
            // TODO Handle Script Failed to Load
        } catch (SQLException e) {
            // TODO Handle Script Failed to Execute
       }
}
</code></pre>

<p>如果是为了创建一个简单数据库的话，这种方法比简单的逐行执行SQL语句来的复杂的多，但是一旦数据库结果变得更复杂或者你想预先写好创建脚本时，这种方法将会使你获益良多。同时你也看到我将执行SQL语句的代码抽象到了一个独立executeSQLScript方法中，这样它可以在其他情况下复用，这一点我在本文后面的代码会证实到的。<br/>
（【译者注】这里原作者没有说创建了DB类以后该如何使用DB类来创建数据库，但既然这是个入门级的说明文，应该假设读者没有使用过SQLite，在下一小节的代码中有这样的代码：<br/>
DB db = new DB(this);<br/>
SQLiteDatabase qdb = db.getReadableDatabase();<br/>
也可以使用getWritableDatabase(); 得到可以写入的数据库，这里Android会自己根据需要创建数据库，如果数据库文件不存在的话就创建，如果数据库文件已经存在的话，那么Android自己会根据数据库文件中的version信息和DB类构造函数中传入的Version信息对比，如果值不一样的话，会自己调用onUpgrade（）方法更新数据库。因此onCreate方法和onUpgrade方法都不是由用户手动调用的。<br/>
这两句话可以加在Activity的onCreate方法中，或者onResume方法也是个不错的选择，执行完这句话后，在Android系统的/data/data/package_name/databases目录下就可以看到你创建的数据库文件，文件名就是上面代码中的DB_NAME的值，用DDMS拿出来以后可以用图形化工具打开看看，图形化工具可以使用有免费开源的sqliteman，在<a href="http://sqliteman.com/page/4.html%E4%B8%8B%E8%BD%BD%EF%BC%9B%E5%8F%A6%E5%A4%96%E8%BF%98%E6%9C%89firefox%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%9Asqlite">http://sqliteman.com/page/4.html下载；另外还有firefox的插件：sqlite</a> manager可以使用）</p>

<h3 id="toc_1">与数据库交互</h3>

<p>现在数据库已经创建好了，下面我想和它进行交互。一个简单的操作步骤：<br/>
第一步是打开数据库，有两种方法可以做到这点：使用getReadableDatabase()方法或者getWritableDatabase()方法。前者速度快，占用资源少，可以用来做除了写数据库和修改数据库之外的所有操作；后者主要用来做insert, update等操作。<br/>
在Android系统中，查询结果集作为一个Cursor对象返回，可以调用query()或者rawQuery()方法执行一次查询，例如，下面的两个方法返回的结果完全相同：</p>

<pre><code>DB db = new DB(this);
SQLiteDatabase qdb = db.getReadableDatabase();
Cursor recordset1 =  qdb.query(&quot;mytable&quot;, null, null, null, null, null, null);
Cursor recordset2 = qdb.rawQuery(&quot;SELECT * FROM mytable&quot;, null);
</code></pre>

<p>第一个查询调用使用了一堆参数，他们分别是数据表名称，一个列名数组, WHERE子句，选择参数数组，GROUP BY子句，HAVING子句以及ORDER BY子句。可以注意到，把这么多参数都设置为null，其作用和你用通配符代替这些参数的效果是一样的，如果你不需要给这些参数赋值，你干脆就不要用这种包含那么多参数的方法。</p>

<p>这里大多数参数对于熟悉SQL语句的人来说相当的直白。不过这个选择参数数组需要一点点说明，它是一个字符串数组，在查询方法中，WHERE子句中可以包含‘？’，然后在查询时，所有问号依次被选择参数数组中的值替换，比如选择参数数组中的第一个值替换掉WHERE子句中第一个‘？’。</p>

<p>再看看rawQuery()方法，它只需要两个参数，第一个是SQL查询语句，第二个是选择参数数组-它的作用和query方法中的一样。选择参数数组一般和复杂的查询一起使用，比如说使用到JOIN操作的时候。（【译者注】这里原作者说到做连接操作，我们知道sqlite仅支持左连接，而且当left join时，连接条件不在where子句中，因此这里应该指select x1, x2 from tables1, tables 2 where table1.?=tables2.? 这样的连接操作。实际上，我觉得这样的设计应该是为了不需要每次查询都要拼接查询语句字符串，比如说写个select * from tablename where name = ?, 这个?每次查询都不一样，这样可以通过选择参数数组中的值来替换?，而不需要每次都”select * from tablename where name = ‘“+Michael+”’” 这样拼接字符串，Java中拼接字符串的代价是比较高的，特别是查询条件比较多的时候，连续的几次字符串+操作会创建一堆String对象）。</p>

<h3 id="toc_2">数据库更新(Upgrades)</h3>

<p>再回到数据库管理上来，让我们看一下有点小复杂的情况，数据库更新。经过一段时间的使用和开发，应用程序往往会发生变化，也许会添加新的功能，也许做了某些优化。这些变化也许需要数据库结构发生变化，并且在数据库更新代码中，通过数据库版本这个值来反映出这次更新。</p>

<p>在更新数据库时有个潜在问题，那就是有可能导致先前版本的数据库数据丢失。另外，一旦我们的应用版本超过了两个，我们不能武断的假设用户总是已经更新到最新的版本了，比如说现在发布的版本是version3.0，那么不能假设所有用户都已经更新到version2.0了，所以我们的更新操作不能是简单的从一个版本更新到下一本版本。</p>

<p>那么怎么处理这种问题呢？我们已经知道当有一个新版本数据库的时候，onUpgrade()方法就会被调用，所以理想的做法是我们在这个方法中判断数据库版本，决定执行一段或者多段更新脚本。</p>

<p>让我们看一下我们的例子中，在2.0版本中要做哪些修改:</p>

<ul>
<li>电话号码格式标准化（分机号，手机号），将电话号码存到一张独立的“numbers”数据表。</li>
<li>在雇员数据表中增加一个薪水字段。</li>
</ul>

<p>以版本1数据库为更新点，可以通过下面的SQL脚本实现更新数据库操作，并且将原来版本中的数据导入到新版本数据库中。</p>

<pre><code>CREATE TABLE numbers (
   _id INTEGER PRIMARY KEY AUTOINCREMENT,
   employid INTEGER NOT NULL,
   number TEXT NOT NULL,
   ntype INTEGER NOT NULL DEFAULT &#39;0&#39;
);
CREATE INDEX employid ON numbers(employid);
 
INSERT INTO numbers (employid, number, ntype) SELECT _id, ext, 0    FROM employees;
INSERT INTO numbers (employid, number, ntype) SELECT _id, mob, 1    FROM employees;
 
CREATE TABLE temp (
     _id INTEGER PRIMARY KEY AUTOINCREMENT,
     name TEXT NOT NULL,
     salary INTEGER NOT NULL DEFAULT &#39;0&#39;
);
INSERT INTO temp (_id, name) SELECT _id, name FROM employees;
 
DROP TABLE employees;
ALTER TABLE temp RENAME TO employees;
</code></pre>

<p>显然，对数据库结构的修改越复杂，SQL脚本写的就越复杂。同时在对SQL的支持上，SQLite与其他数据库相比有更多限制，因此有些时候你需要做些workaround绕过这些限制，举个例子，在上面的更新(update)脚本中，我不得不创建一张临时表作为SQLite不支持DROP COLUMN语句的workaround。</p>

<p>现在已经有更新（upgrade）数据库的SQL脚本了，下一步是就如何在onUpgrade方法中调用SQL脚本，下面给一个实现方法：</p>

<pre><code>@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {      
if (newVersion &gt; oldVersion) {
    switch (oldVersion) {
        case 1:
            executeSQLScript(database, &quot;update_v2.sql&quot;);
        case 2:
            executeSQLScript(database, &quot;update_v3.sql&quot;);
    }
}
}
</code></pre>

<p>在这段代码中有两个地方值得注意。：第一件是我在代码里判断新数据库的版本号是不是比旧数据库版本号大，因为onUpdategrade()方法只要两个版本不一致时都会被调用，所以也有可能导致回滚到旧版本的情况。我们的代码不希望看到这种情况，但是实际上应该考虑这种情况并且加上相应的处理代码。</p>

<p>第二件是在case分支语句中没有break。这是因为每个分支中的SQL语句都是简单的从一个版本更新(updates)到下一个版本，这样的话，如果要从版本1更新(upgrade)到版本3的时候，首先会执行从版本1更新(upgrade)到版本2的脚本，然后再执行从版本2更新(upgrade)到版本3的脚本。如果数据库已经是版本2了，那么只会执行版本2到版本3的更新(upgrade)脚本。</p>

<p>这样的话，每次你更新(upgrade)数据库时，只需要考虑从最近的版本更新到新版本需要对数据库结构做哪些修改，写出相应脚本，就可以处理从任何一个版本升级的情况了。当然，在Java代码中我们还需要更新DB_VERION的值还有其他受数据库结构变化影响的代码。<br/>
结论<br/>
在Android平台的数据持久化方法中，SQLite有着很好数据存储和管理能力，是个不错的选择。然而，和使用其他任何一种数据库一样，需要小心管理，特别是当数据库结构发生变化时更需要小心再小心。</p>

<p>最后，将部分应用逻辑写到SQL脚本中（【译者注】比如在本文例子中从旧数据库中读取数据存到新数据表中这些操作都是用SQL脚本完成的）并且保存到文件中是个简单高效的方法。这种方法让开发人员不需要在程序中写非常复杂的代码处理每次更新(upgrade)，可以将主要精力放在应用的业务逻辑上。</p>

<p>英文原文：<a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html">Gilles Debunne</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-11-22-inner-classes-static-and-non-static.html">嵌套类：静态嵌套类和非静态嵌套类</a></h1>
			<p class="meta"><time datetime="2012-11-22T23:50:10+08:00" 
			pubdate data-updated="true">2012/11/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="http://en.wikipedia.org/wiki/Inner_class">内部类</a>在维基百科的定义为:  面向对象编程中，内部类（又叫做嵌套类）是在另一个类或者接口中进行声明的类。内部类不同于子类（subclass）。（译者注：wiki的注解有误，内部类和嵌套类并不完全等同，详见下文。）</p>

<p>在Java中，上面的定义可以如下示例：</p>

<pre><code>public final class Clazz {
  private final class InnerClazz implements Runnable {
        public InnerClazz() {
        }
 
        @Override
        public void run() {
            System.out.println(&quot;Hello world&quot;);
        }
  }
 
  public Clazz() {
  }
 
  public Runnable getRunnable(){
        return new InnerClazz();
  }
}
</code></pre>

<p>上面这个示例除了声明了一个内部类之外，没做其他任何事情。我举这个例子是想强调嵌套类和内部类的不同，因为不是所有的程序员都理解这一点。</p>

<h3 id="toc_0">内部类（Inner class）</h3>

<p>上面的示例代码中声明了一个内部类“InnerClazz”。每次调用getRunnable方法的时候InnerClazz类的实例就会被创建出来。如果你在FindBugs中调试这段代码，你会看到下面这条警告信息：<br/>
SIC：应该是个静态内部类(SIC_INNER_SHOULD_BE_STATIC) 。<br/>
这个类是一个由其外部对象创建的内部类，但是它没有使用内置的指向外部对象的引用。这个引用可以使得内部类实例更大，并且可以使得外部对象的生存期尽可能长。如果可能，这个类应该被定义成静态的。</p>

<p>这条警告信息很明确：内部类会保留一个指向其父类的引用，因此只要InnerClazz类被引用了，其父类就不能被JVM的垃圾回收机制自动垃圾回收（内部类和其父类的引用关系是很稳固的，你可以通过<a href="/2012-12-03-java-objects-memory-structure.html">内存管理</a>这篇文章了解更多）。如果你想使用这个引用，下面这种嵌套类是非常有用的：</p>

<pre><code>public final class Clazz {
    private final class InnerClazz implements Runnable {
        public InnerClazz() {
        }
 
        @Override
        public void run() {
          // print the value of a member of its &quot;parent&quot; class
          // it&#39;s possible because the inner class has an implicit reference
          // on the Clazz instance
          System.out.println(_currentNumber);
        }
    }
 
     private int _currentNumber = 0;
 
     public Clazz() {
     }
 
     public Runnable getRunnable() {
            _currentNumber++;
            return new InnerClazz();
     }
}
</code></pre>

<h3 id="toc_1">非内部类的嵌套类（Nested but not inner class）</h3>

<p>如果你并不需要保留Clazz实例和InnerClazz实例之间的非常稳固的引用关系，那么就将InnerClazz声明为一个静态成员类（下面的例子中的NestedNotInnerClazz类）。</p>

<pre><code>public final class Clazz {
     // static keyword is added
    static private final class NestedNotInnerClazz implements Runnable {
        public NestedNotInnerClazz() {
        }
 
        @Override
        public void run() {
          System.out.println(&quot;Hello world&quot;);
        }
    }
 
    public Clazz() {
    }
 
    public Runnable getRunnable(){
        return new NestedNotInnerClazz();
    }
}
</code></pre>

<p>瞧瞧，多简单啊。。</p>

<p>英文原文：<a href="http://www.coderfriendly.com/2009/06/27/inner-classes-static-and-non-static/">Coder Friendly</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-11-20-spring-environment-profile.html">如何用Spring 3.1的Environment和Profile简化工作</a></h1>
			<p class="meta"><time datetime="2012-11-20T22:34:11+08:00" 
			pubdate data-updated="true">2012/11/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>编写或设计的软件通常需要部署在不同的环境，也需要使用不同的部署配置。这些部署配置大致可以分为以下几类：</p>

<ul>
<li>Java企业级容器（包括JBoss、WebLogic、Tomcat、Glassfish等）</li>
<li>独立运行的Java应用程序</li>
<li>GUI应用程序</li>
<li>测试框架</li>
</ul>

<p>本文暂不对GUI应用程序进行讨论，留到后续再说。对于其他的类型（容器、独立应用程序和测试框架）来说，代码往往是相同的。因此，在设计或者编码这类软件的时候，这一点非常关键。对于每种场景来说，我所写的代码需要完美运行在每一种场景中。</p>

<p>这是程序合格并且健壮的关键！这里的问题是，有一些资源的配置是与代码的运行平台息息相关的。在我编写单元测试的时候，我无法（其实我能，这么说是为了让你领会文章的主题）获得绑定到JNDI树上的数据源。而在容器中，我只需要遍历JNDI树，询问是否可以获取数据源即可。</p>

<p>另外，想Spring这样的框架也是鼓励这样的开发模式的，至少控制反转挺受欢迎。不同于直接用代码配置数据库和队列，Spring框架是在运行时注入这些对象的，生活依然美好。</p>

<p>你以为我的博客会把网上到处都是控制反转的示例代码再罗列一遍么？当然不是。看下面的代码：</p>

<pre><code>public class BusinessClazz implements SomethingReallyImportant {
   private DataSource dataSource;
   @Required
   public void setDataSource(DataSource dataSource) {
       this.dataSource = dataSource;
   }
}
</code></pre>

<p>数据源是通过运行时注入获得的，BusinessClazz对数据源本身一无所知。我不是世上最聪明的人，但也肯定不是最笨的人。我是说，我曾经读过像《J2ee Development Without Ejb》和《Expert one-on-one J2EE design and development》这类的书，并且自以为已经理解了其中的内容。但这些都是给妹子们看的，不是么？开个玩笑。我在Spring中间了一个数据源实例，并注入到BusinessClazz实例中。</p>

<pre><code>&lt;bean name=&quot;myBusinessClazz&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;

</code></pre>

<p>现在，我的可以完全不考虑数据源的具体实现，仍能在所有的部署环境中运行。但对于数据源呢，应该如何配置才能保证“一次配置，到处运行”？我们将注重对数据源的配置做说明，这个例子也是用于那些因运行环境或运行时不同而需要做修改的组件。</p>

<p>一般情况下，数据源需要两部分配置信息。第一部分是关于数据库位于何处，以及如何连接该数据库的信息。这里需要的信息包括主机名、款口端口号、服务名等。</p>

<p>第二部分是关于如何展示描述配置信息的。下面是一些可选方案。在其中，我建立了一个到数据库的连接，</p>

<pre><code>&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;
   class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
   &lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot;/&gt;
   &lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot;/&gt;
   &lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt;
   &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
</code></pre>

<p>也可以使用Apache的commons-dbcp库创建一个连接池，</p>

<pre><code>&lt;bean id=&quot;dataSource&quot;  class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;
 &lt;property name=&quot;driverClassName&quot; value=&quot;net.sourceforge.jtds.jdbc.Driver&quot;/&gt;
 &lt;property name=&quot;url&quot; value=&quot;jdbc:myserver&quot;/&gt;
 &lt;property name=&quot;username&quot; value=&quot;username&quot;/&gt;
 &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;
 &lt;property name=&quot;initialSize&quot; value=&quot;2&quot;/&gt;
 &lt;property name=&quot;maxActive&quot; value=&quot;5&quot;/&gt;
 &lt;property name=&quot;maxIdle&quot; value=&quot;2&quot;/&gt;
&lt;/bean
</code></pre>

<p>还可以使用容器来管理连接，再从容器中获取连接，</p>

<pre><code>&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:mydatasource&quot;/&gt;
</code></pre>

<p>当然，还有其他许多方法可以配置数据源，但为了说明问题，上面的示例已经够用了。Spring框架的<a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/beans/factory/config/PropertyPlaceholderConfigurer.html">PropertyPlaceholderConfigurer</a>类可以用来处理随运行环境而变化的属性，使用简单，功能强大。</p>

<p>现在的问题是，如何在不同的部署环境中无缝切换，并选择不同类型的数据源呢？</p>

<h4 id="toc_0">自己搞定</h4>

<p>本文所说的问题并不起最近才有的，在过去的6、7年中，许多部署团队想出了各种不同的方法来解决它。每个团队都针对其特定的问题，采取了适合自身条件的方法来解决，他们会在代码中加入一些自适应的判断来简化问题。</p>

<p>这里，希望代码可以“一次编写，到处运行”的最大驱动力之一，就是可以开发人员编写用于测试生还 生产环境代码的单元测试。</p>

<p>对这个问题的一个典型的示例方案是将数据源定义在不同上下文文件中，这些文件需要按照统一的命名约定来命名，以免造成混乱。例如，假设我们有3个操作模式，所以需要建3个不同的上下文文件，</p>

<ul>
<li>datasources-containerContext.xml</li>
<li>datasources-pooledConnection.xml</li>
<li>datasources-singleConnection.xml</li>
</ul>

<p>接下来就是平台相关的代码了，会在你的应用程序初始化Spring的时候执行。它通过Ant式的通配符跨越部署的类路径来查找上下文文件。</p>

<pre><code>ClassPathXmlApplicationContext containerContext = 
  new ClassPathXmlApplicationContext(&quot;**/**-containerContext.xml&quot;);
ClassPathXmlApplicationContext nonContainerContext = 
  new ClassPathXmlApplicationContext(&quot;**/**-pooledContext.xml&quot;);
ClassPathXmlApplicationContext testingContextContext = 
  new ClassPathXmlApplicationContext(&quot;**/**-singleContext.xml&quot;);
</code></pre>

<p>好了，在刚刚过去的几个小时里，你已经建立一个可以在多种环境中运行的系统，所编写的代码也充分利用这个特点。这个办法你已经用了好几年了，但是，这个办法的主要缺点是，每个团队、每个项目都会有自己的方式来解决前面提到的问题。</p>

<h4 id="toc_1">使用Spring Profile</h4>

<p>Spring 3.1为这个问题提供了一个解决方案（如果你还没有为自己的项目升级Spring版本，嗯，你麻烦大了）。</p>

<p>Spring在容器中引入Environment和Profile的概念。每个应用程序上下文都有一个都可以访Environment对象。</p>

<pre><code>ClassPathXmlApplicationContext classPathXmlApplicationContext = 
   new ClassPathXmlApplicationContext();
ConfigurableEnvironment configurableEnvironment = 
   classPathXmlApplicationContext.getEnvironment();
</code></pre>

<p>每种运行环境都有很多活动Profile类可供使用。大多数讲解Spring Profile的例子都是在开发模式或生产模式下。对于不同运行环境问题来说，我的解决方案是使用使用多个Profile来适应不同运行时。这个解决方案的优势是你可以自行决定如何使用Profile。</p>

<p>默认星空情况下，你所创建的Bean在载入容器中后是没有Profile对象的。下面看一个例子。假设下面是我的应用程序中，数据源实例的定义。</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;…&quot;&gt;
&lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;
  class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
  &lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>在Spring 3.0中，增加了一个新的容器类<a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/context/support/GenericXmlApplicationContext.html">GenericXmlApplicationContext</a> ，可以作为ClassPathXmlApplicationContext和FileSystemXmlApplicationContext之外的另一个选择。</p>

<p>GenericXmlApplicationContext类的特点是可以通过Setter方法完成所有的配置，而无需依靠笨重的构造器去完成配置。记住，在初始化容器的准备工作完成后，需要调用refresh()方法完成实际的初始化工作。</p>

<p>下面的代码展示了如何使用GenericXmlApplicationContext类初始化容器：</p>

<pre><code>GenericXmlApplicationContext ctx = new GenericXmlApplicationContext();
ctx.getEnvironment().setActiveProfiles(&quot;standalone&quot;);
ctx.load(&quot;*Context.xml&quot;);
ctx.refresh();
</code></pre>

<p>这里，我将活动Profile设置为“standalone”。在这个工程里，我希望代码既可以作为“standalone”运行在应用程序容器之外，还可以作为“container”运行在容器中。这里，我可以设置多个Profile，例如，下面的代码设置了Profile为“standalone”与“activemq”。</p>

<pre><code>ctx.getEnvironment().setActiveProfiles(&quot;standalone&quot;, &quot;activemq&quot;);
</code></pre>

<p>虽然做了上面的配置，实际上并不会对当前的配置上下文产生影响，因为还没有配置Profile实例。所以，修改配置上下文为：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;…&quot; profile=&quot;standalone&quot;&gt;
 &lt;bean id=&quot;dataSource&quot; destroy-method=&quot;close&quot;
  class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;
  &lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot;/&gt;
  &lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot;/&gt;
  &lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt;
  &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>只有当活动Profile设置为“standalone”时，才会实例化这个Bean。Profile是Bean的属性，而不是一个实例对象，因此，你无法配置单独的Bean来选择Profile。在较早的Spring版本中，这会导致产生多个文件，而Ant的通配符无法在运行时找到正确的配置文件。</p>

<p>在Spring 3.1中，<beans/>标签可以嵌套在<beans/>标签内。现在，我们重新编写一下数据源配置文件：</p>

<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;…&quot;&gt;
&lt;beans profile=&quot;standalone&quot;&gt;  
&lt;bean id=&quot;dataSource&quot;&gt; 
&lt;property name=&quot;driverClassName&quot; value=&quot;org.hsqldb.jdbcDriver&quot;/&gt; 
&lt;property name=&quot;url&quot; value=&quot;jdbc:hsqldb:hsql://localhost&quot;/&gt; 
&lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt; 
&lt;property name=&quot;password&quot; value=&quot;&quot;/&gt; 
&lt;/bean&gt; 
&lt;/beans&gt; 
 
&lt;beans profile=&quot;container&quot;&gt;
&lt;jee:jndi-lookup id=&quot;dataSource&quot; jndi-name=&quot;java:mydatasource&quot;/&gt;
&lt;/beans&gt;
&lt;/beans&gt;
</code></pre>

<p>这样，就可以通过下面的代码快速切换Profile：</p>

<pre><code>ctx.getEnvironment().setActiveProfiles(&quot;container&quot;);
</code></pre>

<p>另一种切换Profile的方法是在运行时作为系统参数传入：</p>

<pre><code>-Dspring.profiles.active=&quot;standalone&quot;
</code></pre>

<p>此外，也可以作为Ear/War的初始化参数传入：</p>

<pre><code>&lt;servlet&gt;
&lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
&lt;servlet-class&gt;
  org.springframework.web.servlet.DispatcherServlet
&lt;/servlet-class&gt;
&lt;init-param&gt;
  &lt;param-name&gt;spring.profiles.active&lt;/param-name&gt;
  &lt;param-value&gt;production&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/servlet&gt;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-11-15-google-play-oauth.html">Google Play服务和OAuth认证工具</a></h1>
			<p class="meta"><time datetime="2012-11-15T22:25:15+08:00" 
			pubdate data-updated="true">2012/11/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Google Play服务在2.2以上设备的发布在全球范围内已经完成，所有这些设备现在在OAuth 2.0下有了新的工具可以使用。下面是一个灵活性方面的例子，这种灵活性可以延伸Google Play服务支持的平台特性。</p>

<h3 id="toc_0">为什么是OAuth 2.0</h3>

<p>网上已经有很多用户名和密码了，而且密码的强度良莠不齐，进一步说，你的设备肯定能分辨出你是谁，这种情况下，业界一直认为，在缺乏高强度安全密码保护的前提下，OAuth 2.0是提供有效安全保障的最佳选择之一。Google Play服务使需要访问Google APIs的Android应用也可以使用OAuth 2.0，并且有很好的用户体验和安全性。</p>

<p>一般来说，当你的Android应用需要使用Google账户去访问一些东西的时候，你得选择用这个设备上的哪个账户去访问，然后必须生成一个OAuth2.0的令牌，用这个令牌在基于Http的对话框中和资源提供者交互。</p>

<p>如果使用最近为java发布的Google APIs客户端文件库的话，这些任务很大程度上可以自动完成。这里我们要讨论的是你是否直接访问服务器，比如在发送HTTP get和post请求到一个RESTful 的接口。</p>

<h3 id="toc_1">准备工作</h3>

<p>Google Play服务尽管已经开始对外发布，但在发布之后也仅限于2.2及以上版本，大部分机子已经可以使用了，但仍有少量机子不可以。也有可能用户选择自己关掉服务。</p>

<p>因为这些原因，在你开始调用前，必须确认Google Play的服务已经安装，调用<a href="https://developers.google.com/android/google-play-services/reference/com/google/android/gms/common/GooglePlayServicesUtil#isGooglePlayServicesAvailable(android.content.Context)">isGooglePlayServicesAvailable()</a>可以去确认，如何处理返回结果，在<a href="https://developers.google.com/android/google-play-services/reference/com/google/android/gms/common/ConnectionResult">ConnectionResult</a>这个类中有描述。</p>

<h3 id="toc_2">选择一个账户</h3>

<p>这不是也永远不会是复杂困难的事，这儿有许多在线的例子，可以从Android账户管理器获得账户和显示许多种选择列表。问题是它们有自己的外观界面和一些类似的东西，比如安全问题。用户有权期待系统上的一致性。</p>

<p>现在你可以使用 <a href="https://developers.google.com/android/google-play-services/reference/com/google/android/gms/common/AccountPicker">AccountPicker.newChooseAccountIntent()</a>这个方法获得一个Intent，将其传给startActivityForResult()会启动一个标准的良好的用户体验界面，如果用户愿意的话会返回给你一个账户。有两点要注意：第一，当使用这些APIs时，需要使用一个Google账户（AccountManager可以处理多个账户），所以指定 <a href="https://developers.google.com/android/google-play-services/reference/com/google/android/gms/auth/GoogleAuthUtil#GOOGLE_ACCOUNT_TYPE">GoogleAuthUtil.GOOGLE_ACCOUNT_TYPE</a>的值作为 allowableAccountTypes参数的值。第二，你不需要一个android.accounts.Account对象，只需要email地址就可以，它可以唯一确定一个google账户。</p>

<h3 id="toc_3">获取Token</h3>

<p>你能在一次调用中提供多个用空格分开的scop这里只需要调用一个方法：GoogleAuthUtil.getToken()，它需要3个参数：Context，email地址，和另一个叫着scope的字符串变量。每一个和oauth2.0对话的信息源需要公布它使用的域（scope），比如，访问Google+的api，需要的scope是e，能得到一个可以访问所有那些scope的令牌（token）。下面就是很典型的代码：</p>

<pre><code>private final static String G_PLUS_SCOPE=&quot;oauth2:https://www.googleapis.com/auth/plus.me&quot;;
 
private final static String USERINFO_SCOPE =  &quot;https://www.googleapis.com/auth/userinfo.profile&quot;;
 
private final static String SCOPES = G_PLUS_SCOPE + &quot; &quot; + USERINFO_SCOPE;
</code></pre>

<p>在理想的情况下，getToken()将会是同步的，但有3件事会让其变得不那么简单：</p>

<p>应用第一次请求token访问资源时，系统会和用户交互，询问用户是否允许。<br/>
每次请求token时，系统会和同一个后台服务器有网络会话。<br/>
处理请求的设备可能会过载而不能立马给你token，它不会让你等或者告诉你请求失败，而会告知你先离开一会儿再回来。<br/>
显然，你绝对不能在UI线程中调用getToken()，因为那会导致不可预知的延迟。</p>

<p>当你调用getToken()时，会发生以下的事情：</p>

<p>如果成功返回token，那说明各个步骤都是对的，后台认为认证是成功的，接着你处理和使用token就可以了。</p>

<p>抛出<a href="https://developers.google.com/android/google-play-services/reference/com/google/android/gms/auth/UserRecoverableAuthException">UserRecoverableAuthException</a>异常意味着你需要和用户交互，很可能是要求用户使用账户进行认证。异常有一个getIntent()方法，你可以将其返回值传给startActivityForResult()来搞定。当然你需要注意onActivityResult()是否ok。</p>

<p>抛出IOException时，说明认证服务器很忙，后者有网络异常（在移动设备上这个情况经常出现）。你不应该马上就放弃，因为再试一次可能就好了。换句话说，如果你立马返回并再次向服务器提出请求，结果不见得好。所以你需要等一下。最好的处理办法是指数退避模式。</p>

<p>抛出<a href="https://developers.google.com/android/google-play-services/reference/com/google/android/gms/auth/GoogleAuthException">GoogleAuthException</a>，意味着认证无法通过，你该礼貌地让你的用户冷静下来。如果请求的scope非法或者email地址对应的账户在当前设备上不存在的话就会发生这种异常。</p>

<p>下面是一些示例代码：</p>

<pre><code>try {
  // if this returns, the OAuth framework thinks the token should be usable
  String token = GoogleAuthUtil.getToken(this, mRequest.email(),
  mRequest.scope());
  response = doGet(token, this);
 
}catch (UserRecoverableAuthException userAuthEx) {
  // This means that the app hasn&#39;t been authorized by the user for access
  // to the scope, so we&#39;re going to have to fire off the (provided) Intent
  // to arrange for that. But we only want to do this once. Multiple
  // attempts probably mean the user said no.
  if (!mSecondTry) {
    startActivityForResult(userAuthEx.getIntent(), REQUEST_CODE);
    response = null;
  } else {
    response = new Response(-1, null, &quot;Multiple approval attempts&quot;);
  }
 
}catch (IOException ioEx) {
  // Something is stressed out; the auth servers are by definition
  //  high-traffic and you can&#39;t count on 100% success. But it would be
  //  bad to retry instantly, so back off
  if (backoff.shouldRetry()) {
    backoff.backoff();
    response = authenticateAndGo(backoff);
  } else {
    response = new Response(-1, null, &quot;No response from authorization server.&quot;);
  }
}catch (GoogleAuthException fatalAuthEx)  {
  Log.d(TAG, &quot;Fatal Authorization Exception&quot;);
  response = new Response(-1, null, &quot;Fatal authorization exception: &quot; +
  fatalAuthEx.getLocalizedMessage());
}
</code></pre>

<p>这是一个我已经提交到code.google.com上的一个用AuthorizedActivity类实现了的示例库。我们觉得这种认证行为将会是不同应用的特定行为，所以这个AuthorizedActivity类不见得对每个人都有用，但它是基于Apach2许可证，你可以在你需要的地方随便用。它已作为一个工程建立了起来，这里有一个叫做G+ Snowflake的应用，它用那个建好的工程取得了许多你在google+上的提交的东西。这个应用在google play上有，源码也在线上。</p>

<h3 id="toc_4">注册你的应用</h3>

<p>大部分进行oauth2.0认证的服务器都要你进行app注册，当然google的也不例外。访问 <a href="https://code.google.com/apis/console/%20">Google APIs Console</a>，创建一个工程，把你要访问的apis从服务菜单中拣出来，然后点击访问API的标签进行注册。输入你应用的报名，即在AndroidManifest.xml中package属性对应的值，另外需要你应用的SHA1码。任何在google play 发布过应用的人都知道秘钥和签名。但在这之前你会得到一个debug版本的应用，进行这种认证的工具在~/.android/debug.keystore，密码是android。幸运的是，你的电脑很可能已经装了keytool这个程序，你能用它来生成你的签名，对于debug版本，生成签名的命令是：</p>

<p>keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore -v -list<br/>
这就能生成SHA1签名，很容易剪切粘贴滴哦。</p>

<p>这方法可能让人觉得有点陈旧，但却值得这么做，因为戏法就是这么发生的。当你的应用被注册过，然后你生成一个token并将其发送给服务提供者，服务提供者通过google检测token是否正确，token是google发布了的，并且google提供给你应用的包名。之前你们做过这件事的家伙们可能想要知道Client IDs和API Keys了，但在这种机制下，你们并不需要它们。</p>

<h3 id="toc_5">使用你的Token</h3>

<p>假设你已经注册过你的应用并调用GoogleAuthUtil.getToken()得到了一个token，假如它就是“MissassaugaParnassus42”。然后你需要做的是，当你向服务提供者发送一个HTTP请求时，包括一个像这样的HTTP请求头：</p>

<p>然后你的HTTP GETs和POSTs开始工作了，你应该调用GoogleAuthUtil.getToken()在每次 GETs 或者 POSTs请求前获得一个token。在恰当的时候缓存数据还有处理token的到期和刷新，这些事情都不用你操心的。</p>

<p>再说一遍，如我上面说的，如果你用着为java而存在的google apis客户端很舒服，它将会为你处理所有客户端的事情，你需要做的就是去注册一下而已。</p>

<p>另外，在这里会有一些编码投入，但回报是巨大的：安全性，认证通过，已授权，拥有良好用户体验的服务访问。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-11-small-test-node-core-module.html">小试Node 核心模块</a></h1>
			<p class="meta"><time datetime="2012-10-11T18:29:58+08:00" 
			pubdate data-updated="true">2012/10/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Node核心模块提供了很多方便的系统级的API，如文件、数据流、网络、进程等。Node 的特点是采用事件驱动、非阻塞/异步IO模型，所以它提供的大部分API都是基于事件模型、异步的编程风格。下面让我们来深入了解Node的核心模块，熟悉Node的异步编程风格。</p>

<h3 id="toc_0">4.1　全局变量相关模块</h3>

<p>本小节介绍的这些对象在全局范围内均可使用，我们可以在任何位置访问这些对象。</p>

<h4 id="toc_1">4.1.1 Global Objects</h4>

<p>global {Object}<br/>
global（全局）对象可以说是ECMAScript中最特别的一个对象，这是一个看不见摸不着仿佛不存在但确又存在的对象。不属于任何其他对象的属性和方法，其实都是它的属性和方法。换句话说，所有在全局作域中定义的属性和方法，都是global对象的属性。ECMAScript对于如何访问global对象并没有给出标准定义，但是浏览器都不约而同是将这个全局对象作为window对象的一部分加以实现的。在浏览器中顶级作用域就是全局作用域，在全局作用域下通过var something即定义了一个全局变量，也可以说window多了一个something的属性。而Node中并不如此，顶级作用域并非是全局作用域，在Node的一个模块中（即一个文件中）通过var something 定义的变量仅仅作用于该模块。<br/>
process {Object}<br/>
进程对象，在4.1.5中会详细描述。<br/>
console {Object}<br/>
标准输出对象，在4.1.2中会详细描述。<br/>
Buffer {Object}<br/>
缓冲区对象，在4.1.6中会详细描述。<br/>
__filename {String}<br/>
当前正在被执行的脚本的文件名。这是一个完整的绝对路径。<br/>
<strong>dirname {String}<br/>
当前正在被执行的脚本的目录名。<br/>
module {Object}<br/>
指向当前模块对象的引用。<br/>
require() {Function}<br/>
加载模块的方法。<br/>
require.resolve()  {Function}<br/>
使用内部方法require的机制查找一个模块的位置，而不是加载模块。如果查找模块成功，会返回</strong>filename，否则抛出一个找不到模块的错误。<br/>
require.cache {Object}<br/>
模块缓存对象。模块被首次加载会以键值对的形式缓存在此对象中，键为__filename，值为module。如果模块缓存对象中的某一个键值被删除，再次加载此模块时会被重新加载。<br/>
require.paths {Array}<br/>
查找模块搜索路径数组。我们可以通过修改该数组自定义搜索路径。这个变量在0.5.x版本被移除。<br/>
exports {Object}<br/>
模块导出对象，在4.1.4中会详细描述。exports是module.exports引用的拷贝，指向同一对象。<br/>
module、require、exports、__filename和__dirname实际上并不真正是全局的，确切的说对于每个模块是局部的。<br/>
setTimeout(cb, ms) {Function}<br/>
clearTimeout(t) {Function}<br/>
setInterval(cb, ms) {Function}<br/>
clearInterval(t) {Function}<br/>
定时器方法，在4.1.3中会详细描述。</p>

<h4 id="toc_2">4.1.2 STDIO</h4>

<p>console {Object}<br/>
大部分浏览器都提供了标准输出对象提供打印输出功能。console这个对象与浏览器中的标准输出对象相似，也提供打印输出的功能。<br/>
console.log() {Function}<br/>
console.info() {Function}<br/>
console.warn() {Function}<br/>
console.error() {Function}<br/>
输出一行标准信息或标准错误到控制台。这些方法可以接收多个参数。例如：<br/>
var count = 1;<br/>
console.log(&#39;count: %d&#39;, count);//count: 1<br/>
如果方法检查到第一个参数没有格式化元素，那么会对每一个参赛调用util.inspect方法并打印输出其返回值。util.inspect方法在4.5.1中会详细描述。<br/>
console.dir(obj) {Function}<br/>
调用util.inspect方法并打印输出返回值。<br/>
console.time(label) {Function}<br/>
console.timeEnd(label) {Function}<br/>
统计一段程序运行所需时间的方法。例如：<br/>
console.time(&#39;100-elements&#39;);<br/>
for (var i = 0; i &lt; 100; i++) {<br/>
  ;<br/>
}<br/>
console.timeEnd(&#39;100-elements&#39;);// 100-elements: 0ms<br/>
console.trace(message) {Function}<br/>
在当前位置打印堆栈轨迹的方法。此方法后的代码会继续正常运行。<br/>
console.assert(expression, [message]) {Function}<br/>
断言某个表达式是否为true的方法，同断言方法assert.ok()。</p>

<h4 id="toc_3">4.1.3 Timers</h4>

<p>setTimeout(callback, delay, [arg], [...]) {Function}<br/>
该方法用于在指定的delay毫秒后单次调用callback回调函数，并可以设定要传递给回调函数的参数，返回值timeoutId可用于clearTimeout()。<br/>
clearTimeout(timeoutId) {Function}<br/>
清楚指定timeoutId的定时器。<br/>
setInterval(callback, delay, [arg], [...]) {Function}<br/>
该方法用于在指定的delay毫秒后多次重复调用callback回调函数，并可以设定要传递给回调函数的参数，返回值intervalId可用于clearInterval ()。<br/>
clearInterval(intervalId) {Function}<br/>
清楚指定intervalId的定时器。<br/>
代码示例：<br/>
var timeoutId = setTimeout(function(o, b){<br/>
  console.log(&quot;This is callback&quot;);//This is callback<br/>
  console.log(o.a);//1<br/>
  console.log(b);//2<br/>
}, 3000, {&quot;a&quot;:1}, 2);</p>

<p>clearTimeout(timeoutId);</p>

<h4 id="toc_4">4.1.4 Modules</h4>

<p>module.exports {Object} <br/>
module.exports对象是用于向外导出方法或者变量以供外部使用。在初始时，module.exports对象就是一个空对象{}，向外导出的方法和变量都将作为module.exports对象的属性。需要注意的是，module.exports需要直接快速的赋值，不能在任何回调函数中完成这个操作。以下这样的使用，会产生不期望的效果：<br/>
x.js:<br/>
setTimeout(function() {<br/>
  module.exports = { a: &quot;hello&quot; };<br/>
}, 0);<br/>
y.js:<br/>
var x = require(&#39;./x&#39;);<br/>
console.log(x.a);//undefined<br/>
我们也可以使用exports对象来完成模块导出操作。exports是module.exports引用的拷贝，指向同一对象。在使用时，我们需要避免这样的错误：<br/>
a.js:<br/>
module.exports = {a: 1};<br/>
exports.b = 2;<br/>
b.js:<br/>
var a = require(&#39;./a&#39;);<br/>
console.log(a);//{ a: 1 }<br/>
这里输出的并不是预期的{ a: 1, b: 2 }。仔细分析一下就可以明白产生这样不是预期结果的原因：module.exports和exports是引用到的同一个对象，module.exports = {}这样的赋值操作修改了module.exports的引用，但是exports的引用并没有改变，调用require()方法的时候所引用的是module.exports 对象，自然exports变量的引用就会被忽略掉了。这种问题的解决方法也很简单，一种方法是同时重写两者的引用，一种是从不重写二者的引用。<br/>
exports = module.exports = { a: 1, b: 2 };</p>

<p>exports.a = 1;<br/>
exports.b = 2;<br/>
module.require(id) {Function}<br/>
加载指定模块标识符id的方法。<br/>
module.id {String}<br/>
模块的标识符。一般为一个完整的绝对路径。<br/>
module.filename {String}<br/>
模块文件的文件名。这是一个完整的绝对路径。<br/>
module.loaded {Boolean}<br/>
模块是否加载完成。<br/>
module.parent {Object}<br/>
加载该模块的父模块对象。<br/>
module.children {Array}<br/>
模块加载的子模块对象数组。<br/>
require.main {Object}<br/>
主模块对象。我们可以使用require.main === module来判断是否是主模块。</p>

<h4 id="toc_5">4.1.5 Process</h4>

<p>process {Object}<br/>
进程对象。它是一个EventEmitter的实例。<br/>
Event: &#39;exit&#39;<br/>
当进程退出时，此事件被触发。这是一个检查模块状态的好时机（比较单元测试）。由于在exit事件触发回调函数完成后主事件循环将终止，所以计时器不会生效。<br/>
监听exit事件的示例，onexit.js：<br/>
process.on(&#39;exit&#39;, function () {<br/>
  process.nextTick(function () {<br/>
   console.log(&#39;This will not run&#39;);<br/>
  });<br/>
  console.log(&#39;About to exit.&#39;);<br/>
});<br/>
Event: &#39;uncaughtException&#39;<br/>
当发生一个未处理的异常时，此事件会被触发。如果该异常有这样一个监听器，那么不执行默认行为（即打印错误堆栈信息并结束应用程序的执行）。<br/>
监听uncaughtException事件的示例，uncaughtException.js：<br/>
process.on(&#39;uncaughtException&#39;, function (err) {<br/>
  console.log(&#39;Caught exception: &#39; + err);<br/>
});</p>

<p>setTimeout(function () {<br/>
  console.log(&#39;This will still run.&#39;);<br/>
}, 500);</p>

<p>// Intentionally cause an exception, but don&#39;t catch it.<br/>
nonexistentFunc();<br/>
console.log(&#39;This will not run.&#39;);<br/>
注意，uncaughtException事件是一种非常粗糙的异常处理机制。我们可以在程序中使用try/catch来更好的控制程序流程。特别是对于在服务器端程序，因为它要持续运行，所以uncaughtException事件是个很有用的安全机制。<br/>
Signal Events<br/>
当进程接收到信号时，此事件会被触发。具体信号名请查看sigaction(2)中的标准POSIX信号名称列表，比如SIGINT、SIGUSR1等。<br/>
监听SIGINT信号的示例，SIGINT.js：<br/>
// Start reading from stdin so we don&#39;t exit.<br/>
process.stdin.resume();</p>

<p>process.on(&#39;SIGINT&#39;, function () {<br/>
  console.log(&#39;Got SIGINT.  Press Control-D to exit.&#39;);<br/>
});<br/>
发送SIGINT信号最简单的方法是使用CTRL+C，大多数情况下这会终止应用程序的执行。<br/>
process.stdout {Object}<br/>
标准输出流对象。console.log方法的定义：<br/>
console.log = function (d) {<br/>
  process.stdout.write(d + &#39;\n&#39;);<br/>
};<br/>
process.stderr {Object}<br/>
错误输出流对象。<br/>
process.stdout 和process.stderr不像Node中的其他数据流，它们在写入时通常阻塞。他们在被指向到普通文件或者TTY文件描述符时是阻塞的；指向到数据通道时是非阻塞的。<br/>
process.stdin {Object}<br/>
标准输入流对象。默认情况下标准输入流会阻塞程序，要读取输入内容需要调用方法process.stdin.resume()。<br/>
下面是打开标准输入并监听它的两个事件的示例，stdin.js:<br/>
process.stdin.resume();<br/>
process.stdin.setEncoding(&#39;utf8&#39;);</p>

<p>process.stdin.on(&#39;data&#39;, function (chunk) {<br/>
  process.stdout.write(&#39;data: &#39; + chunk);<br/>
});</p>

<p>process.stdin.on(&#39;end&#39;, function () {<br/>
  process.stdout.write(&#39;end&#39;);<br/>
});<br/>
process.argv {Array}<br/>
命令行参数数组。第一个参数是&quot;node&quot;，第二个参数是JavaScript文件的绝对路径。接下来是附加的命令行参数。<br/>
argv.js:<br/>
// print process.argv<br/>
process.argv.forEach(function (val, index, array) {<br/>
  console.log(index + &#39;: &#39; + val);<br/>
});<br/>
上面的代码将产生如下输出：<br/>
$ node process-2.js one two=three four<br/>
0: node<br/>
1: /Users/mjr/work/node/process-2.js<br/>
2: one<br/>
3: two=three<br/>
4: four<br/>
process.execPath {String}<br/>
进程可执行文件的绝对路径。<br/>
process.cwd() {Function}<br/>
返回进程的当前工作目录。<br/>
process.chdir(directory) {Function}<br/>
改变进程的当前工作目录，失败时抛出异常。<br/>
chdir.js<br/>
console.log(&#39;Starting directory: &#39; + process.cwd());<br/>
try {<br/>
  process.chdir(&#39;/tmp&#39;);<br/>
  console.log(&#39;New directory: &#39; + process.cwd());<br/>
}<br/>
catch (err) {<br/>
  console.log(&#39;chdir: &#39; + err);<br/>
}<br/>
process.env {Object}<br/>
装有用户环境变量的对象。<br/>
process.exit([code]) {Function}<br/>
使用指定的退出代码进程退出进程。如果不指定参数，方法将使用表示成功的代码0。退出程序并返回错误状态的示例，exit.js:<br/>
process.exit(1);<br/>
执行node的shell将会得到返回值1。<br/>
process.getgid() {Function}<br/>
获取进程的群组标识（详见getgid(2)）。这是一个数字的群组ID，不是群组名称。<br/>
process.setgid(id) {Function}<br/>
设置进程的群组标识（详见setgid(2)）。参数可以是一个数字ID或者群组名字符串。如果指定了一个群组名，这个方法会阻塞等待将群组名解析为数字ID。<br/>
gid.js:<br/>
console.log(&#39;Current gid: &#39; + process.getgid());<br/>
try {<br/>
  process.setgid(501);<br/>
  console.log(&#39;New gid: &#39; + process.getgid());<br/>
}<br/>
catch (err) {<br/>
  console.log(&#39;Failed to set gid: &#39; + err);<br/>
}<br/>
process.getuid() {Function}<br/>
获取进程的用户ID（详见getuid(2)）。这是一个数字用户ID，不是用户名。<br/>
process.setuid(id) {Function}<br/>
设置进程的用户ID（详见setuid(2)）。参数可以是一个数字ID或者用户名字符串。如果指定了一个用户名，那么该方法会阻塞等待将用户名解析为数字ID。<br/>
uid.js：<br/>
console.log(&#39;Current uid: &#39; + process.getuid());<br/>
try {<br/>
  process.setuid(501);<br/>
  console.log(&#39;New uid: &#39; + process.getuid());<br/>
}<br/>
catch (err) {<br/>
  console.log(&#39;Failed to set uid: &#39; + err);<br/>
}<br/>
process.version {String}<br/>
一个编译内置的属性，用于显示Node的版本。<br/>
version.js:<br/>
console.log(&#39;Version: &#39; + process.version);<br/>
process.versions {Object}<br/>
用于显示Node依赖库的版本的对象。<br/>
versions.js:<br/>
console.log(process.versions);<br/>
输出如下：<br/>
{ node: &#39;0.6.19&#39;,<br/>
  v8: &#39;3.6.6.25&#39;,<br/>
  ares: &#39;1.7.5-DEV&#39;,<br/>
  uv: &#39;0.6&#39;,<br/>
  openssl: &#39;0.9.8r&#39; }<br/>
process.installPrefix {String}<br/>
一个编译内置的属性，用于显示Node的安装目录的前缀NODE_PREFIX。<br/>
installPrefix.js:<br/>
console.log(&#39;Prefix: &#39; + process.installPrefix);<br/>
process.kill(pid, [signal]) {Function}<br/>
向一个进程发送信号，参数pid为进程ID，参数signal是一个描述要发送信号的字符串，如“SIGINT”或者“SIGUSR1”。如果不指定，默认发送“SIGTERM”信号。更多信息请查看kill(2)。<br/>
注意，虽然此方法名为process.kill，但是它仅仅用于发送信号，就像kill系统调用一样。发送的信号除了可以结束目标进程外，还可以完成其他的操作。<br/>
发送信号的示例，kill.js:<br/>
process.on(&#39;SIGHUP&#39;, function () {<br/>
  console.log(&#39;Got SIGHUP signal.&#39;);<br/>
});</p>

<p>setTimeout(function () {<br/>
  console.log(&#39;Exiting.&#39;);<br/>
  process.exit(0);<br/>
}, 100);</p>

<p>process.kill(process.pid, &#39;SIGHUP&#39;);<br/>
process.pid {String}<br/>
进程PID。<br/>
process.title {String}<br/>
设置、获取ps命令中显示的名称。<br/>
process.arch {String}<br/>
运行程序的处理器架构：“arm”、“ia32”、“x64”。<br/>
process.platform {String}<br/>
程序运行的平台，如“linux2”、“darwin”等。<br/>
process.memoryUsage() {Function}<br/>
返回一个描述Node进程内存使用情况的对象。<br/>
memoryUsage.js:<br/>
console.log(process.memoryUsage());<br/>
输出如下：<br/>
{ rss: 8552448, heapTotal: 2546784, heapUsed: 1234140 }<br/>
heapTotal和heapUsed指V8内存使用情况。<br/>
process.nextTick(callback) {Function}<br/>
在事件循环的下一轮执行callback回调函数。这个方法不是setTimeout(fn, 0)的别名，它更加高效。<br/>
nextTick.js：<br/>
process.nextTick(function () {<br/>
  console.log(&#39;nextTick callback&#39;);<br/>
});<br/>
process.umask([mask]) {Function}<br/>
设置或读取进程的文件创建模式掩码，子进程会从父进程继承这个掩码。如果使用此方法设置新的掩码，则它返回旧的掩码，否则返回当前掩码。<br/>
umask.js:<br/>
var oldmask, newmask = 0644;<br/>
oldmask = process.umask(newmask);<br/>
console.log(&#39;Changed umask from: &#39; + oldmask.toString(8) + &#39; to &#39; + newmask.toString(8));<br/>
process.uptime() {Function}<br/>
返回Node进程运行的时间，单位为秒。<br/>
uptime.js:<br/>
console.log(process.uptime());</p>

<h4 id="toc_6">4.1.6 Buffer</h4>

<p>Buffer {Class}<br/>
纯JavaScript语言对Unicode很友好，但是难以处理二进制数据。在处理TCP数据流和文件时不可避免地需要操作字节流。Node提供一些方法来创建、操作和接收二进制数据。<br/>
原始的数据被存放在Buffer的实例中。Buffer类似于一个整数数组，不同之处在于它和V8内存堆之外分配的一段内存数据相对应。Buffer对象的大小不能动态调整。Buffer是全局的，不需要在使用前还需每次&quot;require(&#39;buffer&#39;)&quot;后才能够使用它，并有多种不同的方法实例化。<br/>
Buffer和JavaScript中的String对象之间的转换需要指定编码方式。如下是Node支持的编码方式:<br/>
&#39;ascii&#39; - 仅对应7位的ASCII数据。这种编码方式速度很快，它会删除字节的高位。<br/>
&#39;utf-8&#39; - Unicode字符。许多网页和其他文档使用这种编码方式。<br/>
&#39;ucs2&#39; - 2字节的，低字节序编码Unicode字符。它只能编码BMP（基本多语言面，U+0000-U+FFFF）字符。<br/>
&#39;base64&#39; - base64字符串编码。<br/>
&#39;binary&#39; - 一种只使用每个字符前8个字节将原始二进制数据编码进字符串的方式。这个方式已经废弃，应当尽量使用buffer对象。这个编码将在未来版本中移除。<br/>
&#39;hex&#39; - 将一个字节编码为两个16进制字符。<br/>
new Buffer(size) {ClassMethod}<br/>
创建指定大小的Buffer对象。<br/>
new Buffer(array) {ClassMethod}<br/>
用数组新建Buffer对象。<br/>
new Buffer(str, [encoding]) {ClassMethod}<br/>
新建一个保存指定字符串的Buffer对象。字符编码默认&#39;utf-8&#39;。<br/>
buf.write(string, [offset], [length], [encoding]) {Function}<br/>
使用指定的编码方式将字符串从指定偏移量开始写入Buffer，然后返回实际写入的大小。编码默认是&#39;utf-8&#39;，偏移量默认是0，length为写入的字节长度。如果Buffer空间不足，则只会写入部分字符串。这种方式不会出现一个字符被拆分成半个字符被写入。下面是将一个utf-8字符串写入buffer，然后打印出来的示例，write.js：<br/>
buf = new Buffer(256);<br/>
len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);<br/>
console.log(len + &quot; bytes: &quot; + buf.toString(&#39;utf8&#39;, 0, len));<br/>
//12 bytes: ½ + ¼ = ¾<br/>
buf.toString([encoding], [start], [end]) {Function}<br/>
使用指定的编码方式将Buffer从指定起始位置到指定结束位置解码为字符串并返回。编码默认是&#39;utf-8&#39;，起始位置默认是0，结束位置默认为Buffer的长度。<br/>
buf[index] {Byte}<br/>
获取或设置位于索引字节的值。由于返回值为单个的字节，因此其范围应该在0x00到0xff（16进制）或者0到255（10进制）之间。下面是将一个ASCII字符串复制进Buffer，每次一个字节，index.js：<br/>
str = &quot;node.js&quot;;<br/>
buf = new Buffer(str.length);<br/>
for (var i = 0; i &lt; str.length ; i++) {<br/>
  buf[i] = str.charCodeAt(i);<br/>
}<br/>
console.log(buf);<br/>
Buffer.isBuffer(obj) {ClassMethod}<br/>
验证传入的对象是否是Buffer的一个实例。<br/>
Buffer.byteLength(string, [encoding]) {ClassMethod}<br/>
返回字符串的实际字节数。这个方法和String.prototype.length不同，后者返回字符串的字符数。<br/>
byteLength.js：<br/>
str = &#39;\u00bd + \u00bc = \u00be&#39;;</p>

<p>console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +<br/>
  Buffer.byteLength(str, &#39;utf8&#39;) + &quot; bytes&quot;);</p>

<p>// ½ + ¼ = ¾: 9 characters, 12 bytes<br/>
buf.length {Number}<br/>
Buffer的大小（以字节为单位）。请注意，这个不是存放内容的大小，而是分配buffer对象的内存大小。这个大小不随Buffer中存放内容的多少而改变。<br/>
length.js：<br/>
buf = new Buffer(1234);</p>

<p>console.log(buf.length);// 1234<br/>
buf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);<br/>
console.log(buf.length);// 1234<br/>
buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd]) {Function}<br/>
在两个Buffer之间执行内存拷贝。targetStart和sourceStart默认为0，sourceEnd默认为buf.length。例如，新建连个buffer对象，然后将buf1中16至19字节拷贝到buf2中第8字节开始的空间中。<br/>
copy.js：<br/>
buf1 = new Buffer(26);<br/>
buf2 = new Buffer(26);</p>

<p>for (var i = 0 ; i &lt; 26 ; i++) {<br/>
  buf1[i] = i + 97; // 97 is ASCII a<br/>
  buf2[i] = 33; // ASCII !<br/>
}</p>

<p>buf1.copy(buf2, 8, 16, 20);<br/>
console.log(buf2.toString(&#39;ascii&#39;, 0, 25));<br/>
// !!!!!!!!qrst!!!!!!!!!!!!!<br/>
buf.slice([start], [end]) {Function}<br/>
返回指定起始位置和结束位置的原Buffer引用的分片。当修改新Buffer时也将会被体现在原Buffer上，因为两个Buffer指向同一段内存地址。例如，使用字母表简历一个Buffer对象，并分片出一个新的Buffer，然后修改原始Buffer的一个字节。<br/>
slice.js：<br/>
var buf1 = new Buffer(26);</p>

<p>for (var i = 0 ; i &lt; 26 ; i++) {<br/>
  buf1[i] = i + 97; // 97 is ASCII a<br/>
}</p>

<p>var buf2 = buf1.slice(0, 3);<br/>
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));// abc<br/>
buf1[0] = 33;// ASCII !<br/>
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));// !bc<br/>
buf.fill(value, [offset], [end]) {Function}<br/>
用指定的值填充Buffer。如果偏移量offset（默认0）和结束位置end（默认buf.length）都没有值，它将填充整个Buffer。<br/>
fill.js：<br/>
var b = new Buffer(50);<br/>
b.fill(&quot;h&quot;);<br/>
console.log(b);<br/>
buf.inspect()<br/>
返回Buffer的字符串表示，每个字节用十六进制表示。当调用console.dir的时候打印的就是这个方法返回的结果。当Buffer超长（默认为50）时，会用...省略超长的内容。<br/>
buffer.INSPECT_MAX_BYTES  {Number}<br/>
这个数值会在调用buffer.inspect()方法时被用到，默认为50，我们可以直接对这个属性赋值来修改其值的大小。<br/>
注意，这是buffer核心模块的一个属性，需要通过调用require(&#39;buffer&#39;)返回的对象来访问，它不是全局的Buffer或者Buffer实例的属性。<br/>
SlowBuffer {Class}<br/>
SlowBuffer 这个类主要是内部使用。JavaScript程序应该使用Buffer，避免使用SlowBuffer 。SlowBuffer 不是全局的，需要导入后才可以使用。为了避免频繁的给Buffer对象分配小内存块，对于创建小于8k的Buffer，其实是从一个池中分片得来的，只有大于8k的Buffer才会每次都新创建一个SlowBuffer实例。<br/>
Buffer.poolSize {Number}<br/>
Buffer类创建的池大小，大于此值则每次new一个SlowBuffer，否则从池中slice返回一个Buffer，如果池剩余空间不够，则新创建一个SlowBuffer做为池。我们可以直接对这个属性赋值来修改池的大小。<br/>
除了上述方法外，Buffer模块还提供了许多读取和写入各种数值类型的方法，我们可以在Node的官方文档Buffer模块（<a href="http://www.nodejs.org/api/buffer.html%EF%BC%89%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%86%8D%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E3%80%82">http://www.nodejs.org/api/buffer.html）中查看到，这里就不再详细描述。</a></p>

<h3 id="toc_7">4.2　事件模块</h3>

<h4 id="toc_8">4.2.1 Events</h4>

<p>events.EventEmitter {Class}<br/>
事件驱动是Node一个很重要的特点。Node中有很多对象都会触发事件，比如一个进程退出时会触发事件。所有能够触发事件的对象都是EventEmitter的实例。我们可以通过require(&quot;events&quot;)来访问这个模块，通过调用require(&#39;events&#39;).EventEmitter可以使用事件触发器类。通常，事件名称采用驼峰式命名法，不过目前没有对事件名称作任何限制，也就是说任何字符串都可以被用作事件名。<br/>
Event: &#39;newListener&#39;<br/>
可以将函数注册给对象，使其在事件触发时执行，此类函数被称作监听器。当新的事件监听器被添加时，事件触发器都会触发&#39;newListener&#39;事件。<br/>
Event: &#39;error&#39;<br/>
当事件触发器遇到错误时，会触发&#39;error&#39;事件。这个事件特殊的地方在于：如果没有监听器处理这个事件，它将会输出堆栈信息，并退出应用程序。<br/>
emitter.addListener(event, listener) {Function}<br/>
emitter.on(event, listener) {Function}<br/>
这两个方法都可以将一个监听器添加到指定的事件监听器数组的末尾。<br/>
server.on(&#39;connection&#39;, function (stream) {<br/>
  console.log(&#39;someone connected!&#39;);<br/>
});<br/>
emitter.once(event, listener) {Function}<br/>
这个方法可以添加一次性的监听器。该监听器在事件触发第一次时执行，随后被移除。<br/>
server.once(&#39;connection&#39;, function (stream) {<br/>
  console.log(&#39;Ah, we have our first user!&#39;);<br/>
});<br/>
emitter.removeListener(event, listener) {Function}<br/>
将监听器从指定的事件的监听器数组中移除出去。非常值得注意的是：这个操作将会改变监听器数组的下标。<br/>
var callback = function(stream) {<br/>
  console.log(&#39;someone connected!&#39;);<br/>
};<br/>
server.on(&#39;connection&#39;, callback);<br/>
// ...<br/>
server.removeListener(&#39;connection&#39;, callback);<br/>
emitter.removeAllListeners([event]) {Function}<br/>
将指定事件的所有监听器从监听器数组中移除。<br/>
emitter.setMaxListeners(n) {Function}<br/>
默认情况下，当事件触发器注册了超过10个以上的监听器时，系统会打印警告信息。这个默认配置将有助于我们查找内存泄漏问题。很显然并不是所有的事件触发器都需要进行10个监听器的限制，此方法允许我们手动设置该数量值。如果这个值被设置为0，意味着没有数量限制。<br/>
emitter.listeners(event) {Function}<br/>
返回指定事件的监听器数组。我们可以对该数组进行操作，比如删除监听器等。<br/>
server.on(&#39;connection&#39;, function (stream) {<br/>
  console.log(&#39;someone connected!&#39;);<br/>
});<br/>
var listeners = server.listeners(&#39;connection&#39;);<br/>
console.log(util.inspect(listeners);// [ [Function] ]<br/>
emitter.emit(event, [arg1], [arg2], [...]) {Function}<br/>
顺序执行监听器列表中的每个监听器函数并传递相应的参数。</p>

<h3 id="toc_9">4.3　文件和数据流相关模块</h3>

<h4 id="toc_10">4.3.1 Stream</h4>

<p>Stream（流）是一个抽象接口，Node中有很多实例对象实现了这个接口。例如，请求http服务器的request是一个流。所有的流都是EventEmitter的实例。流可以分为可读的、可写的或者既可读又可写。所以下面分两部分来介绍流，一部分为可读流，另一部分来可写流。<br/>
Readable Stream（可读流）具有下述的事件、成员和方法。<br/>
Event: &#39;data&#39; function (data) { }<br/>
&#39;data&#39;事件的回调函数参数默认情况下是一个Buffer对象。如果使用了setEncoding()则参数为一个字符串。<br/>
Event: &#39;end&#39; function () { }<br/>
此事件在流中遇到EOF（TCP中为FIN）时被触发，表示流不会再有数据（不会触发&#39;data事件&#39;）。如果流同时也是可写的，那它还可以继续写入。<br/>
Event: &#39;error&#39; function (exception) { }<br/>
此事件在读取数据出错时被触发。<br/>
Event: &#39;close&#39; function () { }<br/>
当底层的文件描述符被关闭时触发此事件，并不是所有的流都会触发这个事件。例如，一个http请求就不会触发&#39;close&#39;事件。<br/>
Event: &#39;fd&#39; function (fd) { }<br/>
当流读取到文件描述符信息时触发此事件。一个文件数据流包含两部分信息：文件描述符信息和文件数据信息。此事件只支持Unix流，其他类型的流不会触发此事件。<br/>
stream.readable {Boolean}<br/>
这是一个布尔值，默认为true。当读取流遇到错误（&#39;error&#39;事件）或者读到结尾（&#39;end&#39;事件）或者调用destroy()方法后，该值会设置为false。<br/>
stream.setEncoding(encoding) {Function}<br/>
调用此方法后，&#39;data&#39;事件的回调函数参数会由默认的Buffer变为字符串。这个方法的参数编码类型科研室&#39;utf-8&#39;、&#39;ascii&#39;或&#39;base64&#39;。<br/>
stream.pause() {Function}<br/>
暂停&#39;data&#39;事件的触发。<br/>
stream.resume() {Function}<br/>
恢复被pause()方法暂停的&#39;data&#39;事件。<br/>
stream.destroy() {Function}<br/>
关闭底层的文件描述符。流将不会再触发任何事件。<br/>
stream.pipe(destination, [options]) {Function}<br/>
这是Stream.prototype（Stream原型对象）的一个方法，所有Stream对象都可以使用它。这个方法用于将这个可读流与流向目标连接起来，传入这个流中数据将会写入的流向目标中。通过在必要时暂停和恢复流，使来源流和目的流得以保持同步。以模拟Unix系统的cat命令为例：<br/>
process.stdin.resume();<br/>
process.stdin.pipe(process.stdout);<br/>
默认情况下，当来源流的&#39;end&#39;事件出发时，目的流的end()方法会被调用，此时目的流将不再可写入。要在这种情况下为了保持目的流仍然可写入，可将options参数设置为{ end: false}。这使process.stdout保存打开状态，因此&quot;Goodbye&quot;可以在end事件发生后被写入。<br/>
process.stdin.resume();</p>

<p>process.stdin.pipe(process.stdout, { end: false });</p>

<p>process.stdin.on(&quot;end&quot;, function() {<br/>
  process.stdout.write(&quot;Goodbye\n&quot;);<br/>
});<br/>
注意：如果来源流不支持pause()和resume()方法，pipe此方法将在来源流对象上增加这两个方法的简单定义，使其可以触发&#39;pause&#39;和&#39;resume&#39;事件。<br/>
Writable Stream（可写流）具有下述的事件、成员和方法。<br/>
Event: &#39;drain&#39; function () { }<br/>
当在write()方法被调用并返回false后触发此事件。此事件被触发说明缓冲区已空，再次写入是安全的。<br/>
Event: &#39;error&#39; function (exception) { }<br/>
此事件在发生错误的时候被触发，回调函数接受一个异常参数exception。<br/>
Event: &#39;close&#39; function () { }<br/>
底层文件描述符被关闭时触发此事件。<br/>
Event: &#39;pipe&#39; function (src) { }<br/>
当此可写流作为参数传给一个可读流的pipe方法时触发此事件。<br/>
stream.writable {Boolean}<br/>
这是一个布尔值，默认为true。当读取流遇到错误（&#39;error&#39;事件）或者end()/destroy()方法被调用后，该值会设置为false。<br/>
stream.write(string, [encoding], [fd]) {Function}<br/>
使用指定编码encoding将字符串string写入到流中。如果字符串被成功写入内核缓冲区，此方法返回true。如果内核缓冲区已满，此方法返回false，数据将在未来被写出。当内核缓冲区再次被清空后，&#39;drain&#39;事件将被触发。Encoding参数默认为&#39;utf-8&#39;。<br/>
如果指定了可选参数fd，它将被作为一个文件描述符通过流传送。此功能仅被Unix流所支持，对于其他流此操作将被忽略而没有任何提示。当使用此方法传送一个文件描述符时，如果在流没有清空前关闭此文件描述符，将造成传送一个无效（已关闭）FD的风险。<br/>
stream.write(buffer) {Function}<br/>
与上面的write方法类似，写入一个Buffer对象。<br/>
stream.end() {Function}<br/>
使用EOF或FIN结束一个流的输出。<br/>
stream.end(string, encoding) {Function}<br/>
以指定的字符编码encoding写入一个字符串string，然后使用EOF或FIN结束流的输出。这对降低数据包传输量有所帮助。<br/>
stream.end(buffer) {Function}<br/>
与上面的end方法类似，写入一个Buffer对象，然后使用EOF或FIN结束流的输出。<br/>
stream.destroy() {Function}<br/>
关闭底层的文件描述符。流将不会再触发任何事件。<br/>
stream.destroySoon() {Function}<br/>
清空当前的写队列（写操作完成），然后关闭文件描述符。</p>

<h4 id="toc_11">4.3.2 Readline</h4>

<p>Readline模块可以帮助我们一行一行地读取一个流（如STDIN）。我们可以调用require(&#39;readline&#39;)来使用此模块。<br/>
注意：一旦我们调用这个模块，Node程序不会终止，直到我们关闭这个接口和STDIN流。如何正常终止我们的程序，请看下面的例子。<br/>
createInterface.js:<br/>
var rl = require(&#39;readline&#39;);</p>

<p>var i = rl.createInterface(process.stdin, process.stdout, null);<br/>
i.question(&quot;What do you think of node.js?&quot;, function(answer) {<br/>
  // TODO: Log the answer in a database<br/>
  console.log(&quot;Thank you for your valuable feedback.&quot;);</p>

<p>// These two lines together allow the program to terminate. <br/>
  // Without them, it would run forever.<br/>
  i.close();<br/>
  process.stdin.destroy();<br/>
});<br/>
rl.createInterface(input, output, completer) {Function}<br/>
创建一个读行接口，方法接收的参数是输入input与输出output两个流。参数completer是一个方法，用于自动完成。当接收到一个子串，它会返回[[substr1, substr2, ...], originalsubstring]。Completer方法也可以在异步模式下运行，这样它需要接收两个参数：<br/>
function completer(linePartial, callback) { callback(null, [[&#39;123&#39;], linePartial]); }<br/>
createInterface这个方法常与process.stdin和 process.stdout并用，以接收用户输入。<br/>
Interface {Class}<br/>
用于stdin和stdout这两个流进行一行一行读取流操作的抽象接口类。<br/>
rl.setPrompt(prompt, length) {Function}<br/>
设置提示。比如当你在Node命令行模式（在终端上直接运行node命令不带任何参数即可进入命令行模式）上时，你会看到这样的提示&#39;&gt;&#39;。<br/>
rl.prompt() {Function}<br/>
用当前的提示信息新起一行以供用户输入，并准备好从用户输入读取一行。<br/>
rl.question(query, callback) {Function}<br/>
先显示提示信息query，然后调用callback这个回调函数来响应用户的输入。<br/>
rl.close() {Function}<br/>
关闭TTY。<br/>
rl.pause() {Function}<br/>
暂停TTY。<br/>
rl.resume() {Function}<br/>
恢复TTY。<br/>
rl.write() {Function}<br/>
写入TTY。<br/>
Event: &#39;line&#39; function (line) {}<br/>
当在流中接收到\n就会触发此事件。通常当用户敲打回车或者退出就会触发此事件。这是一个很好的钩子去监听用户的输入。例如这样监听每一行的输入：<br/>
rl.on(&#39;line&#39;, function (cmd) {<br/>
  console.log(&#39;You just typed: &#39;+cmd);<br/>
});<br/>
Event: &#39;close&#39; function () {}<br/>
当在流中接收到<sup>C（SIGINT）或<sup>D（EOT）就会触发此事件。这是一个探知用户已经完成使用应用程序的很好的方式。例如可以这样监听close事件，并随后退出程序:</sup></sup><br/>
rl.on(&#39;close&#39;, function() {<br/>
  console.log(&#39;goodbye!&#39;);<br/>
  process.exit(0);<br/>
});<br/>
这里有一个如何融合使用前面介绍的事件和方法模拟出一个简单的命令行交互的例子，readline.js:<br/>
var readline = require(&#39;readline&#39;),<br/>
  rl = readline.createInterface(process.stdin, process.stdout),<br/>
  prefix = &#39;OHAI&gt; &#39;;</p>

<p>rl.on(&#39;line&#39;, function(line) {<br/>
  switch(line.trim()) {<br/>
    case &#39;hello&#39;:<br/>
      console.log(&#39;world!&#39;);<br/>
      break;<br/>
    default:<br/>
      console.log(&#39;Say what? I might have heard <code>&#39; + line.trim() + &#39;</code>&#39;);<br/>
      break;<br/>
  }<br/>
  rl.setPrompt(prefix, prefix.length);<br/>
  rl.prompt();<br/>
}).on(&#39;close&#39;, function() {<br/>
  console.log(&#39;Have a great day!&#39;);<br/>
  process.exit(0);<br/>
});<br/>
console.log(prefix + &#39;Good to see you. Try typing stuff.&#39;);<br/>
rl.setPrompt(prefix, prefix.length);<br/>
rl.prompt();</p>

<h4 id="toc_12">4.3.3 TTY</h4>

<p>在Linux中，TTY也许是跟终端有关系的最为混乱的术语。TTY是TeleTYpe的一个老缩写。Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，和古老的电报机区别并不是很大。之后，当计算机只能以批处理方式运行时(当时穿孔卡片阅读器是唯一一种使程序载入运行的方式)，电传打字机成为唯一能够被使用的“实时”输入/输出设备。最终，电传打字机被键盘和显示器终端所取代，但在终端或TTY接插的地方，操作系统仍然需要一个程序来监视串行端口。TTY也可以简单理解为一个程序监视物理的TTY/终端接口。我们可以调用require(&#39;tty&#39;)来使用此模块。<br/>
tty.js:<br/>
var tty = require(&#39;tty&#39;);<br/>
process.stdin.resume();<br/>
tty.setRawMode(true);<br/>
process.stdin.on(&#39;keypress&#39;, function(char, key) {<br/>
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &#39;c&#39;) {<br/>
    console.log(&#39;graceful exit&#39;);<br/>
    process.exit();<br/>
  }<br/>
});<br/>
tty.isatty(fd) {Function}<br/>
这个方法返回一个布尔值。这取决于文件描述符fd是否和本终端有关联，有关联返回true，否则返回false。<br/>
tty.setRawMode(mode) {Function}<br/>
参数mode是一个布尔值，可以被设置为true或false。此方法可以改变当前进程的stdin（标准输入）为原始设备方式或默认方式。</p>

<h4 id="toc_13">4.3.4 Path</h4>

<p>Path模块包含很多用于处理文件路径的小工具。几乎所有方法仅仅是执行字符串的转换，并没有去文件系统检查是否是有效的路径。Path.exists和path.existsSync这两个方法是例外，很容易发现这两个方法是在访问文件系统。我们可以调用require(&#39;path&#39;)来使用此模块。<br/>
path.normalize(p)<br/>
该方法用于标准化一个字符型的路径。请注意&#39;..&#39;和&#39;.&#39;的使用。当发现有多个斜杠（/）时，系统会将他们替换为一个斜杠；如果路径末尾中包含有一个斜杠，那么系统会保留这个斜杠。在Windows中，上述路径中的斜杠（/）要换成反斜杠（\）。<br/>
normalize.js:<br/>
var path = require(&#39;path&#39;);<br/>
var string = &#39;/foo/bar//baz/asdf/quux/..&#39;;<br/>
string = path.normalize(string);<br/>
console.log(string);<br/>
// returns  &#39;/foo/bar/baz/asdf&#39;<br/>
path.join([path1], [path2], [...])<br/>
该方法用于合并传入的参数得到一个标准化的路径字符串。<br/>
join.js：<br/>
var path = require(&#39;path&#39;);<br/>
var string = path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz/asdf&#39;, &#39;quux&#39;, &#39;..&#39;);<br/>
console.log(string);<br/>
// returns  &#39;/foo/bar/baz/asdf&#39;<br/>
path.resolve([from ...], to)<br/>
将参数to解析为绝对路径。如果参数 to当前不是绝对的，系统会将from 参数按从右到左的顺序依次前缀到to上，直到在from中找到一个绝对路径时停止。如果遍历所有from中的路径后，系统依然没有找到一个绝对路径，那么当前工作目录也会作为参数使用。最终得到的路径是标准化的字符串，并且标准化时系统会自动删除路径末尾的斜杠，但是如果获取的路径是解析到根目录的，那么系统将保留路径末尾的斜杠。你也可以将这个方法理解为Shell中的一组cd命令。path.resolve(&#39;foo/bar&#39;, &#39;/tmp/file/&#39;, &#39;..&#39;, &#39;a/../subfile&#39;)就类似于：<br/>
cd foo/bar<br/>
cd /tmp/file/<br/>
cd ..<br/>
cd a/../subfile<br/>
pwd<br/>
该方法与cd命令的区别在于该方法中不同的路径不一定存在，而且这些路径也可能是文件。<br/>
resolve.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;)<br/>
// returns &#39;/foo/bar/baz&#39;</p>

<p>path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;)<br/>
// returns &#39;/tmp/file&#39;</p>

<p>path.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;)<br/>
// if currently in /home/myself/node, it returns<br/>
// &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;<br/>
path.relative(from, to)<br/>
解析参数，返回相对路径。有时我们有两个绝对路径，我们需要获得从一个到另一个的相对路径。这实际上相当于path.resolve的反向转换，就像这样：<br/>
path.resolve(from, path.relative(from, to)) == path.resolve(to)<br/>
relative.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.relative(&#39;C:\orandea\test\aaa&#39;, &#39;C:\orandea\impl\bbb&#39;);<br/>
// returns &#39;..\..\impl\bbb&#39;</p>

<p>path.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;);<br/>
// returns &#39;../../impl/bbb&#39;<br/>
path.dirname(p)<br/>
该方法返回一个路径的目录名，类似于Unix中的dirname命令。<br/>
dirname.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.dirname(&#39;/foo/bar/baz/asdf/quux&#39;)<br/>
// returns &#39;/foo/bar/baz/asdf&#39;<br/>
path.basename(p, [ext])<br/>
该方法返回一个路径中最低一级目录名，类似于Unix中的 basename命令。<br/>
basename.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;);<br/>
// returns &#39;quux.html&#39;</p>

<p>path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;, &#39;.html&#39;);<br/>
// returns &#39;quux&#39;<br/>
path.extname(p)<br/>
该方法返回路径中的文件扩展名，即路径最低一级的目录中&#39;.&#39;字符后的任何字符串。如果路径最低一级的目录中&#39;没有&#39;.&#39; 或者只有&#39;.&#39;，那么该方法返回一个空字符串。<br/>
extname.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.extname(&#39;index.html&#39;);<br/>
// returns &#39;.html&#39;</p>

<p>path.extname(&#39;index&#39;);<br/>
// returns &#39;&#39;<br/>
path.exists(p, [callback])<br/>
该方法用于测试参数p中的路径是否存在。然后以true或者false作为参数调用callback回调函数。<br/>
exists.js:<br/>
var path = require(&#39;path&#39;);<br/>
var util = require(&#39;util&#39;);<br/>
path.exists(&#39;/etc/passwd&#39;, function (exists) {<br/>
  util.debug(exists ? &quot;it&#39;s there&quot; : &quot;no passwd!&quot;);<br/>
});<br/>
path.existsSync(p)<br/>
path.exists的同步方法。</p>

<h4 id="toc_14">4.3.5 File System</h4>

<p>文件的I/O是由标准POSIX函数封装而成。需要使用require(&#39;fs&#39;)访问这个模块。所有的方法都提供了异步和同步两种方式。异步形式下，方法的最后一个参数需要传入一个执行完成时的回调函数。传给回调函数的参数取决于具体的异步方法，但第一个参数总是保留给异常对象。如果操作成功，那么该异常对象就变为null或者undefined。<br/>
这里是一个异步调用的例子：<br/>
var fs = require(&#39;fs&#39;);<br/>
fs.unlink(&#39;/tmp/hello&#39;, function (err) {<br/>
  if (err) throw err;<br/>
  console.log(&#39;successfully deleted /tmp/hello&#39;);<br/>
});<br/>
这里是进行相同操作的同步调用的例子：<br/>
var fs = require(&#39;fs&#39;);<br/>
fs.unlinkSync(&#39;/tmp/hello&#39;)<br/>
console.log(&#39;successfully deleted /tmp/hello&#39;);<br/>
由于异步方法调用无法保证执行的顺序，所以下面的代码容易导致出现错误。<br/>
fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, function (err) {<br/>
  if (err) throw err;<br/>
  console.log(&#39;renamed complete&#39;);<br/>
});<br/>
fs.stat(&#39;/tmp/world&#39;, function (err, stats) {<br/>
  if (err) throw err;<br/>
  console.log(&#39;stats: &#39; + JSON.stringify(stats));<br/>
});<br/>
这样做有可能导致fs.stat在fs.rename之前执行，正确的做法是链式调用回调函数。<br/>
fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, function (err) {<br/>
  if (err) throw err;<br/>
  fs.stat(&#39;/tmp/world&#39;, function (err, stats) {<br/>
    if (err) throw err;<br/>
    console.log(&#39;stats: &#39; + JSON.stringify(stats));<br/>
  });<br/>
});<br/>
当需要频繁操作时，强烈建议使用异步方法。同步方式在其完成之前将会阻塞当前的整个进程，即搁置所有连接。</p>

<p>Node会跳到上层目录完成同样的动作，知道模块被找到，或者到达根目录为止。例如，如果在文件&#39;/home/ry/projects/foo.js&#39;中调用require(&#39;bar.js&#39;)，Node会在下列位置查找，顺序如下：<br/>
/home/ry/projects/node_modules/bar.js<br/>
/home/ry/node_modules/bar.js<br/>
/home/node_modules/bar.js<br/>
/node_modules/bar.js<br/>
Node允许用户在独立的文件夹中方便的组织程序，为这个文件夹指定一个单一的入口后可以把这个文件夹当作模块被加载。</p>

<h4 id="toc_15">4.3.6 Crypto</h4>

<p>有三种方式可以将文件夹作为require函数的参数。第一种方式是在该文件夹中创建package.json文件，指定一个main模块，一个简单的package.json文件会是这样：<br/>
{ &quot;name&quot; : &quot;some-library&quot;,<br/>
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }<br/>
如果此文件位于./some-library文件夹，加载这个文件夹可以调用require(&#39;./some-library&#39;)，这时会尝试加载./some-library/lib/some-library.js。如果Node在该文件夹下没有找到package.json这个文件，那么Node将依次尝试加载改文件夹下的index.js或index.node文件。例如，如果上面的例子找不到package.json，那么会依次尝试加载：<br/>
./some-library/index.js<br/>
./some-library/index.node</p>

<h4 id="toc_16">4.3.7 ZLIB</h4>

<p>Node模块在首次加载成功后会被缓存起来，这意味着同一模块每次调用require方法得到的是完全相同的对象。</p>

<p>整理后记：这四篇文章以前是想整理一本node书籍的，但是由于琐事没坚持下来。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-10-small-test-node-module.html">小试Node Node模块</a></h1>
			<p class="meta"><time datetime="2012-10-10T18:28:07+08:00" 
			pubdate data-updated="true">2012/10/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>模块是Node的基本单位，让我们从模块开始深入了解Node。</p>

<h3 id="toc_0">3.1　CommonJS规范</h3>

<p>JavaScript是一门强大的面向对象的语言，但是JavaScript的标准定义是为了构建基于浏览器的应用程序，它没有一个用于更广泛的应用程序的标准库。CommonJS（官方主页 <a href="http://www.commonjs.org">http://www.commonjs.org</a> ）定义了很多用于普通应用程序（主要指非浏览器应用）使用的API，从而弥补了这个空白。</p>

<p>CommonJS是一种规范，内容包括模块、二进制、编码、文件、系统、断言、套接字、事件队列等。Node是CommonJS的一种实现，但是只实现了它的部分规范。CommonJS有很多实现，如SeaJS、CouchDB和RequireJS等。这些项目大部分也只实现了CommonJS的部分规范（可以在这里查看某个项目的实现部分 <a href="http://www.commonjs.org/impl/">http://www.commonjs.org/impl/</a> ）。</p>

<p>先简要说明一下CommonJS规范对模块的定义。每个模块都有对应的标识符，而标识符有两种：相对标识符与绝对标识符。模块的上下文中有require、exports两个变量。模块的加载是通过模块中的require函数完成，参数是模块的标识符，返回值是被加载模块向外exports导出的属性或方法。</p>

<h3 id="toc_1">3.2　第一个 Node模块</h3>

<p>Node有一个简明的模块加载系统。一个文件就可以被作为一个模块使用，比如，在foo.js文件中加载同一目录下的circle.js模块。</p>

<p>circle.js：</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre>

<p>foo.js：</p>

<pre><code>var circle = require(&#39;./circle.js&#39;);
console.log( &#39;The area of a circle of radius 4 is &#39;+ circle.area(4));
</code></pre>

<p>Node模块的定义和使用都非常的简单，只需调用require方法加载模块即可。在foo.js文件中调用require方法完成对circle.js的加载，这样就可以在foo.js文件中使用circle.js文件中定义并exports导出的函数了。这里require的参数是一个相对路径定义的模块标识符。使用相对路径定义的模块的标识符以“./”或者“../”开头，前者表示当前文件夹，后者表示上级文件夹。使用绝对路径定义的模块的标识符以“/”开头，这种方法定义的标识符和文件系统的根目录相关。</p>

<h3 id="toc_2">3.3　模块的分类和加载</h3>

<p>Node模块可以分成两类，一类为核心模块，一类为文件模块。<br/>
核心模块在Node源代码编译的时候已经被编译成了二进制可执行文件。核心模块的源代码在Node源代码的lib文件夹中可以找到。调用require函数加载模块时，核心模块总是优先被加载。核心模块的模块标识符就是模块名，前面米有路径。例如，require(&#39;http&#39;)总是返回核心模块HTTP模块。核心模块的说明文档可以在官网上面很容易被找到。</p>

<p>文件模块是动态加载的，加载速度较核心模块较慢。文件模块包含三种文件，扩展名分别为.js、.json和.node。文件模块的模块标识符是使用相对路径或者绝对路径定义的模块标识符。如果模块标识符不包含文件的扩展名，显然这样Node无法找到确切的文件，Node将依次将.js、.json、.node三种扩展名添加上再进行加载。例如执行require(&#39;./circle&#39;)时首先查找当前目录circle文件，然后再尝试circle.js文件，加载成功即返回。.js文件被视为JavaScript文本文件，通过核心模块fs模块被读取后编译并执行；.json文件被视为JSON文本文件，读取后会调用JSON.parse被解析加载；.node被视为已编译的C/C++插件模块，通过dlopen方法进行加载。</p>

<p>如果传递给require函数的模块标识符不以“/”、“./”或“../”开头，也不是核心模块名，这时Node会从当前模块所在的目录下的node_modules这个文件夹下查找文件尝试加载。如果还是没有找到，那么Node会跳到上层目录完成同样的动作，知道模块被找到，或者到达根目录为止。例如，如果在文件&#39;/home/ry/projects/foo.js&#39;中调用require(&#39;bar.js&#39;)，Node会在下列位置查找，顺序如下：</p>

<pre><code>/home/ry/projects/node_modules/bar.js
/home/ry/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
</code></pre>

<p>Node允许用户在独立的文件夹中方便的组织程序，为这个文件夹指定一个单一的入口后可以把这个文件夹当作模块被加载。有三种方式可以将文件夹作为require函数的参数。第一种方式是在该文件夹中创建package.json文件，指定一个main模块，一个简单的package.json文件会是这样：</p>

<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }
</code></pre>

<p>如果此文件位于./some-library文件夹，加载这个文件夹可以调用require(&#39;./some-library&#39;)，这时会尝试加载./some-library/lib/some-library.js。如果Node在该文件夹下没有找到package.json这个文件，那么Node将依次尝试加载改文件夹下的index.js或index.node文件。例如，如果上面的例子找不到package.json，那么会依次尝试加载：</p>

<pre><code>./some-library/index.js
./some-library/index.node
</code></pre>

<p>除了上述的查找目录，Node还会去全局的模块目录查找。如果在系统的环境变量中添加了NODE_PATH，Node会去NODE_PATH 设置的目录中去查找。NODE_PATH 配置的目录为绝对路径，允许多个，用冒号:隔开（Windows下使用分号;）。如果模块还没有找到，Node还会从下面的目录查找：</p>

<pre><code>$HOME/.node_modules
$HOME/.node_libraries
$PREFIX/lib/node
</code></pre>

<p>\(HOME是用户主目录，\)PREFIX是Node安装目录的前缀。</p>

<p>Node模块在首次加载成功后会被缓存起来，这意味着同一模块每次调用require方法得到的是完全相同的对象。</p>

<h3 id="toc_3">3.4　NPM Node包管理器</h3>

<p>NPM（Node  Package Manager），是一个Node包管理工具。NPM可以帮助你很方便的进行包的下载、安装和管理。NPM的实现大部分也遵循CommonJS规范中对包的定义（ <a href="http://wiki.commonjs.org/wiki/Packages/1.0">http://wiki.commonjs.org/wiki/Packages/1.0</a> ）。</p>

<p>一个NPM包有如下结构：<br/>
* package.json文件位于包顶级目录下，记录包的相关信息；<br/>
* bin目录下存放C/C++扩展编译后的二进制文件；<br/>
* lib目录下存放JavaScript代码文件。<br/>
* doc目录下存放文档；<br/>
* test目录下存放测试代码。</p>

<p>一个基本的package.json文件是这样的：</p>

<pre><code>{
  &quot;name&quot;: &quot;chapter3&quot;, 
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;main&quot;: &quot;./index.js&quot;, 
  &quot;dependencies&quot;: {
    &quot;pinyin&quot;: &quot;0.0.1&quot;
  }
}
</code></pre>

<p>name是包名，在NPM库中是唯一的；version是用于标识包的版本，通常为x.y.z；dependencies用于声明需要的依赖。其他字段的说明可以在CommonJS规范中对包的定义的文档中查看。</p>

<h3 id="toc_4">3.5　NPM常用命令介绍</h3>

<p>NPM通过使用npm命令来完成对包的管理操作，这些命令涉及到一个Node包整个生命周期的每一个操作，包括发布、下载、使用或者移除等。</p>

<p>npm install packageName<br/>
安装一个指定包名的Node包到当前文件夹。<br/>
npm install -g packageName<br/>
安装一个指定包名的Node包到Node的安装目录。<br/>
npm install<br/>
如果命令中不指定包名，则在当前文件中中寻找package.json文件读取dependencies的值进行安装。<br/>
npm uninstall packageName<br/>
卸载一个指定包名的Node包。<br/>
npm update packageName<br/>
更新一个指定包名的Node包。<br/>
npm adduser<br/>
在NPM仓库上注册一个账号，需要填写用户名、密码和电子邮件地址。<br/>
npm init<br/>
初始化一个Node包，根据输入的内容创建一个package.json文件。<br/>
npm publish<br/>
发布一个Node包。<br/>
npm unpublish<br/>
移除一个Node包。<br/>
npm search packageName<br/>
查找一个指定包名的Node包。<br/>
npm help <command><br/>
获取npm的帮助信息。</p>

<p>以上仅仅只介绍了一些相对比较常用的命令，其他命令及详细使用说明可以使用help命令查看，或者在NPM的官方网站（ <a href="http://npmjs.org/">http://npmjs.org/</a> ）查看。NPM除了提供search命令用来查找Node包，NPM也提供了网页的形式（ <a href="http://search.npmjs.org/">http://search.npmjs.org/</a> ）供访问。现在通过NPM发布的Node包的数量已经达到一万多。如果你开发了一个Node包，非常期待你发布到NPM上去，为Node平台添砖加瓦。</p>

<h3 id="toc_5">3.6　依赖的问题</h3>

<h4 id="toc_6">3.6.1  循环依赖</h4>

<p>循环依赖，是指两个文件互引用对方。例如a.js文件中require b.js文件，而b.js文件中又require a.js文件，这样造成一个死循环。让我们来看一下的代码：<br/>
 a.js：</p>

<pre><code>console.log(&#39;a starting&#39;);
exports.done = false;
var b = require(&#39;./b.js&#39;);
console.log(&#39;in a, b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a done&#39;);
</code></pre>

<p>b.js：</p>

<pre><code>console.log(&#39;b starting&#39;);
exports.done = false;
var a = require(&#39;./a.js&#39;);
console.log(&#39;in b, a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b done&#39;);
</code></pre>

<p>main.js：</p>

<pre><code>console.log(&#39;main starting&#39;);
var a = require(&#39;./a.js&#39;);
var b = require(&#39;./b.js&#39;);
console.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done);

</code></pre>

<p>当main.js加载a.js时，a.js也会加载b.js。在这个时候b.js也会反过来加载a.js。为了防止这样一个死循环，a.js返回了一个未完成的exports对象给b.js。当b.js加载完成，它会将它的exports对象返回给a.js，然后a.js会继续完成加载。运行main.js输出如下：</p>

<pre><code>main starting 
a starting 
b starting 
in b, a.done = false 
b done 
in a, b.done = true 
a done 
in main, a.done=true, b.done=true 
</code></pre>

<h4 id="toc_7">3.6.1  传递依赖</h4>

<p>传递依赖，是指重复的间接依赖。Node对模块有缓存机制，Node是靠模块的路径来判断是否已经被加载的，当这个模块的路径变了，就会被重新加载。当然在我们自己的应用中不会把一个文件拷贝成双份放到两个不同的目录然后去使用，这种重复加载的情况完全可以避免。但是当Node包出现传递依赖的时候，就会出现模块被重复加载。例如，一个项目同时依赖mine包和express包，express也依赖mine包，使用NPM安装包后文件目录结构如下：</p>

<pre><code>./node_modules
├── mime
└── express
    └── node_modules
        └── mime
</code></pre>

<p>从目录上可以看到mime包出现了两次，可以说有两个完全相同的包，这个包中的模块会被重复加载两次，产生了两个模块的实例。</p>

<p>如果你对Maven很熟悉，你会知道Maven在处理传递依赖的版本确定规则为：深度越浅，越被优先选择；若两个依赖包处于依赖树的同一层则优先选择排列在前面的。Node中的包是以文件夹的形式存在的，所以不会存在同一层中存在相同的包。当两个依赖包处于不同层时，Maven不管两个包的版本只会选择深度较浅的那个依赖包，也就是说只会选择一个版本。Node则不然，Node会产生两个不同的实例，会多版本共存。如果你想避免这种重复加载，你可以手动删除深度较深的包，只保留在公共路径上的包。</p>

<p>当嵌套依赖关系的层次很深时，文件的查找列表可能会变的很长。因此Node在查找时进行如下优化：/node_modules不会附加到一个以/node_modules结尾的文件夹后面。例如，如果在文件&#39;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&#39;中调用require函数时，会搜索如下目录：</p>

<pre><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/
/home/ry/projects/foo/node_modules/bar/node_modules/node_modules/
/home/ry/projects/foo/node_modules/bar/node_modules/
/home/ry/projects/foo/node_modules/node_modules/
/home/ry/projects/foo/node_modules/
/home/ry/projects/node_modules/
/home/ry/node_modules/
/home/node_modules/
/node_modules/
</code></pre>

<h3 id="toc_8">3.7　小结</h3>

<p>我们在这一章学习了Node的模块和包，具体内容如下：<br/>
* CommonJS是一种规范，Node是CommonJS的一种实现； <br/>
* Node模块可以分成两类，一类为核心模块，一类为文件模块；<br/>
* NPM，是一个Node包管理工具，过使用npm命令来完成对包的管理操作；<br/>
* Node模块存在循环依赖和传递依赖这两种问题，在使用中需要注意。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-09-small-test-hello-node.html">小试Node Hello Node</a></h1>
			<p class="meta"><time datetime="2012-10-09T18:26:57+08:00" 
			pubdate data-updated="true">2012/10/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Node还很年轻，正处于快速发展中，版本更新速度也很快。下面内容介绍的是最新的0.6.x（笔者使用的是0.6.18版本，如果版本号不同，只需替换版本号即可）的版本安装和配置。如果你想使用旧版本（比如0.4.x），安装和配置会不尽相同，请借助搜索引擎搜索安装和配置方法。</p>

<h3 id="toc_0">2.1　安装Node</h3>

<h4 id="toc_1">2.1.1  Windows平台下安装</h4>

<p>在Node官方网站上面下载安装文件（ <a href="http://nodejs.org/dist/v0.6.18/node-v0.6.18.msi">http://nodejs.org/dist/v0.6.18/node-v0.6.18.msi</a> ），双击即可在程序的引导下完成安装。完成以上操作后，检查一下是否安装成功：</p>

<p><code>node -v</code></p>

<p>检查是否返回：</p>

<p><code>v0.6.18</code></p>

<p>至此，Node已经安装完成。如需卸载，可以在控制面板\程序\程序和功能中找到Node进行卸载。</p>

<h4 id="toc_2">2.1.1  Unix/Linux平台下安装</h4>

<pre><code>wget http://nodejs.org/dist/v0.6.18/node-v0.6.18.tar.gz 
tar zxvf node-v0.6.1.tar.gz 
cd node-v0.6.1 
./configure 
</code></pre>

<p>上面几行命令是通过wget命令下载最新版本的代码，并解压之。./configure命令将会检查环境是否符合Node的编译要求。如果检查没有通过，请安装提示需要的库。如果configure命令执行成功，就可以进行编译了：</p>

<pre><code>make 
make install 
</code></pre>

<p>Node通过make工具进行编译和安装（如果make install不成功，请使用sudo以确保拥有权限）。完成以上操作后，检查一下是否安装成功：</p>

<p><code>node -v</code></p>

<p>检查是否返回：</p>

<p><code>v0.6.18</code></p>

<p>至此，Node已经编译并安装完成。如需卸载，可以执行make uninstall进行卸载。</p>

<h3 id="toc_3">2.2　安装NPM</h3>

<p>NPM(Node Package Manager)是Node的模块管理器。最新版本的Node已经内置了NPM，无需另行安装。可以在安装Node完成后，检查NPM是否已经安装成功：</p>

<p><code>npm -v</code></p>

<p>检查是否返回：</p>

<p><code>1.1.21</code></p>

<p>至此，Node和NPM都已经安装完成。</p>

<h3 id="toc_4">2.3　Hello World!</h3>

<p>我们从最简单的Hello World开始我们的Node之旅。新建一个文件helloworld.js，并编写代码。</p>

<p><code>console.log(&#39;Hello World!&#39;);</code></p>

<p>现在我们要运行这个代码文件。这个操作非常简单，直接输入以下命令即可运行：</p>

<pre><code>node helloworld.js 
Hello World! 
</code></pre>

<p>用node命令加上文件名即可运行代码文件，在运行成功后打印输出了HelloWorld!，打印完成后程序自动停止退出。<br/>
下面我们来启动一个HTTP服务器，当在浏览器访问时，会向浏览器输出HelloWorld!。新建一个文件http.js，并编写代码。</p>

<pre><code>var http = require(&#39;http&#39;);
http.createServer(function (req, res) {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;Hello World!\n&#39;);
}).listen(1337, &#39;127.0.0.1&#39;);
console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);
</code></pre>

<p>使用node命令运行这个文件：</p>

<pre><code>node http.js 
Server running at http://127.0.0.1:1337/ 
</code></pre>

<p>这样就启动了一个用Node编写的最简单的HTTP服务器。你会发现这次运行的代码在运行到最后一行后不会自动停止退出，去系统进程列表可以找到一个node的进程一直在运行。这是因为listen函数创建了一个监听1337端口的监听器。这个事件监听器会使http.js一直保持执行状态，知道你在终端窗口中执行退出操作，如Ctrl+C。你可以在任意浏览器中访问<a href="http://127.0.0.1:1337/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9A">http://127.0.0.1:1337/就可以看到如图所示的结果：</a></p>

<p><img src="/resource/image/2012-10-09-small-test-hello-node/helloworld.png" alt="浏览器结果"/></p>

<h3 id="toc_5">2.4　小结</h3>

<p>我们在这一章学习了Node和NPM的安装，并编写和运行了两个简单的Node程序。<br/>
本章具体内容包括：<br/>
* Node和NPM的安装，并验证是否安装成功； <br/>
* 如何运行和停止代码；<br/>
* 用Node编写的一个最简单的HTTP服务器。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-08-small-test-node-introduction.html">小试Node 简介</a></h1>
			<p class="meta"><time datetime="2012-10-08T18:25:34+08:00" 
			pubdate data-updated="true">2012/10/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Node（或者Node.js），是一个构建于Google Chrome JavaScript运行环境（runtime）之上的一个平台，为了提供一种简单的构建快速、可伸缩的网络程序的方法。Node采用事件驱动、非阻塞/异步IO模型，使得它轻量高效，可完美地构建运行于分布式环境的数据密集型即时应用程序。</p>

<h3 id="toc_0">1.1　Node不是什么</h3>

<p>Node不是JavaScript，也不是JavaScript应用。Node是一个平台，是一个JavaScript运行环境。Node可以让JavaScript摆脱浏览器的束缚，在浏览器之外运行JavaScript，但是Node绝对不仅仅是JavaScript。Node之所以采用了Google Chrome浏览器的V8引擎来解释和执行JavaScript代码，除了V8引擎性能优异，还因为V8引擎可以独立运行，并支持将其嵌入任何C++应用程序进行扩展。Node除了提供可以运行JavaScript的运行环境，还用编写了很多系统级的API，比如网络，文件等。这样Node就可以用来开发系统级或者服务器端的应用程序。</p>

<h3 id="toc_1">1.2　Node的特点</h3>

<h4 id="toc_2">1.2.1　事件驱动、非阻塞/异步IO</h4>

<p>Node以单进程、单线程的模式运行，它通过事件轮询来完成并行操作。Node内部采用了一些非阻塞“库”来支持实现事件轮询，目的就是可以为耗费资源的操作提供回调操作。当你像文件系统发送一个请求时，无需等待硬盘完成复杂的寻址和检索文件操作，硬盘在完成这些耗时操作时会触发完成事件通知Node，继续调用执行回调函数完成后序操作。Node代码在运行时会一直执行，不会阻塞的等待某个结果返回（如请求访问一个文件），阻塞的部分会靠事件监听来完成，这样就构成了事件驱动模型。</p>

<h4 id="toc_3">1.2.2　性能优异</h4>

<p>创始人Ryan Dahl在早期分享过一个测试程序（<a href="http://nodejs.org/cinco_de_node.pdf">http://nodejs.org/cinco_de_node.pdf</a> ），该程序返回一个1M的缓冲Buffer，Node每秒处理822个请求，而Nginx每秒处理708个。Node有很强大的吞吐能力，每秒可以响应更多的请求数。你完全不必为Node的性能担忧和顾虑，放心地使用它。</p>

<p>你也许会担心在不同平台下面的性能差异。Node在0.6.x版本后可以直接在Windows平台上运行，不需要借助Cygwin的支持。Node在Windows平台上的性能和Unix/Linux平台已经相差无几，而且在某些方面性能要更优。Ryan Dahl分享了具体测试数据：</p>

<p>| Linux v 0.4.12 | Linux v 0.6.0<br/>
http_simple.js /bytes/1024 | 5461 r/s | 6263 r/s<br/>
io.js 读 | 19.75 MB/s | 26.63 MB/s<br/>
io.js 写 | 21.60 MB/s | 17.40 MB/s<br/>
startup.js | 74.7 ms | 49.6 ms</p>

<p>| Windows v 0.4.12 | Windows v 0.6.0<br/>
http_simple.js /bytes/1024 | 3858 r/s | 5823 r/s<br/>
io.js 读 | 12.41 MB/s | 26.51 MB/s<br/>
io.js 写 | 12.61 MB/s | 33.58 MB/s<br/>
startup.js | 152.81 ms | 52.04 ms</p>

<h4 id="toc_4">1.2.3　JavaScript &amp; V8</h4>

<p>Node支持的语言是JavaScript。JavaScript对Web开发人员来说一定很熟悉，它是一门动态弱类型语言，能按需非正式声明和可动态扩展对象。匿名函数、闭包等特性也非常适合事件驱动、异步编程。你如果已经对JavaScript熟悉，那么你无需学习新的语言，你可以很快上手Node。</p>

<p>一个完整的JavaScript实现应该包括三个部分：ECMAScript(核心)、BOM(浏览器模型)和DOM(文档对象模型)。Node没有BOM和DOM，只有ECMAScript。</p>

<p>Node受益于V8引擎的JIT(Just In Time)编译功能，Node的运行速度可以和本地代码媲美。随着V8引擎的发展与进步，Node也会同时从中收益。V8实现了ECMA-262第五版(<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a> )。不同的浏览器使用了不同的JavaScript引擎，例如Chakra(IE9)、SpiderMonkey(Firefox)、JavaScriptCore(Safari)。不同的引擎对ECMA-262的实现会略有不同，需要加以注意。</p>

<h3 id="toc_5">1.3　Node不是银弹</h3>

<p>Node的出现，引发了很激烈的讨论，有人支持有人反对。很多人在公开发表自己的看法，《如果你正在使用Node，你就是误入歧途》就是其中很有名的一篇文章（英文原文地址：<a href="http://codeslinger.posterous.com/if-youre-using-nodejs-youre-doing-life-wrong">http://codeslinger.posterous.com/if-youre-using-nodejs-youre-doing-life-wrong</a> ）。当然，也会有人针对回应，一位自由软件开发者Craig回应《Node不是银弹，而仍然是一颗子弹》（英文原文地址：<a href="http://crgwbr.com/details/41/nodejs-isnt-a-silver-bullet-but-still-a-bullet/">http://crgwbr.com/details/41/nodejs-isnt-a-silver-bullet-but-still-a-bullet/</a> ）。在这里并不想讨论孰对孰错的问题，因为根本无法定论。Bjarne Stroustrup曾经说过的一句话：“世界上只有两种语言：整天被人喷的语言，没有人用的语言。”或许这句话可以解释一切。</p>

<h3 id="toc_6">1.4　谁在使用Node</h3>

<p>虽然Node诞生刚刚两年多，还很年轻，但是发展速度迅猛。有很多企业在生产环境中使用了Node，那么我们来看看几个企业应用中的案例。<br/>
在社交网站LinkedIn最新发布的移动应用中，HTML5技术抢占前端开发，而Node则是该移动应用的后台基础。LinkedIn移动开发主管Kiran Prasad对媒体表示，其整个移动软件平台都由Node构建而成。选择Node的原因，第一是因为其灵活性；第二是Node擅长与其他服务通信。</p>

<p>知名项目托管网站GitHub也尝试了Node应用，其开发人员在博客中介绍了使用Node的情况。该Node应用称为NodeLoad，是一个存档下载服务器（每当你下载某个存储分支的tarball或者zip文件时就会用到它）。GitHub之前的存档下载服务器采用Ruby编写。在旧系统中，下载存档的请求会创建一个Resque任务。该任务实际上在存档服务器上运行一个git archive命令，从某个文件服务器中取出数据。然后，初始的请求分配给你一个小型Ruby Sinatra应用等待该任务。它其实只是在检查memcache flag是否存在，然后再重定向到最终的下载地址上。旧系统运行大约3个Sinatra实例和3个Resque worker。GitHub的开发人员觉得这是Node应用的好机会。Node基于事件驱动，相比Ruby的阻塞模型，Node能够更好地处理git存档。在编写新下载服务器过程中，开发人员觉得Node非常适合该功能，此外，他们还利用了Node库socket.io来监控下载状态。</p>

<p>国内知名电子商务平台淘宝网在产品中也实际应用了Node。MyFOX是一个数据处理中间件，负责从一个MySQL集群中提取数据，计算，并输出统计结果。用户提交一段SQL语句，MyFOX根据该SQL命令的语义，生成各个数据库分片所需要执行的查询语句，并发送至各个分片，再将结果进行汇总和计算。 MyFOX的特点是CPU密集，无文件IO，并只处理只读数据。起初MyFOX使用PHP编写，但遇到许多问题。例如PHP是单线程的，MySQL又需要阻塞查询，因此很难并发请求数据，后来的解决方案是使用Nginx和Dirzzle，并基于HTTP协议实现接口，并通过curl_multi_get命令进行请求。不过MyFOX项目组最终还是决定使用Node来实现MyFOX。</p>

<h3 id="toc_7">1.5　小结</h3>

<p>本章简要介绍了Node，具体包括：</p>

<ul>
<li>Node不仅仅是JavaScript； </li>
<li>Node采用事件驱动、非阻塞/异步IO模型；</li>
<li>Node性能优异，可跨平台，平台间的性能相差无几；</li>
<li>Node支持的语言是JavaScript，但是没有DOM和BOM；</li>
<li>Node已经不少在企业生产环境中的成功案例；</li>
</ul>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_8.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_6.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-wechat-small-app.html">张小龙首次公开解读小程序：1月9号上线</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-27-benefits-and-pitfalls-of-micro-service.html">微服务的好处和陷阱</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-02-douban-rexxar.html">Rexxar：豆瓣对混合开发的思考</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-10-31-close-wait-problem.html">CLOSE_WAIT 问题分析</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>