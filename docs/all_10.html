
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-09-03-transaction_isolation.html">GAE 事务隔离</a></h1>
			<p class="meta"><time datetime="2011-09-03T14:47:08+08:00" 
			pubdate data-updated="true">2011/9/3</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h4 id="toc_0">一致性</h4>

<p>GAE 上的事务隔离是快照隔离。在事务开启后，可以把事务中操作的实体组看作是该实体组在数据存储中的一个带有版本的快照。</p>

<p>事务中的所有操作都将只针该快照进行，并且事务中的查询操作只能获取到事务开启时快照中的实体。这一点<a href="/2010-11-15-gae-transaction.html">前面已经提到过</a> ;-)</p>

<p>快照隔离的最终目的就是乐观并发控制，保证一致性。</p>

<h4 id="toc_1">可用性</h4>

<p>GAE 一直在限制事务内只能操作同一个实体组是有原因的。同一实体组将被存储在同一 Google 分布式存储单元中，如果事务中</p>

<p>同时操作多个实体组，失败的可能性会增加很多。所以为了保证可用性，才做出了这个限制。</p>

<p>不过这个限制即将为可选的，SDK 1.5.3 里面已经加入了<a href="http://code.google.com/appengine/docs/java/javadoc/com/google/appengine/api/datastore/TransactionOptions.html">事务配置</a>，可以让事务操作多个实体组。不过目前经测试，1.5.3 里面还不可用。</p>

<p>参考</p>

<ul>
<li><a href="http://code.google.com/appengine/docs/java/datastore/transactions.html">Google App Engine Transactions</a></li>
<li><a href="http://code.google.com/appengine/articles/transaction_isolation.html">Transaction Isolation in App Engine</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-08-27-gae-will-support-servlet3.html">GAE Java 将支持 Servlet 3</a></h1>
			<p class="meta"><time datetime="2011-08-27T14:36:06+08:00" 
			pubdate data-updated="true">2011/8/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="http://jcp.org/en/jsr/detail?id=315">Servlet 3.0 规范</a>发布快两年了，不过目前大多数 Servlet 容器以及应用还是基于 Servlet 2.5。</p>

<p>GAE 开发团队已经接受了 Servlet 3.0 特性支持，大家可以标星这个 <a href="http://code.google.com/p/googleappengine/issues/detail?id=3091">issue</a> 进行进展关注。</p>

<p>就像该 issue 中一兄台<a href="http://code.google.com/p/googleappengine/issues/detail?id=3091#c17">说的</a>，“即使不能实现所有 Servlet 3.0 特性，但实现部分也可以摆脱对一些 MVC 框架的严重依赖。”</p>

<p>比较期待 GAE 支持 Servlet annotations 以及 pluggability。特别是插件支持，能让应用更容易扩展。</p>

<p>P.S. 这里已经提案了 Servlet 3.1 ：<a href="http://jcp.org/en/jsr/summary?id=340">JSR 340</a></p>

<p>广告：</p>

<p>GAE/J 框架 <a href="http://latke.googlecode.com/">Latke</a> 已经实现了应用层次的<a href="https://docs.google.com/document/pub?id=15H7Q3EBo-44v61Xp_epiYY7vK_gPJLkQaT7T1gkE64w">插件支持</a>，大家可以试试哦 ;-)</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-08-06-storage-options-on-google-appengine.html">GAE 数据保存方式</a></h1>
			<p class="meta"><time datetime="2011-08-06T14:27:33+08:00" 
			pubdate data-updated="true">2011/8/6</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>GAE 为应用提供了多种保存数据的方式，例如大家熟知的 Datastore，不过也有一些方式大家不太熟悉。本文将尽量全地列出所有 GAE 上保存数据的方式，并分别描述其优势与劣势，以便开发者更明晰地进行选择。</p>

<h3 id="toc_0">Datastore</h3>

<p>大家最熟悉、使用最广泛的保存数据的方式自然是 Datastore 了。Datastore 是 GAE 的非关系型数据库，它提供了健壮、持久的存贮，也提供了最具灵活性性的数据存取操作。</p>

<h4 id="toc_1">优势</h4>

<p>持久 - 保存在 datastore 里的数据是持久的。<br/>
读写 - 应用能够读写保存在 datastore 里的数据，并且 datastore 提供了事务机制以保证完整性。<br/>
全局一致 - 所有应用实例拥有同一个 datastore 视图。<br/>
灵活 - 通过查询（Query）与索引提供了多种获取数据的方式。</p>

<h4 id="toc_2">劣势</h4>

<p>延迟 - datastore 是把数据保存在磁盘上，并提供了可靠保证，写操作必须确保数据已经被保存才返回（译注：异步 API 呢？），读操作不得不经常从磁盘取回数据（译注：底层如何进行缓存的呢？）</p>

<h3 id="toc_3">Memcache</h3>

<p>Memcache 是大家最熟悉的“二级”存储机制，它缓存数据以避免重复进行代价高（译注：例如 CPU、API 耗时特别高的调用）的操作。Memcache 常作为其他 APIs 的缓存层，例如 datastore，缓存某种数据源生成的结果集。</p>

<h4 id="toc_4">优势</h4>

<p>快 - 毫秒级别的存取操作（译注：1-4 毫秒，还是比较慢的-_-b）。<br/>
全局一致 - 所有应用实例拥有同一个 memcache 视图。Memcache 提供了操作数据的原子操作，保证完整性（译注：对象序列化）。</p>

<h4 id="toc_5">劣势</h4>

<p>不可靠 - 数据可能随时被丢弃（译注：GAE 默认会尽可能长时间地持有缓存项）。</p>

<h3 id="toc_6">Blobstore</h3>

<p>Blobstore 提供了便捷高效保存用户上传的大数据的方法。</p>

<h4 id="toc_7">优势</h4>

<p>支持大文件 - 2GB（译注：没有在现在的官方文档里找到根据。另外，30 秒的请求限制能传 2G？-_-b）。<br/>
不用自己处理 blob。<br/>
提供了高性能的 blobs 存取，特别是对图片。<br/>
应用能够向读取本地文件一样读取 blob。</p>

<h4 id="toc_8">劣势</h4>

<p>只读 - 应用不能自行创建 blobs，也不能修改已上传的 blobs。<br/>
需要要付费才能使用 blobstore。</p>

<h3 id="toc_9">实例内存</h3>

<p>应用实例也能通过类成员（译注：Java 里是类字段）或 globals（译注：貌似是 Python 里的概念）在本地（译注：该实例 JVM）内存中缓存数据。这个方式提供了最快的存取速度，但却有一些不利的方面。</p>

<h4 id="toc_10">优势</h4>

<p>快 - 能有多快有多快，因为数据保存在正在访问的同一个进程中。<br/>
方便 - 不需要 GAE APIs。<br/>
灵活 - 能够保存任何格式的数据，没有序列化/反序列化限制。</p>

<h4 id="toc_11">劣势</h4>

<p>不可靠 - 实例可能在任何时间被启动或关闭，所以应用只应该用这种方式来进行缓存数据（译注：应用实例的 JVM 内存不是跨实例的哦，所以这种方式缓存的数据可能会有一致性问题，见下点）。<br/>
不全局一致 - 每个应用实例都拥有自己的运行环境，自己的本地变量。对某一实例中的变量修改并不会影响其他实例。<br/>
容量限制 - 实例的内存使用是有大小限制的。</p>

<h3 id="toc_12">本地文件</h3>

<p>应用可以使用标准文件系统 APIs 来读取随应用一起上传的文件。</p>

<h4 id="toc_13">优势</h4>

<p>快 - 读取本地文件只需要访问应用实例运行的机器磁盘，延迟与 Memcache 接近。<br/>
可靠 - 只要应用在服务，就能够读取到文件。<br/>
灵活 - 能够使用任何格式的文件。</p>

<h4 id="toc_14">劣势</h4>

<p>只读 - 应用不能修改文件；这些文件的内容在部署的时候就已经确定了。<br/>
容量限制 - 单个文件最大 10MB，应用所有文件大小总和必须小于 150MB。</p>

<h3 id="toc_15">任务队列负荷（Payloads）</h3>

<p>虽然这不是传统意义上的存贮，但任务队列是能够保存持有一定的数据的。</p>

<h4 id="toc_16">优势</h4>

<p>快 - 任务运行时发送 payloads，获取这些数据不用调用额外的 API。<br/>
如果使用得到，可以不用保存任务数据（译注：？）。</p>

<h4 id="toc_17">劣势</h4>

<p>意图单一 - payloads 是提供给任务队列任务的数据存贮。<br/>
容量限制 - 任务最大大小 10KB（译注：现在 Push 队列是 100KB，Pull 队列是 1MB），包含了负荷数据。</p>

<h3 id="toc_18">结论</h3>

<p>GAE 提供了多种数据存储机制，我们得在应用场景下选择适当的存储方式。通常，较好的方案是组合使用这些数据保存方式，例如 datastore 与 memcache，本地文件与实例内存。</p>

<p>注：</p>

<ol>
<li>原文中的链接是 GAE/Python 版的，译文中的链接是 GAE/Java 版的</li>
<li>“优势”/“劣势”这两个词可能翻译不当....</li>
</ol>

<p>附上原文（<a href="http://blog.notdot.net/2010/11/Storage-options-on-App-Engine">Storage options on App Engine</a>）</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-07-28-java-7-technologies.html">Java 7 的新特性一览表</a></h1>
			<p class="meta"><time datetime="2011-07-28T17:28:19+08:00" 
			pubdate data-updated="true">2011/7/28</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>官方说是 7月28日 正式发布 Java 7 ，正常的话我们应该在 7月29日 看到这个版本。很快了，就两天时间。</p>

<p>发布之前让我们先来看看 Java 7 都有什么新特性吧。</p>

<p>Java 7 的技术：<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/desc_jdk_structure.html">Description of Java Conceptual Diagram</a></p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2011-07-28-java-7-technologies.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-07-26-java-final-keyword.html">再识 Java 的 final 关键字</a></h1>
			<p class="meta"><time datetime="2011-07-26T17:15:55+08:00" 
			pubdate data-updated="true">2011/7/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在 Java 中，我们一般用 final 关键字来定义类字段常量，防止类继承、方法覆写。但其实我们也应该尽可能地使用 final 关键字来修饰方法参数与局部变量。</p>

<p>因为这样做可以使代码更易读，能让阅读者清楚地知道该参数/变量是不会在被重赋值的，也可以让编译器更好地帮助我们优化生成的字节码。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2011-07-26-java-final-keyword.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-07-14-maven-plugin.html">Maven 插件访问项目类路径</a></h1>
			<p class="meta"><time datetime="2011-07-14T17:06:57+08:00" 
			pubdate data-updated="true">2011/7/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>写 Maven 插件的时候可能需要用到项目的类路径，例如插件反射项目的类再做后续处理。</p>

<p>在插件中如何获取项目类路径呢？官方插件（maven-compiler-plugin）为我们做出了示例，点击<a href="http://svn.apache.org/viewvc/maven/plugins/tags/maven-compiler-plugin-2.3.2/src/main/java/org/apache/maven/plugin/CompilerMojo.java?revision=992608&amp;view=markup">这里</a>查看其源码。</p>

<p>顺藤摸瓜，有两个点需要注意：</p>

<ul>
<li><p>@requiresDependencyResolution compile<br/>
意味着在此插件执行前会准备好项目 compile 作用域依赖 作为类路径，取值参见下表：</p>

<table>
<thead>
<tr>
<th>system</th>
<th>provided</th>
<th>compile</th>
<th>runtime</th>
<th>test</th>
</tr>
</thead>

<tbody>
<tr>
<td>compile</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>-</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>-</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>compile+runtime (since Maven 3.0)</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr>
<td>test</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody>
</table></li>
<li><p>@parameter default-value=&quot;${project.compileClasspathElements}<br/>
意味着示例类中的成员属性 classpathElements 将保存 @requiresDependencyResolution 指明的类路径</p></li>
</ul>

<p>具体细节请移步：</p>

<ul>
<li><a href="http://maven.apache.org/guides/mini/guide-maven-classloading.html">Guide to Maven Classloading</a></li>
<li><a href="http://maven.apache.org/developers/mojo-api-specification.html">Mojo API Specification</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-06-18-svn-branch-merge.html">SVN 分支更新与合并</a></h1>
			<p class="meta"><time datetime="2011-06-18T16:53:16+08:00" 
			pubdate data-updated="true">2011/6/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>正规的产品开发一般都使用主干(trunk)和分支(branch)。主干用来发布产品的正式版本。branch用来维护历史版本，修改软件缺陷及新功能的开发。使用分支可以有效的分隔这些不同目的活动，同时也为最终集成这些活动的成果提供技术基础。下面简单描述一下Subversion环境下的分支最主 要的操作。</p>

<h4 id="toc_0">创建分支</h4>

<p>svn cp -m &quot;TICKxxx: create xxx branch&quot; http://svn_server/xxx_repository/trunk http://svn_server/xxx_repository/branches/br_feature001  </p>

<h4 id="toc_1">合并主干上的最新代码到分支上</h4>

<p>该操作常常被称为刷新(refresh)，根据分支上开发的周期长短不同，这个过程通常需要反复执行。命令如下：</p>

<p>cd ws_br_feature001    </p>

<p>svn merge http://svn_server/xxx_repository/trunk  </p>

<p>如果需要预览该刷新操作，可以使用svn mergeinfo命令，如：</p>

<p>svn mergeinfo http://svn_server/xxx_repository/trunk --show-revs eligible</p>

<p>或使用svn merge --dry-run选项以获取更为详尽的信息。</p>

<h4 id="toc_2">合并到主干</h4>

<p>一旦分支上的开发结束，分支上的代码需要合并到主干。SVN中执行该操作需要在trunk的工作目录下进行。命令如下：</p>

<p>cd ws_trunk    </p>

<p>svn merge --reintegrate http://svn_server/xxx_repository/branches/br_feature001  </p>

<p>分支合并到主干中完成后应当删该分支，因为在SVN中该分支已经不能进行刷新也不能合并到主干。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-06-01-steps-problem.html">台阶问题</a></h1>
			<p class="meta"><time datetime="2011-06-01T16:49:09+08:00" 
			pubdate data-updated="true">2011/6/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>该程序给出了使用递归方式以及使用迭代方式两种算法实现。该两种实现都基于如下推导：</p>

<ul>
<li>当 m = n, n != 1 时，f(n) = 2(n-1)
即 f(n) 为 二项式 (a+b)n 展开式各项系数之和，推导如下：
设楼梯有 n 级，某人一步最多迈 m(m=n) 级，使用“隔板法”（共 n-1 个空位）可得 f(n) = ∑n=1nCnn-1 = 2n-1。</li>
<li>当 m &lt;=n 时，f(n) = 2<em>f(n-1) - f(n-m-1)
即 f(n) = f(n-1) + f(n-2) + ... + f(n-m) 代入 n 后的递推式，推导如下：
归纳可得 f(n) 为先上 1 步、2 步、...、m 步走法只和：f(n) = f(n-1) + f(n-2) + ... + f(n-m)。
逐步代入展开：f(n) = (f(n-2) + f(n-3) + ... + f(n-m-1))+ f(n-2) + ... + f(n-m)，即（展开 f(n-1)）... =&gt; f(n) = 2</em>f(n-1) - f(n-m-1)。</li>
</ul>

<p>f(n) 可根据 m 分三类情况求解：</p>

<ul>
<li>当 m = 1 时，有且仅有 1 种走法，f(n)=1</li>
<li>当 m &lt;= n 时，f(n) = 2*(f(n-1) - f(n-m-1)，特别地，</li>
<li>当 m = n 时，f(n) = 2n-1</li>
</ul>

<p>足见，程序员绝对需要一定的数学知识。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2011-06-01-steps-problem.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-05-20-go-web-two.html">Go Web 开发（二）</a></h1>
			<p class="meta"><time datetime="2011-05-20T16:45:37+08:00" 
			pubdate data-updated="true">2011/5/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">目的</h3>

<p>了解使用 Go 模板技术开发 Web 应用的。</p>

<h3 id="toc_1">代码</h3>

<p>server.go</p>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;http&quot;
    &quot;template&quot;
)

type User struct {
    Name    string
}

func Register(w http.ResponseWriter, r *http.Request) {
    if &quot;GET&quot; == r.Method {
        fmt.Fprintln(w, &quot;&lt;h1&gt;Register&lt;/h1&gt;&quot; +
            &quot;&lt;form action=&#39;/&#39; method=&#39;POST&#39;&gt;&quot; +
            &quot; User Name: &lt;input name=&#39;userName&#39; value=&#39;Type in your name&#39;/&gt;&lt;input type=&#39;submit&#39; value=&#39;Register&#39;/&gt;&quot; +
            &quot;&lt;/form&gt;&quot;)
        return
    }

    user := &amp;User{r.FormValue(&quot;userName&quot;)}
    t, _ := template.ParseFile(&quot;hello.html&quot;, nil)
    t.Execute(w, user)
}

func main() {
    http.HandleFunc(&quot;/&quot;, Register)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<p>hello.html</p>

<pre><code>&lt;h1&gt;Hello, {Name}&lt;/h1&gt;
</code></pre>

<h3 id="toc_2">总结</h3>

<p>自动解析类型字段<br/>
模板需要自行编程进行缓存</p>

<h3 id="toc_3">下一步</h3>

<p>数据持久化</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-05-20-go-web-one.html">Go Web 开发（一）</a></h1>
			<p class="meta"><time datetime="2011-05-20T16:42:19+08:00" 
			pubdate data-updated="true">2011/5/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">目的</h3>

<p>了解 Go 开发 Web 应用的基本原理。</p>

<h3 id="toc_1">代码</h3>

<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;http&quot;
)

type User struct {
    Name    string
}

func Register(w http.ResponseWriter, r *http.Request) {
    if &quot;GET&quot; == r.Method {
        fmt.Fprintln(w, &quot;&lt;h1&gt;Register&lt;/h1&gt;&quot; +
            &quot;&lt;form action=&#39;/&#39; method=&#39;POST&#39;&gt;&quot; +
            &quot; User Name: &lt;input name=&#39;userName&#39; value=&#39;Type in your name&#39;/&gt;&lt;input type=&#39;submit&#39; value=&#39;Register&#39;/&gt;&quot; +
            &quot;&lt;/form&gt;&quot;)
        return
    }

    user := &amp;User{r.FormValue(&quot;userName&quot;)}
    fmt.Fprintln(w, &quot;Hello &quot;, user.Name)
}

func main() {
    http.HandleFunc(&quot;/&quot;, Register)
    http.ListenAndServe(&quot;:8080&quot;, nil)
}
</code></pre>

<h3 id="toc_2">总结</h3>

<p>相比 Java Web 开发，简洁不少（语法、配置）<br/>
调试不方便，需要重编译、链接</p>

<h3 id="toc_3">下一步</h3>

<ul>
<li>模板入门</li>
<li>数据持久化</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-05-15-web-http-request-performance-optimization.html">Web 应用性能优化——HTTP 请求数</a></h1>
			<p class="meta"><time datetime="2011-05-15T16:35:13+08:00" 
			pubdate data-updated="true">2011/5/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">摘要</h3>

<p>从页面 HTTP 请求数以及 HTTP 缓存两方面来分析 Web 应用性能，并给出相应优化建议。</p>

<h3 id="toc_1">HTTP 请求数</h3>

<p>浏览器在请求服务器后如果返回 HTML，则在浏览器端可能会涉及到如下一些并发 HTTP 请求：</p>

<p>CSS/JS/IMG（via GET），请求数记作 S<br/>
脚本函数请求（via AJAX GET/POST/etc.），请求数记作 D<br/>
IFrame（via GET, S’&amp; D’），请求数记作 I<br/>
由此可得出一个用户在无浏览器缓存时访问某页面的 HTTP 并发数：</p>

<p>C = S + D + I</p>

<h3 id="toc_2">优化策略</h3>

<p>为了有效降低并发 HTTP 请求数 C，必须降低 S、D 与 I。可以考虑从以下几个方面进行优化：</p>

<p>CSS Sprite，图片压缩（降低 S）<br/>
CSS/JS合并，压缩（降低 S）<br/>
离线存储（降低 D）<br/>
避免使用IFrame，AJAX 加载（降低 I，降低 S、D）</p>

<h3 id="toc_3">HTTP 缓存</h3>

<p>HTTP 缓存的目的在于减少服务器处理损耗，降低带宽占用，从而提高浏览器端用户体验，提升服务器性能。</p>

<p>在 HTTP/1.1 协议中，最常用的缓存控制方法是通过设置 Cache-Control、Expires、Last-Modified、ETag 头作为响应内容缓存控制策略。</p>

<p>其基本原理是服务器在处理请求时通过非常高效、低耗的计算（时间，HASH）可以得知请求的内容是否发生变化，若未变化则告知浏览器 304（Not Modified），浏览器从本地缓存取资源；否则返回请求资源。</p>

<h3 id="toc_4">优化策略</h3>

<p>响应头 Cache-Control、Expires、Last-Modified、ETag 必须进行有效设置：</p>

<p>CSS/JS/IMG/etc.<br/>
将这些静态资源设置缓存控制，例如至少为一天。<br/>
静态/动态资源分离<br/>
将静态资源部署到独立的 HTTP 服务器中，这样可以有效缓解应用服务器压力。</p>

<h3 id="toc_5">结论</h3>

<p>通过降低页面 HTTP 请求数，优化 HTTP 缓存可以有效降低前端服务器负载。将静态/动态资源分离能进一步优化服务整体性能，但需要改进前端服务器（负载均衡代理服务器）代理模式。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-05-02-jpa-cache-cluster.html">JPA 缓存与应用集群</a></h1>
			<p class="meta"><time datetime="2011-05-02T16:20:21+08:00" 
			pubdate data-updated="true">2011/5/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">摘要</h3>

<p>本文主要介绍了 JPA 缓存体系结构以及在集群环境下 JPA 二级缓存的问题及应对策略。</p>

<h3 id="toc_1">JPA 缓存</h3>

<p>JPA 缓存分为一级缓存（L1）与二级缓存（L2）。</p>

<p>其中，一级缓存即实体管理器（EntityManager），主要负责实体状态管理。<br/>
二级缓存即 EntityManagerFactory 缓存，主要负责缓存实体或数据行（例如 EclipseLink 缓存实体，Hibernate 缓存实体 Id 与数据行）。</p>

<p>查询时，二级缓存可以有效缓解数据库压力，并有助于集合实体的初始化。</p>

<p><img src="/resource/image/2011-05-02-jpa-cache-cluster/JPACache1.png" alt="JPA Cache"/></p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2011-05-02-jpa-cache-cluster.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-04-29-decimal-fractions.html">无限循环小数转化成分数（Java实现）</a></h1>
			<p class="meta"><time datetime="2011-04-29T00:20:53+08:00" 
			pubdate data-updated="true">2011/4/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>如何精确的表达无限小数呢？这在计算机中是一个不可能完成的事情；但是无限循环小数是可以转化成分数，从而精确表达的；那问题来了，如何将无限循环小数转化成分数？例如0.（3），括号中是循环体，可以用1/3或3/9来表示。当然，我们想要的是分子分母不能再约分的最简分数。好吧：）来看看如何实现吧！</p>

<pre><code>import java.math.*;

public class Decimal2Fraction {
    public String Repeating2Smallest(String repeating, String separate){
        String separate_l = separate.substring(0,1);
        String separate_r = separate.substring(1,2);
        String separate_p = &quot;.&quot;;
        int index_p = repeating.indexOf(separate_p);
        int index_l = repeating.indexOf(separate_l);
        int index_r = repeating.indexOf(separate_r);
        BigInteger number = new BigInteger(repeating.substring(0,index_p));
        int n = index_l-index_p-1;
        BigInteger a = BigInteger.ZERO;
        if(n&gt;0)a = new BigInteger(repeating.substring(index_p+1,index_l));
        int m = index_r-index_l-1;
        BigInteger b = BigInteger.ZERO;
        if(m&lt;=0) return &quot;请输入正确的循环体&quot;;
        if(m&gt;0)b= new BigInteger(repeating.substring(index_l+1,index_r));
        BigInteger numerator = NumeratorFormula(n, m, a, b);
        BigInteger denominator = DenominatorFormula(n , m);
        BigInteger GCD = BigInteger.ZERO;
        while(!GCD.equals(BigInteger.ONE)){
            GCD = numerator.gcd(denominator);
            numerator = numerator.divide(GCD);
            denominator = denominator.divide(GCD);
        }
        return number+&quot; &quot;+numerator+&quot;/&quot;+denominator;
    }
    public BigInteger NumeratorFormula(int n,int m,BigInteger a,BigInteger b){
        return BigInteger.TEN.pow(m).subtract(BigInteger.ONE).multiply(a).add(b);
    }
    public BigInteger DenominatorFormula(int n,int m){
        return BigInteger.TEN.pow(m).subtract(BigInteger.ONE).multiply(BigInteger.TEN.pow(n));
    }
    public static void  Console(Object o){System.out.println(o.toString());}
    public static void main(String[] args) {
        Decimal2Fraction d2f = new Decimal2Fraction();
        String s = &quot;0.2[22]&quot;;
        Console(d2f.Repeating2Smallest(s,&quot;[]&quot;));
    }

}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-03-25-android-suspend-opensource.html">Google宣布Android暂停开源</a></h1>
			<p class="meta"><time datetime="2011-03-25T00:20:24+08:00" 
			pubdate data-updated="true">2011/3/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>一向以大举开源旗帜的Google昨日做出了一项令人吃惊的决定，Android 3.0系统源代码将暂停开源。不久前以不开源为由在Chrome中停止支持H.264，今天却又闭源Android 3.0，怎么看都是只许州官放火不许百姓点灯。</p>

<p>谷歌宣布Android 3.0暂停开源</p>

<p>北京时间3月25日早间消息，谷歌周四宣布，将暂时不开放针对平板电脑设计的Android 3.0“蜂巢”操作系统的源代码。</p>

<p>谷歌一名发言人表示，谷歌将“临时限制”对“蜂巢”系统代码的访问，主要原因是“谷歌尚未做好该系统被改变，或是针对不同产品进行定制的准备”。</p>

<p>然而业内人士认为，谷歌封闭“蜂巢”系统是由于谷歌的合作伙伴不希望较小的竞争对手也可以利用这一系统。谷歌发言人表示：“Android 3.0‘蜂巢’系统是针对大屏幕尺寸设备重新设计的一款系统，在小部件、多任务、浏览、通知和个人定制等方面都有所改进。尽管我们很高兴向Android 平板电脑提供这些功能，但在将这款系统移植到手机等其他设备的过程中，我们还有更多工作要做。在此之前，我们决定不对‘蜂巢’开源。”</p>

<p>谷歌的合作伙伴摩托罗拉已经发布了基于“蜂巢”系统的平板电脑Xoom，三星电子、戴尔、HTC和宏碁等厂商也将推出同类产品。</p>

<p>谷歌此前一直标榜Android是一款开源的操作系统，但“蜂巢”却是在封闭状态下开发的。而即使这款操作系统最终开源，其中的一些部件，包括 Android电子市场和谷歌地图，仍将是谷歌私有的。谷歌目前也拥有Android的商标权。这意味着，手机厂商无法在不遵守谷歌规定的情况下开发 Android设备。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2011-03-14-tomcat-jdk-welcome-page.html">tomcat-5.5.33、jdk1.6.0_24访问不到欢迎页</a></h1>
			<p class="meta"><time datetime="2011-03-14T00:19:19+08:00" 
			pubdate data-updated="true">2011/3/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>今天下午碰到比较郁闷的问题，apache-tomcat-5.5.33、jdk1.6.0_24在win7下访问不到欢迎页；纠结了3个小时才发现是这两个版本存在兼容性问题，换用稍微低一点的jdk，不一定非要是1.5，具体是update_X的具体哪个版本真不清楚，如果你有兴趣可以自己试试，如果你还有兴趣可以告诉我一下。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_11.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_9.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2017-06-24-ios-arm.html">iOS开发 - 制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-10-wechat-redenvelop-tweak-for-non-jailbroken-iphone.html">不越狱iOS自动抢红包</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-01-continuous-deployment-at-instagram.html">Instagram 是如何做持续部署的</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-30-life-2016.html">2016 总结 - 工作十小时，休息五分钟</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>