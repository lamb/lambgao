
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-21-alibaba-cobar-survey.html">Cobar 概述</a></h1>
			<p class="meta"><time datetime="2014-04-21T18:38:49+08:00" 
			pubdate data-updated="true">2014/4/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="https://github.com/alibaba/cobar">Cobar</a> 是由 Alibaba 开源的 MySQL 分布式处理中间件，它可以在分布式的环境下看上去像传统数据库一样提供海量数据服务。</p>

<p><img src="https://01yttw.dm1.livefilestore.com/y2ppdD23riGhI6sLiZu6c-Wf2GZ7gU_O8JFZMPpGUjahD5WNMRpUmjTjPfLNTwtrOORN2GWW5JweAkqDqfblR8Xi_YfMvTbVq0znhJGlxcSW-Y/cobar.png?psid=1" alt="Cobar 架构"/></p>

<h3 id="toc_0">Cobar 解决的问题</h3>

<p>分布式：Cobar 的分布式主要是通过将表放入不同的库来实现：</p>

<ol>
<li><p>Cobar 支持将一张表水平拆分成多份分别放入不同的库来实现表的水平拆分</p></li>
<li><p>Cobar 也支持将不同的表放入不同的库</p></li>
<li><p>多数情况下，用户会将以上两种方式混合使用</p></li>
</ol>

<p>HA：在用户配置了 MySQL 心跳的情况下，Cobar 可以自动向后端连接的 MySQL 发送心跳，判断 MySQL 运行状<br/>
况，一旦运行出现异常，Cobar 可以自动切换到备机工作。但需要强调的是：</p>

<ol>
<li><p>Cobar 的主备切换有两种触发方式，一种是用户手动触发，一种是 Cobar 的心跳语句检测到异常后自动触发。那么，当心跳检测到主机异常，切换到备机，如果主机恢复了，需要用户手动切回主机工作，Cobar 不会在主机恢复时自动切换回主机，除非备机的心跳也返回异常</p></li>
<li><p>Cobar 只检查 MySQL 主备异常，不关心主备之间的数据同步，因此用户需要在使用 Cobar 之前在 MySQL 主备上配置双向同步</p></li>
</ol>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-04-21-alibaba-cobar-survey.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-10-javamail-smtp-163.html">JavaMail 使用 163 发送邮件</a></h1>
			<p class="meta"><time datetime="2014-04-10T18:43:23+08:00" 
			pubdate data-updated="true">2014/4/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在通过 JavaMail 使用 163 邮箱发邮件时有几点问题需要注意。</p>

<ul>
<li><p>550 用户被锁定：普通 163 邮箱是无法通过 smtp.163.com 发送邮件的，只有 163 VIP 邮箱才行，然后设置 mail.smtp.host=smtp.vip.163.com</p></li>
<li><p>454 Command not permitted when TLS active：需要设置 mail.smtp.starttls.enable=false</p></li>
<li><p>553 authentication is required：需要设置 mail.smtp.auth=true</p></li>
<li><p>550 Invalid User：from 必须写成带 @ 的邮件格式，且 username 要用 @ 前面的</p></li>
</ul>

<p>一个完整的配置示例：</p>

<p>mail.smtp.auth=true<br/>
mail.smtp.starttls.enable=false<br/>
mail.debug=false<br/>
mail.smtp.host=smtp.vip.163.com<br/>
mail.smtp.port=465<br/>
mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory<br/>
mail.smtp.socketFactory.fallback=false<br/>
mail.smtp.socketFactory.port=465</p>

<p>编程实参：Authenticator 用户名：xxx；mimeMessage.setFrom(&quot;<a href="mailto:xxx@vip.163.com">xxx@vip.163.com</a>&quot;)</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-08-mongodb-2-6-0.html">Mongdb2.6.0 一个新版本号</a></h1>
			<p class="meta"><time datetime="2014-04-08T00:31:25+08:00" 
			pubdate data-updated="true">2014/4/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>MongoDB 2.6 发布了，这是一个主要的发行版本，改进涉及到核心、存储、网络、查询和安全性等诸多方面。核心主要改进内容包括：</p>

<ul>
<li>聚合函数增强</li>
<li>集成全文搜索</li>
<li>改进插入和更新操作</li>
<li>新的写操作协议</li>
<li>Windows 下的 MSI 安装包</li>
</ul>

<h3 id="toc_0">聚合函数增强</h3>

<ul>
<li>现在db.collection.aggregate() 返回一个游标, 可以使用管道操作符来限制返回文档的数量</li>
<li>聚合函数也可以使用explain来打印详细的查询信息来帮助分析了</li>
<li>Aggregation can now use a more efficient external-disk-based sorting process.</li>
<li>新的管道操作符\(out和\)redact </li>
<li>New or modified operators:
set expression operators
\(let and \)map operators to allow for the use of variables
\(literal operator and \)size operator
$cond expression now accepts either an object or an array</li>
</ul>

<p>下面的略，有空再细看一下.</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-08-bye-windwos-xp.html">再见Windows XP</a></h1>
			<p class="meta"><time datetime="2014-04-08T00:30:55+08:00" 
			pubdate data-updated="true">2014/4/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>今天（4月8日）微软将正式停止针对Windows XP的安全维护， 意味着这一服役长达13年之久的操作系统终于开始退出历史舞台了。Windows XP于2001年10月25日正式发布，相比其前一代操作系统Windows 2000和Windows Me，其全新的用户图形界面、简化的操作体验，使其快速抢占了市场。随后微软推出的Vista由于各种缺陷（耗资源、速度慢、兼容性差等），也无法成功替代XP，反而使得用户的XP情结更加根深蒂固，继而成为微软后续操作系统（Windows 7/8）推广的最大绊脚石。 </p>

<p>我现在已经脱离Windows很久，但是还是要写篇文章纪念一下，因为80后谁敢拍着胸膛说我没用过Windows XP，谁敢说我没用过盗版XP。我用过，所以我要说“再见，Windows XP！”</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-07-mongodb-daemon-start-and-down.html">Mongdb后台daemon方式启动与停止</a></h1>
			<p class="meta"><time datetime="2014-04-07T00:30:25+08:00" 
			pubdate data-updated="true">2014/4/7</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在后台开启Mongdb服务可以使用--fork。启用fork必须要带上--logpath来指定日志输出目录。为了防止日志被覆盖可以开启--logappend。</p>

<pre><code>mongod --fork --logpath /data/log/20140407.log --logappend
</code></pre>

<p>mongodb默认的数据保存路径是/data/db/，默认端口号为27017。如果想修改可以使用--dbpath和--port来修改</p>

<pre><code>mongod --dbpath /mydata/ --port 20111
</code></pre>

<p>也可以把参数写入配置文件中，通过配置文件来启动。</p>

<pre><code>mongod -f /data/conf/mongodb.conf
</code></pre>

<p>配置文件如下：</p>

<pre><code>port = 27017
dbpath = /data/db
logpath = /data/log/20140407.log
logappend = true
fork = true
</code></pre>

<p>如果没有使用--fork，退出终端的时候mongodb会自动清理退出，把没有写好的数据写完成，并最终关闭数据文件。要注意的是这个过程会持续到所有操作都完成。如果使用--fork在后台运行mongdb服务，那么就要通过向服务器发送shutdownServer()消息来关闭。</p>

<pre><code>use admin
db.shutdownServer()
</code></pre>

<p>要注意的是，这个命令只允许在本地，或是一个经过认证的客户端。</p>

<p>如果这是一个主从式的复制集群，在1.9.1版本后将按下面的步骤来关闭</p>

<ul>
<li>检查从Mongodb的数据更新时间</li>
<li>如果所有的从Mongodb和主的时间差都超过10，这个时候不会关闭mongodb（在这种情况下面，我们可以通过配置timeoutSecs的方式来让从Mongodb完成数据的更新）</li>
<li>如果其中有一个从Mongodb与主服务时间差在10秒内，那么主服务器将会关闭，并且等待从Mongodb更新完成并关闭。</li>
</ul>

<p>如果没有up-to-date 从Mongodb且你想强制关闭服务，可以通过添加force:true;命令如下：</p>

<pre><code>db.adminCommand({shutdown : 1, force : true})
or
db.shutdownServer({force : true, timeoutsec : 5})
</code></pre>

<p>Window下面以后台服务的方式启动可以使用下面的命令添加服务，配置文件的内容同mac下的</p>

<pre><code>sc create MongoDB binPath= &quot;\&quot;%MONGO_HOME%\bin\mongod.exe\&quot; --service --config=\&quot;%MONGO_HOME%\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot;
</code></pre>

<p>如果成功看到</p>

<pre><code>[SC] CreateService SUCCESS
</code></pre>

<p>服务安装成功后可以使用命名启动也可以手动启动</p>

<pre><code>net start MongoDB
</code></pre>

<p>想删除服务可以使用如下命令</p>

<pre><code>sc delete &quot;MongoDB&quot;
</code></pre>

<p>单个进程打开的最大文件句柄数量限制的修改，在/etc/profile文件最下面添加命令</p>

<pre><code>ulimit -n 1024
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-05-can-break-wind-but-cannot-break-sb.html">防风，但不防傻逼</a></h1>
			<p class="meta"><time datetime="2014-04-05T00:29:46+08:00" 
			pubdate data-updated="true">2014/4/5</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>耐不住毕业前的躁动与无聊，我前段时间养成了半夜在走廊和人抽烟聊天的习惯。有一次我偶然发现隔壁寝室的四个男生一人买了个zippo打火机，我虽然偶尔也抽烟，但用的都是一块钱一个偶尔死活打不着偶尔却能烧到头发的便宜货，因此对这种高端霸气上档次的东西心存敬畏与好奇，便借来把玩了一番。</p>

<p>我打着了后弱弱问一哥们道：“这玩意防风么？”</p>

<p>他点点头道：“嗯，zippo打火机都是防风的。”</p>

<p>然后我“呼”的一声就把火给吹灭了，然后得意洋洋地把打火机在他前面晃了晃道：“你看，不防风吧。”</p>

<p>他淡淡地说了句道：“防风，但不防傻逼。”</p>

<p>当时虽然被周围一票人给笑了半天，但我自己也忍不住跟着笑了很久，倒不是我缺心眼听不懂好歹话或者是喜欢被人称作傻逼，而是我觉得这个说法真心很赞，光从这句回答本身的机智程度来看就足够给好评了，无论这个所指的对象是不是我，我都觉得很享受。</p>

<p>后来有天我和一个朋友聊天的时候，他跟我说起他之前的一个经历。他之前在学校的学生会里工作，因为权利问题还有一些个人的矛盾和其中的一个同学搞得很僵，但他一直都处处让着那个同学，反倒是那个同学处处刁难他，还想方设法排挤孤立他。终于有一天他觉得呆不下去了，选择主动退出学生会，临走前他特意约了那个同学出来，给他道歉说之前都是自己的不对，希望他能够原谅自己。</p>

<p>我听完后忍不住骂他实在是怂，整件事情他并没有做错什么，到头来不仅是你退出，还去给那个伤害你的人道歉，究竟是不是脑子搭错了。他只是淡淡的告诉我，有些事情冤冤相报何时了，他本来也没想争个啥，既然一山不容二虎不如就我退一步呗，我给他道歉其实是想告诉他，我不是一个喜欢认输的人，但对于没品的对手以及没意义的争斗，我就把这种满足感施舍给你可怜的虚荣心好了。</p>

<p>他的这个回答让我再次想起了前些天在走廊里听到的那句话，作为zippo打火机，既然你标榜你是防风的，那就难免会有人用各种奇怪的方式来验证你究竟是不是能防风，能防什么样的风，也肯定会有人在弄灭你以后耀武扬威地向旁人得意地炫耀他的胜利以及你的无能。然而这时候的你，是满腔怒火要和那个人争一个高下，给他灌输所谓的防风的标准是什么，还是徒劳地努力改变自己，让自己变得不仅能防各种阴风台风龙卷风，还能防水防盗防学长呢。我觉得与其去和傻逼较劲，不如放自己一条生路，告诉他对不起这个打火机让你失望了，希望他能够找到更适合自己的点烟方式，无论是用火柴煤气灶还是氧气切割机。</p>

<p>我越发觉得这是一个累心的年代，记得之前有人因为我转载的一张图片，声称要发微博让广大网民一起声讨我，我当时还可傻逼地写了一条很长的状态来解释缘由声明自己的立场，生怕自己被狂热的粉丝们人肉出来挂在城楼上晒成腊肉条。现在想想，无论是在网上和人吵个面红耳赤，还是急于在各种流言蜚语前证明自己的清白，都是一种自寻烦恼而自讨没趣的行为，还容易把自己的情商与智商拉到地平线以下。</p>

<p>既然你愿意站得高，愿意把自己的想法拿出来分享，那么难免就会被人看到你的弱点，被不同居心的揣测或是针对，就像你说你是个防风的打火机，还是个颇有些出名的牌子，那么就避免不了有秀下限的人来试试你究竟是不是真的防风。然而当有人用极端手段或是错误的手段成功地挑战了你时，你究竟是怒不可遏地反过来挑战他的智商，维护自己那飘渺的尊严，还是一笑而过，让傻逼飞一会儿呢。</p>

<p>我想绝大多数人都咽不下这一口气，也受不了这个委屈，然而为了变得更强大，很多时候我们需要这样的修炼，直到所有的质疑和否定相比起你的强大都变得微不足道的那一天。</p>

<p>好吧，我终于还是用我最讨厌的文体写完了这篇文章，就为了这句最初用来形容我却让我爱得不行的一句话。</p>

<p>“防风，但不防傻逼。”愿各位共勉。</p>

<p>文/陈谌 <a href="http://site.douban.com/177678/widget/notes/10060932/note/273510395/?qq-pf-to=pcqq.discussion">原文链接</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-04-03-maven-jdocbook-plugin.html">maven-jdocbook-plugin 使用</a></h1>
			<p class="meta"><time datetime="2014-04-03T18:46:21+08:00" 
			pubdate data-updated="true">2014/4/3</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><a href="http://www.docbook.org/">DocBook</a> 是一个文档工具，Spring、Hibernate 等开源项目都是用它来编写、生成多格式文档的。这里主要介绍在 maven 环境中使用 maven-jdocbook-plugin 插件来使用 DocBook。</p>

<p>POM 中加入 jdocbook 插件：</p>

<pre><code>&lt;plugin&gt;
    &lt;groupId&gt;org.jboss.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-jdocbook-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.3.8&lt;/version&gt;
    &lt;extensions&gt;true&lt;/extensions&gt;
    &lt;configuration&gt;
        &lt;masterTranslation&gt;zh-CN&lt;/masterTranslation&gt;
        &lt;formats&gt;
            &lt;format&gt;
                &lt;formatName&gt;html&lt;/formatName&gt;
            &lt;/format&gt;
        &lt;/formats&gt;
    &lt;/configuration&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss&lt;/groupId&gt;
            &lt;artifactId&gt;jbossorg-docbook-xslt&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.jboss&lt;/groupId&gt;
            &lt;artifactId&gt;jbossorg-jdocbook-style&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
            &lt;type&gt;jdocbook-style&lt;/type&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;SDK_Manual_zh_CN&lt;/id&gt;
            &lt;phase&gt;package&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;resources&lt;/goal&gt;
                &lt;goal&gt;generate&lt;/goal&gt;
            &lt;/goals&gt;

            &lt;configuration&gt;
                &lt;sourceDocumentName&gt;index.xml&lt;/sourceDocumentName&gt;
                &lt;sourceDirectory&gt;${basedir}/src/main/docs&lt;/sourceDirectory&gt;
                &lt;imageResource&gt;
                    &lt;directory&gt;${basedir}/src/main/docs/images&lt;/directory&gt;
                &lt;/imageResource&gt;
                &lt;cssResource&gt;
                    &lt;directory&gt;${basedir}/src/main/docs/css&lt;/directory&gt;
                &lt;/cssResource&gt;

                &lt;formats&gt;
                    &lt;format&gt;
                        &lt;formatName&gt;html&lt;/formatName&gt;
                        &lt;stylesheetResource&gt;classpath:/xslt/org/jboss/xhtml.xsl&lt;/stylesheetResource&gt;
                        &lt;finalName&gt;index.html&lt;/finalName&gt;
                    &lt;/format&gt;
                    &lt;format&gt;
                        &lt;formatName&gt;html_single&lt;/formatName&gt;
                        &lt;stylesheetResource&gt;classpath:/xslt/org/jboss/xhtml-single.xsl&lt;/stylesheetResource&gt;
                        &lt;finalName&gt;index.html&lt;/finalName&gt;
                    &lt;/format&gt;
                &lt;/formats&gt;

                &lt;options&gt;
                    &lt;xincludeSupported&gt;true&lt;/xincludeSupported&gt;
                &lt;/options&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

<p>还需要加入 JBoos 的 mvn 库：</p>

<pre><code>&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;jboss-public-repository-group&lt;/id&gt;
        &lt;name&gt;JBoss Public Repository Group&lt;/name&gt;
        &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public/&lt;/url&amp;gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>

<p>目录结构：</p>

<p><img src="https://pyqdbw.dm2302.livefilestore.com/y2p1MpINCmrzVLlvjf6p8o1ZwxXXKvDtrJbOdqFMpz5Hwr08vSWTxR57tHzk-fp6j68eVJ4T33FseHLLoDiGvuB6NaFKjcU9F50vDXaVde2rH8/docbook.png?psid=1" alt="目录结构"/></p>

<p>本文主要是参考 <a href="http://www.blogjava.net/kuuyee/archive/2009/07/27/288613.html">用maven-jdocbook-plugin简单配置docbook5.0环境</a> 所写，并修复了其中一些配置有误的地方。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-03-18-rabbitmq-network-partition.html">RabbitMQ 网络分区问题</a></h1>
			<p class="meta"><time datetime="2014-03-18T18:26:13+08:00" 
			pubdate data-updated="true">2014/3/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>RabbitMQ 集群的网络分区容错性并不是非常高，在网络经常发生分区时会有些问题，最明显的就是脑裂问题。</p>

<p>官方文档是这样介绍的：</p>

<p>RabbitMQ clusters do not tolerate network partitions well. If you are thinking of clustering across a WAN, don&#39;t. You should use <a href="https://www.rabbitmq.com/federation.html">federation</a> or the <a href="https://www.rabbitmq.com/shovel.html">shovel</a> instead.</p>

<p>从中我们可以看出，在广域网环境下不应该使用集群，而应该使用 federation 或者 shovel 来解决。</p>

<p>不过即使是在局域网环境下，网络分区也不可能完全避免，网络设备（比如中继设备、网卡）出现故障也会导致网络分区。</p>

<p>Network partition detected</p>

<p>Mnesia reports that this RabbitMQ cluster has experienced a network partition. This is a dangerous situation. RabbitMQ clusters should not be installed on networks which can experience partitions. </p>

<p>当出现网络分区时，不同分区里的节点会认为不属于自身所在分区的节点都已经挂了，对 queue、exchange、binding 的操作仅对当前分区有效。在 RabbitMQ 的默认配置下，即使网络恢复了也不会自动处理网络分区带来的问题从而恢复集群。RabbitMQ（3.1+）会自动探测网络分区，并且提供了配置来解决这个问题。</p>

<pre><code>[
 {rabbit,
  [{tcp_listeners,[5672]},
   {cluster_partition_handling, ignore}]
 }
].
</code></pre>

<p>RabbitMQ 提供了三种配置：</p>

<ol>
<li>ignore：默认配置，发生网络分区时不作处理，当认为网络是可靠时选用该配置</li>
<li>autoheal：各分区协商后重启客户端连接最少的分区节点，恢复集群（CAP 中保证 AP，有状态丢失）</li>
<li>pause_minority：分区发生后判断自己所在分区内节点是否超过集群总节点数一半，如果没有超过则暂停这些节点（保证 CP，总节点数为奇数个）</li>
</ol>

<p>参考：</p>

<ul>
<li><a href="https://www.rabbitmq.com/partitions.html">RabbitMQ 官方文档</a></li>
<li><a href="http://en.wikipedia.org/wiki/Network_partition">网络分区</a></li>
<li><a href="http://en.wikipedia.org/wiki/Split-brain_(computing)">脑裂问题</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-03-11-node-invoke-java-via-hessian.html">Hessian 示例：Node 调用 Java</a></h1>
			<p class="meta"><time datetime="2014-03-11T18:17:46+08:00" 
			pubdate data-updated="true">2014/3/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Java 端作为服务提供者，基于 <a href="https://github.com/alibaba/dubbo">Dubbo</a> 实现服务并通过 Dubbo Hessian 扩展暴露服务；Node 端作为服务消费者，通过 <a href="https://github.com/villadora/node-hessian">node-hessian</a> 调用 Java 端的服务。</p>

<h3 id="toc_0">Java 端</h3>

<h4 id="toc_1">服务接口</h4>

<pre><code>package com.yuanxin.paas.ssb;
 
public interface TestService {
 
    /**
     * 测试：无参，无返回值。
     */
    void test();
     
    /**
     * 测试：原生类型参数与返回值。
     * 
     * @param i
     * @return 
     */
    String test0(int i);
     
    /**
     * 测试：无参，自定义类型返回值。
     * 
     * @return 
     */
    Result test1();
     
    /**
     * 测试：自定义类型参数，无返回值。
     * 
     * @param arg 
     */
    void test2(Arg arg);
     
    /**
     * 测试：自定义参数，自定义返回值。
     * 
     * @param arg
     * @return 
     */
    Result test3(final Arg arg);
}
</code></pre>

<h4 id="toc_2">自定义参数类</h4>

<pre><code>package com.yuanxin.paas.ssb;
 
import java.io.Serializable;
 
public class Arg implements Serializable {
 
    private int i;
 
    public int getI() {
        return i;
    }
 
    public void setI(int i) {
        this.i = i;
    }
 
}
</code></pre>

<h4 id="toc_3">自定义返回值类</h4>

<pre><code>package com.yuanxin.paas.ssb;
 
import java.io.Serializable;
 
public class Result implements Serializable {
 
    private int i;
 
    private String string;
 
    public int getI() {
        return i;
    }
 
    public void setI(int i) {
        this.i = i;
    }
 
    public String getString() {
        return string;
    }
 
    public void setString(String string) {
        this.string = string;
    }
 
}
</code></pre>

<p>Dubbo 配置略。</p>

<h3 id="toc_4">Node 端</h3>

<h4 id="toc_5">node-hessian</h4>

<p>安装 <a href="https://github.com/villadora/node-hessian">node-hessian</a>：</p>

<pre><code>npm install hessian-proxy
</code></pre>

<h4 id="toc_6">调用服务接口</h4>

<pre><code>var Proxy = require(&#39;hessian-proxy&#39;).Proxy;
 
var proxy = new Proxy(&#39;http://127.0.0.1:9098/test-provider/provider/com.yuanxin.paas.ssb.TestService&#39;, &#39;&#39;, &#39;&#39;, proxy);
 
proxy.invoke(&#39;test&#39;, null, function (err, reply) {
    console.log(&#39;test: &#39; + reply);
});
 
proxy.invoke(&#39;test0&#39;, [25], function (err, reply) {
    console.log(&#39;test0: &#39; + JSON.stringify(reply));
})
 
proxy.invoke(&#39;test1&#39;, null, function (err, reply) {
    if (err) {
        console.log(&#39;test1: &#39; + err);
    }
 
    console.log(&#39;test1: &#39; + JSON.stringify(reply));
})
 
var argForTest2 = {
    i: 2
};
 
argForTest2.__type__ = &#39;com.yuanxin.paas.ssb.Arg&#39;;
 
proxy.invoke(&#39;test2&#39;, [argForTest2], function (err, reply) {
    if (err) {
        console.log(&#39;test2: &#39; + err);
    }
 
    console.log(&#39;test2: &#39; + JSON.stringify(reply));
})
 
 
var argForTest3 = {
    i: 3
};
 
argForTest3.__type__ = &#39;com.yuanxin.paas.ssb.Arg&#39;;
 
proxy.invoke(&#39;test3&#39;, [argForTest3], function (err, reply) {
    if (err) {
        console.log(&#39;test3: &#39; + err);
    }
 
    console.log(&#39;test3: &#39; + JSON.stringify(reply));
})
</code></pre>

<h3 id="toc_7">运行结果</h3>

<h4 id="toc_8">Java 端</h4>

<p><img src="https://oojduq.dm2304.livefilestore.com/y2py0LBG1b1FvLtEbu06GyRtHlJupy8dqaq_o0KNF5HoezRo2TvSMWc4OtrRZubhn9GRcUpZokO9ckrOfv5V8b8KoNLg8wQtZPKIickLNaTsuw/hessian-java.png?psid=1" alt="Java 端"/></p>

<h4 id="toc_9">Node 端</h4>

<p><img src="https://oojduq.dm2301.livefilestore.com/y2pxuLkG4il3ohi2PsC6XlEr0q2daXHtATcpiFAS05PlCJX3zzpOWlAS_IedLT5851lD6UoLCYHCwzrsV9ouLWzkA9mj8FwJaIXiYljHMNRhiY/hessian-node.png?psid=1" alt="Node 端"/></p>

<h3 id="toc_10">总结</h3>

<p>Dubbo 非常赞，提供了对 Hessian 原生协议的支持；Node 调用起来也非常简单，不过还是有几个点需要注意一下：</p>

<ul>
<li>接口方法不能重载（接口里的方法必须使用不同的方法名）</li>
<li>自定义类型的命名空间服务端与消费端要一致（com.yuanxin.paas.ssb.Arg）</li>
<li>服务端自定义类型需要实现序列化接口（java.io.Serializable）</li>
<li>尽量使用简单的自定义类型结构（避免嵌套）</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-02-08-autoremove-logs.html">自动清理日志 Shell 脚本</a></h1>
			<p class="meta"><time datetime="2014-02-08T18:17:45+08:00" 
			pubdate data-updated="true">2014/2/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>以删除 Jetty 日志为例，仅保留最近 7 天的日志文件。</p>

<pre><code>#!/bin/bash
  
# 要清理的目录，多个目录用空格分开
dirs=(d-jetty/logs v-jetty/logs rhythm-jetty/logs symphony-jetty/logs) 
  
# 循环 dirs 数组
for dir in ${dirs[*]}
  do
    # 删除目录下 7 天之前的日志文件
    find $dir -mtime +7 -name *.log* | xargs rm
  done
</code></pre>

<p>最后，加入 crontab，每天定时执行：</p>

<pre><code>crontab -e
</code></pre>

<p>设置为凌晨 4 点执行：</p>

<pre><code>* 4 * * * /root/clean_jetty_logs.sh
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-01-22-backup-mysql-shell.html">MySQL 自动备份 Shell 脚本</a></h1>
			<p class="meta"><time datetime="2014-01-22T18:13:59+08:00" 
			pubdate data-updated="true">2014/1/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>可以选择设置需要备份的库，自动备份压缩，自动删除 7 天前的备份，需要使用 crontab 定时执行。</p>

<pre><code>#!/bin/bash

# 要备份的数据库名，多个数据库用空格分开
databases=(db1 db2 db3) 

# 备份文件要保存的目录
basepath=&#39;/root/backup/mysql/&#39;

if [ ! -d &quot;$basepath&quot; ]; then
  mkdir -p &quot;$basepath&quot;
fi

# 循环databases数组
for db in ${databases[*]}
  do
    # 备份数据库生成SQL文件
    /bin/nice -n 19 /usr/bin/mysqldump -uUSER -pPASSWORD --database $db &gt; $basepath$db-$(date +%Y%m%d).sql
    
    # 将生成的SQL文件压缩
    /bin/nice -n 19 tar zPcf $basepath$db-$(date +%Y%m%d).sql.tar.gz $basepath$db-$(date +%Y%m%d).sql
    
    # 删除7天之前的备份数据
    find $basepath -mtime +7 -name &quot;*.sql.tar.gz&quot; -exec rm -rf {} \;
  done

  # 删除生成的SQL文件
  rm -rf $basepath/*.sql
</code></pre>

<p>其中备份目录、MySQL 口令需要配置。</p>

<p>然后使用 crontab 设置该脚本定时执行：</p>

<pre><code>crontab -e
</code></pre>

<p>设置为凌晨 3 点执行：</p>

<pre><code>0 3 * * * /root/backup_mysql.sh
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-01-15-java-exec-utli.html">Java 执行命令</a></h1>
			<p class="meta"><time datetime="2014-01-15T18:12:02+08:00" 
			pubdate data-updated="true">2014/1/15</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Java 调用命令行有两种方式，ProcessBuilder 或 Runtime。</p>

<p>在使用 Runtime 时，有两点需要注意：</p>

<ol>
<li>需要开启线程读取错误流，否则可能会造成进程阻塞</li>
<li>执行带管道或重定向的命令时需要拆成多个命令执行</li>
</ol>

<pre><code>Execs.exec(new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /proc/cpuinfo | grep &#39;model name&#39; | awk &#39;{ print $NF }&#39;&quot;});
</code></pre>

<p>细节请参考这个<a href="https://github.com/b3log/b3log-latke/blob/master/latke/src/main/java/org/b3log/latke/util/Execs.java">实现</a>。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-01-14-grub-rescue.html">Grub 恢复命令</a></h1>
			<p class="meta"><time datetime="2014-01-14T18:07:56+08:00" 
			pubdate data-updated="true">2014/1/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>重装 Win 后，MBR 被重置，会导致 Ubuntu 进不去，这里介绍一个恢复步骤。</p>

<h4 id="toc_0">1. 从 LiveCD 进入</h4>

<h4 id="toc_1">2. 找到已挂载好的原 Linux 根分区（/media/ubuntu/xxx）如果 /boot 是单独安装的，也需要挂载好。</h4>

<h4 id="toc_2">3. 挂载虚拟文件系统</h4>

<pre><code>sudo mount --bind /dev /media/ubuntu/xxx/dev
sudo mount --bind /proc /media/ubuntu/xxx/proc
sudo mount --bind /sys /media/ubuntu/xxx/sys
</code></pre>

<h4 id="toc_3">4. 为确保 grub 工具是从 LiveCD 执行的，挂在 /usr</h4>

<pre><code>sudo mount --bind /usr/ /media/ubuntu/xxx/usr
sudo chroot /media/ubuntu/xxx
</code></pre>

<h4 id="toc_4">5. 更新（创建） /boot/grub/grub.cfg</h4>

<pre><code>sudo update-grub2
</code></pre>

<h4 id="toc_5">6. 重新安装 grub</h4>

<pre><code>grub-install /dev/sd&lt;strong&gt;X&lt;/strong&gt;
</code></pre>

<p>注意：不要带分区号，可以用 sudo fdisk -l 查看</p>

<h4 id="toc_6">7. 重启</h4>

<pre><code>sudo reboot
</code></pre>

<h4 id="toc_7">8. 进入 Ubuntu 后执行</h4>

<pre><code>sudu update-grub2
</code></pre>

<h4 id="toc_8">9. Done!</h4>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-12-17-building-android-projects-with-gradle.html">使用Gradle构建Android项目</a></h1>
			<p class="meta"><time datetime="2013-12-17T17:26:29+08:00" 
			pubdate data-updated="true">2013/12/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在最近的Google IO大会上我注意到Android Studio开发环境引起了大家的关注。我发现Eclipse经常会变慢而且健壮性不强，所以一个新的替代Android IDE是最受欢迎的消息。在仔细关注这次的发布时，我发现另一个亮点是基于Gradle的Android项目新的构建系统。因此我决定更仔细地了解Gradle。</p>

<p>下面列举了一些使用Gradle构建Android项目的好处：</p>

<ul>
<li>在IDE环境和命令行下使用同一个构建系统</li>
<li>改进的依赖关系管理</li>
<li>更容易地集成到自动化构建系统</li>
</ul>

<p>一个额外的好处来自Android函数库包格式“aar”格式。以前，Android函数库通常需要被导入到IDE以此将App需要的资源加入编译。但是现在的Android函数库可以被直接包含，与“jar”文件被Java项目包含的方式类似。这项功能虽然出现已久，但确实非常受欢迎。</p>

<p>下面是我一个项目的gradle构建脚本：</p>

<pre><code>buildscript {
    //定义一些项目需要的JAR函数库
    LIBS_DIR = &quot;../../../libs&quot;
 
    //需要从maven中央库得到gradle的android插件
    repositories {
        mavenCentral()
    }
 
    dependencies {
        classpath &#39;com.android.tools.build:gradle:0.4.2&#39;
    }
}
 
//声明项目是一个android构建
apply plugin: &#39;android&#39;
 
dependencies {
    //同时用本地maven库查找依赖
    repositories {
        mavenLocal()
    }
 
    //下面是一些app需要的jar文件
    compile files(&quot;${LIBS_DIR}/hiscore/hiscore.jar&quot;)
    compile files(&quot;${LIBS_DIR}/GoogleAnalytics/libGoogleAnalytics.jar&quot;)
 
    //这是一个我存放在本地maven仓库（使用“aar”格式）的android函数库
    compile (&#39;com.mopub.mobileads:mopub-android-sdk:unknown&#39;)
}
 
//android构建的项目定义
android {
    compileSdkVersion 15
    buildToolsVersion &quot;17.0.0&quot;
 
    //下面的代码路径不是推荐的新项目结构
    //我仍然使用的Eclipse风格结构
    sourceSets {
        main {
            manifest.srcFile &#39;AndroidManifest.xml&#39;
            java.srcDirs = [&#39;src&#39;]
 
            resources.srcDirs = [&#39;src&#39;]
            aidl.srcDirs = [&#39;src&#39;]
 
            renderscript.srcDirs = [&#39;src&#39;]
 
            res.srcDirs = [&#39;res&#39;]
            assets.srcDirs = [&#39;assets&#39;]
        }
 
        instrumentTest.setRoot(&#39;tests&#39;)
    }
 
    //声明创建一个带签名的发布版本细节
    signingConfigs {
        release {
            storeFile file(&quot;../keys/android.keystore&quot;)
            storePassword &quot;######&quot;
            keyAlias &quot;######&quot;
            keyPassword &quot;######&quot;           
        }
    }
 
    //声明此发布构建在签名之前需要运行proguard
    buildTypes {
        release {
            runProguard true
            proguardFile getDefaultProguardFile(&#39;proguard-android.txt&#39;)
            proguardFile &#39;proguard.cfg&#39;
            signingConfig signingConfigs.release
        }    
    }    
}
</code></pre>

<p>从命令行构建app可以运行下面的命令：</p>

<pre><code>gradle assembleDebug    #debug构建
gradle assembleRelease  #release构建
</code></pre>

<p>我以前用过Maven做了几个项目，发现用Maven来管理项目配置非常有用，尤其是在依赖管理方面。但是我发现Maven在某些情况下缺少灵活性，你不得不为某些特殊的情况进行自定义。理论上你可以编写自己的Maven插件，但实践起来大多数用户不会这么做通常他们会依赖现有的插件。所以我经常使用Ant而不是Maven，因为它在处理项目特殊操作，比如拷贝或修改代码文件时更加灵活。</p>

<p>Gradle看上去在这两方面都做得很好：通过插件为绝大多数的常用情况提供了全面支持，管理依赖关系方面与Maven做得同样好；同时也提供了良好的灵活性，在需要修改构建脚本时可以自由地定制。</p>

<p>我相信Gradle是构建Android应用的趋势。Gradle还提供了很多其他很赞的特性，例如构建“佐料（flavors）”等，本文没有涉及。我相信Google采用Gradle是在Android发展上的一个重要进步。现在，我会将其他的项目都转为使用Gradle。</p>

<p>原文链接： <a href="http://spweblog.blogspot.com/2013/07/building-android-projects-with-gradle.html">spweblog.blogspot.com</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-11-06-evolution-of-service-management-process.html">服务治理过程演进</a></h1>
			<p class="meta"><time datetime="2013-11-06T17:57:29+08:00" 
			pubdate data-updated="true">2013/11/6</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p><img src="http://img.my.csdn.net/uploads/201304/23/1366707908_4896.png" alt="Dubbo 服务治理"/></p>

<p>在大规模服务化之前，应用可能只是通过RMI或Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。</p>

<h4 id="toc_0">(1) 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。</h4>

<p>此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。</p>

<p>并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。</p>

<h4 id="toc_1">(2) 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</h4>

<p>这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。</p>

<ul>
<li>静态依赖：通过 mvn 依赖生成</li>
<li>动态依赖：通过运行时调用分析得出</li>
</ul>

<h4 id="toc_2">(3) 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</h4>

<p>为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。</p>

<p>其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>

<h4 id="toc_3">(4) 规模继续扩大，应用之间不再是扁平的对应关系，开始分层，比如核心数据层，业务集成层等，就算没有出现循环依赖，也不允许从低层向高层依赖，以免后续被逼循环依赖。</h4>

<p>这时，需要在注册中心定义架构体系，列明有哪些层的定义，每个服务暴露或引用时，都必须声明自己应用属于哪一层，这样注册中心能更快的发现架构的腐化现象。</p>

<h4 id="toc_4">(5) 服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？</h4>

<p>这时就需要登记每个服务都是谁负责的，并建立一个服务的文档库，方便检索。</p>

<h4 id="toc_5">(6) 慢慢一些敏感数据也都服务化了，安全问题开始变得重要，谁能调该服务？如何授权？</h4>

<p>这样的服务可能需要一个密码，访问时需带着此密码，但如果用密码，要改密码时，就会很不方便，所有的消费方都要改，所以动态生成令牌(Token)可能会更好，提供方将令牌告之注册中心，由注册中心决定是否告之消费方，这样就能在注册中心页面上做复杂的授权模型。</p>

<h4 id="toc_6">(7) 就算是不敏感的服务，也不是能任意调用，比如某服务突然多了一个消费者，这个消费者的请求量直接把服务给拖跨了，其它消费者跟着一起故障。</h4>

<p>首先服务提供方需要流控，当流程超标时，能拒绝部分请求，进行自我保护。</p>

<p>其次，消费者上线前和提供者约定《服务质量等级协定(SLA)》，SLA包括消费者承诺每天调用量，请求数据量，提供方承诺响应时间，出错率等，将SLA记录在监控中心，定时与监控数据对比，超标则报警。</p>

<p>(6)、(7)可通过路由扩展加入自己的复杂授权实现，黑/白名单+调用栈可实现某服务接口可调用其他服务接口的授权判断</p>

<h4 id="toc_7">(8) 虽然有SLA约定，如果不能控制，就只是君子协定，如何确保服务质量？</h4>

<p>比如：一个应用很重要，一个不那么重要，它们调用同一个服务，这个服务就应该向重要应用倾斜，而不是一视同仁，当支撑不住时，应限制不重要应用的访问，保障重要应用的可用，如何做到这一点呢。这时，就需要服务路由，控制不同应用访问不同机器，比如：<br/>
应用分离：<br/>
* consumer.application = foo =&gt; provider.host = 1,2,3<br/>
* consumer.application != foo =&gt; provider.host = 5,6<br/>
读写分离：<br/>
* method.name = find<em>,get</em> =&gt; provider.host = 1,2,3<br/>
* method.name != find<em>,get</em> =&gt; provider.host = 5,6</p>

<h4 id="toc_8">(9) 服务上线后，需要验证服务是否可用，但因防火墙的限制，线下是不能访问线上服务的，不得不先写好一个测试Main，然后放到线上去执行，非常麻烦，并且容易忘记验证。</h4>

<p>所以线上需要有一个自动运行的验证程序，用户只需在界面上填上要验证的服务方法，以及参数值和期望的返回值，当有一个服务提供者上线时，将自动运行该用例，并将运行结果发邮件通知负责人。</p>

<h4 id="toc_9">(10) 服务应用和Web应用是有区别的，它是一个后台Daemon程序，不需要Tomcat之类的Web容器。但因公司之前以Web应用为主，规范都是按Web应用的，所以不得不把服务跑在一个根本用不上的Web容器里，而搭一个这样的Web工程也非常费事。</h4>

<p>所以需要实现一个非Web的容器，只需简单的Main加载Spring配置即可，并提供Maven模板工程，只需mvn dubbo:generate 即可创建一个五脏俱全的服务应用。</p>

<h4 id="toc_10">(11) 开发服务的人越来越多，更注重开发效率，IDE的集成支持必不可少。</h4>

<p>通过插件，可以在Eclipse中直接运行服务，提供方可以直接填入测试数据测试服务，消费方可以直接Mock服务不依赖提供方开发。</p>

<h4 id="toc_11">(12) 因为暴露服务很简单，服务的上线越来越随意，有时候负责服务化的架构师都不知道有人上线了某个服务，使得线上服务鱼龙混杂，甚至出现重复的服务，而服务下线比上线还困难。</h4>

<p>需要一个新服务上线审批流程，必须经过服务化的架构师审批过了，才可以上线。</p>

<p>而服务下线时，应先标识为过时，然后通知调用方尽快修改调用，直到没有人调此服务，才能下线。</p>

<h4 id="toc_12">(13) 因服务接口设计的经验一直在慢慢的积累过程中，很多接口并不能一促而蹴，在修改的过程中，如何保证兼容性，怎么判断是否兼容？另外，更深层次的，业务行为兼容吗？</h4>

<p>可以根据使用的协议类型，分析接口及领域模型的变更是否兼容，比如：对比加减字段，方法签名等。</p>

<p>而业务上，可能需要基于自动回归测试用例，形成Technology Compatibility Kit (TCK)，确保兼容升级。</p>

<h4 id="toc_13">(14) 随着服务的不停升级，总有些意想不到的事发生，比如cache写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？</h4>

<p>应用间声明依赖强度，哪些功能强依赖，哪些弱依赖，然后基于依赖强度，计算出影响面，并定期测试复查，加强关键路径上的服务的优化和容错，清理不该在关键路径上的服务。</p>

<p>提供容错Mock数据，Mock数据也应可以在注册中心在运行时动态下发，当某服务不可用时，用Mock数据代替，可以减少故障的发生，比如某验权服务，当验权服务全部挂掉后，直接返回false表示没有权限，并打印Error日志报警。</p>

<p>另外，前端的页面也应采用Portal进行降级，当该Portal获取不到数据时，直接隐藏，或替换为其它模块展示，并提供功能开关，可人工干预是否展示，或限制多少流量可以展示。</p>

<h4 id="toc_14">(15) 当已有很多小服务，可能就需要组合多个小服务的大服务，为此，不得不增加一个中间层，暴露一个新服务，里面分别调其它小服务，这样的新服务业务逻辑少，却带来很多开发工作量。</h4>

<p>此时，需要一个服务编排引擎，内置简单的流程引擎，只需用XML或DSL声明如何聚合服务，注册中心可以直接下发给消费者执行聚合逻辑，或者部署通用的编排服务器，所有请求有编排服务器转发。</p>

<h4 id="toc_15">(16) 并不是所有服务的访问量都大，很多的服务都只有一丁点访问量，却需要部署两台提供服务的机器，进行HA互备，如何减少浪费的机器。</h4>

<p>此时可能需要让服务容器支持在一台机器上部署多个应用，可以用多JVM隔离，也可以用ClassLoader隔离。</p>

<h4 id="toc_16">(17) 多个应用如果不是一个团队开发的，部署在一台机器上，很有可以误操作，停掉了别人的服务。</h4>

<p>所以需要实现自动部署，所有的部署都无需人工干扰，最好是一键式部署。</p>

<p>类似 xAE 的 Console*</p>

<h4 id="toc_17">(18) 机器总是的闲时和忙时，或者冗余机器防灾，如何提高机器的利用率？</h4>

<p>即然已经可以自动部署了，那根据监控数据，就可以实现资源调度，根据应用的压力情况，自动添加机器并部署。</p>

<p>如果你的应用是国际化的，有中文站，美国站之类，因为时差，美国站的机器晚上闲的时候，可能正是中文站的白天忙时，可以通过资源调度，分时段自动调配和部署双方应用。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_6.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_4.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2017-01-01-continuous-deployment-at-instagram.html">Instagram 是如何做持续部署的</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-30-life-2016.html">2016 总结 - 工作十小时，休息五分钟</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-28-wechat-small-app.html">张小龙首次公开解读小程序：1月9号上线</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-27-benefits-and-pitfalls-of-micro-service.html">微服务的好处和陷阱</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>