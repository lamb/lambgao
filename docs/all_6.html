
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-10-25-check-list.html">检查表及总结 - 《代码大全》</a></h1>
			<p class="meta"><time datetime="2013-10-25T17:50:23+08:00" 
			pubdate data-updated="true">2013/10/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>为了更好的评估代码写的哪里有问题，我把《代码大全》里核心的部分checklist整理出来了，大家可以大概过一遍，不一定每写完一个程序都要一条一条的去检查，但心里应该有这么一张检查表，在写代码和review代码时自然而然的想起来。</p>

<h3 id="toc_0">设计</h3>

<ul>
<li>设计是否经过多次迭代，并最终决定了最好的一个？</li>
<li>是否同时使用自上而下和自下而上的方法来解决设计问题？</li>
<li>类与类之间的交互关系是否已经设计为最小化？</li>
<li>设计被划分为层次吗？</li>
<li>你对把这一程序分解成为子程序，包和类的方式感到满意吗？</li>
<li>程序是不是易于维护？</li>
<li>设计是否精简？设计出来的每一个部分都绝对必要吗？</li>
<li>整体而言，你的设计是否有助于最小化偶然性和本质性的复杂度吗？</li>
</ul>

<h3 id="toc_1">类的设计</h3>

<ul>
<li>你是否把程序中的类都看做是抽象数据类型了？是否从这个角度评估它们的接口了？</li>
<li>类是否有一个中心目的？</li>
<li>类的命名是否恰当？其名字是否表达了其中新目的？</li>
<li>类的接口是否展现了一致的抽象？</li>
<li>类的接口是否能让人清楚明白的知道如何用它？</li>
<li>类的接口是否抽象，使你能不必顾虑他是如何实现其服务的？你能把类看做黑盒子吗？</li>
<li>类提供的服务是否足够完整，让其它类无需动用其内部数据？</li>
<li>是否已从类中去除无关信息？</li>
<li>是否考虑过把类进一步分解？</li>
<li>在修改类时是否维持了其接口的完整性？</li>
<li>是否把成员的可访问性降到最小？</li>
<li>是否避免暴露类的数据成员？</li>
<li>类是否避免对其使用者，包括其派生类会如何使用它做了假设？</li>
<li>类是否不依赖于其它类？它是松散耦合吗？</li>
<li>继承是否只用来建立一个is a关系？派生类是否遵循了LSP原则。</li>
<li>继承层次是否很浅？</li>
<li>类中是否只有大约七个或者更少的成员？</li>
<li>是否把类直接或者间接调用其他类的子程序的数量减到最少？</li>
<li>类是否在绝对必要时才与其他类写作？</li>
<li>是否在构造函数中初始化了所有的数据成员？</li>
</ul>

<h3 id="toc_2">子程序</h3>

<ul>
<li>创建子程序的理由充分吗？</li>
<li>一个子程序中所有适合单独提出的部分是不是已经被提出到单独的子程序中了？</li>
<li>过程的名字是否用了强烈、清晰的动词加宾语的词组，函数的名字是否描述了其返回值？</li>
<li>子程序的名字是否描述它所作的全部事情？</li>
<li>子程序是否具有强烈的功能上的内聚性？</li>
<li>子程序之间是否有较松散的耦合？子程序与其它子程序之间的连接是否是最小的，明确的，可见的，灵活的？</li>
<li>子程序的长度是否是由其功能和逻辑自然确定，而非遵循任何人为的编码标准？</li>
<li>子程序的参数表是否表现出一种具有整体性且一致的抽象？</li>
<li>子程序参数的排列顺序是否合理？是否与类似的子程序的参数排列相符？</li>
<li>接口假定是否在文档中说明？</li>
<li>子程序的参数是否没有超过7个？</li>
<li>是否用到了每一个输入参数，是否用到了每一个输出参数？</li>
<li>子程序是否避免了把输入参数用作工作变量？</li>
<li>如果子程序是一个函数，那么它是否在所有可能的情况下都能返回一个合法的值？</li>
</ul>

<h3 id="toc_3">防御式编程</h3>

<ul>
<li>子程序是否保护自己免遭有害输入数据的破坏？</li>
<li>你用断言来说明编程假定吗？其中包括了前条件和后条件了吗？</li>
<li>断言是否只说明从来不应该发生的情况？</li>
<li>你是否在架构或者高层设计中规定了一组特定的错误处理技术？</li>
<li>你是否在架构或者高层设计中规定了是让错误处理更倾向于健壮性还是正确性？</li>
<li>代码中用到辅助调试的代码了吗？</li>
<li>在防御式编程时引入的代码量是否适宜，既不过多也不过少？</li>
<li>你在项目中定义了一套标准化的异常处理方案吗？</li>
<li>如果可能的话，是否在局部处理了错误而不是把它当成一个异常跑出去？</li>
<li>所有异常是否都与抛出他们的子程序在同一抽象层次上？</li>
<li>每个异常是否包含了关于异常发生的所有背景信息？</li>
<li>代码中是否没有空的catch语句？</li>
<li>检查有害输入数据的代码是否也检查了故意的缓冲区溢出，SQL注入，HTML注入，整数溢出及其他恶意输入数据？</li>
<li>是否检查了所有的错误返回码？</li>
<li>是否捕获了所有的异常？</li>
<li>出错消息中是否避免出现有助于攻击者攻入系统所需的信息？</li>
</ul>

<h3 id="toc_4">伪代码</h3>

<ul>
<li>是否检查过已满足所有的先决条件？</li>
<li>定义好这个类要解决的问题了吗？</li>
<li>高层次的设计是否清晰？能给这个类和其中的每个子程序起一个好的名字吗？</li>
<li>考虑过该如何测试这个类及其中的每个子程序吗？</li>
<li>关于效率的问题，你主要从稳定的接口和可读的实现这两个角度考虑吗？还是主要从满足资源和速度的预期目标的角度考虑过呢？</li>
<li>从标准库函数和其它代码库中寻找过可用的子程序或者组件吗？</li>
<li>从参考书中查过有用的算法了吗？</li>
<li>是否用详尽的伪代码设计好每一个子程序？</li>
<li>你在脑海里检查过伪代码吗？这些伪代码容易理解吗？</li>
<li>关注过那些可能让你重返设计的警告信息了吗？</li>
<li>是否把伪代码正确的翻译成代码了？</li>
<li>你反复使用伪代码编程过程了吗？</li>
<li>在做出假定的时候有没有对它们加以说明？</li>
<li>已经删除了那些冗余的注释了吗？</li>
<li>你是否采取了几次迭代中最好的那个结果？还是在第一次迭代之后就停止了？</li>
<li>你完全理解你的代码了吗？这些代码是否容易理解？</li>
</ul>

<h3 id="toc_5">变量</h3>

<ul>
<li>变量声明位置靠近变量第一次使用的位置吗？</li>
<li>尽可能在变量声明的同时初始化变量吗？</li>
<li>计数器和累加器经过适当初始化了吗？如果需要再一次使用，之前重新初始化了吗？</li>
<li>适当的重新初始化“需要重复执行的代码里的变量”了吗？</li>
<li>代码在通过编译器编译的时候是不是没有警告信息？你启用了所有可用的警告信息了吗？</li>
<li>如果语言允许隐式声明，你为由此可能引发的问题做好补偿措施了吗？</li>
<li>如果可能，所有变量都被定义为具有最小的作用域吗？</li>
<li>各变量的引用点都尽可能集中在一起吗？对同一个变量的两次相邻引用，或者变量的整个生命期都这样做了吗？</li>
<li>控制结构符合数据类型吗？</li>
<li>所有声明的变量都用了吗？</li>
<li>变量都在合适的时间绑定了吗？也就是说你有意识的在晚期绑定所带来的灵活性和增加复杂度之间做出平衡了吗？</li>
<li>每个变量都有且仅有一项用途吗？</li>
<li>每个变量的含义都很明确且没有隐含含义吗？</li>
</ul>

<h3 id="toc_6">变量命名</h3>

<ul>
<li>名字完整并且准确的表达了变量所代表的含义吗？</li>
<li>名字足够长，可以让你无需苦苦思索吗？</li>
<li>如果有计算限定符，它被放在名字后面吗？</li>
<li>名字中用Count或者index来掉提Num了吗？</li>
<li>循环小标的名字有意义吗？</li>
<li>所有临时的变量都重新命名为更有意义的名字了吗？</li>
<li>当布尔变量为真时，变量能准确表达其含义吗？</li>
<li>枚举中的名字含有能够表示其类别的前缀或者后缀吗？</li>
<li>具名常量是根据它所代表的抽象实体儿不是它所代表的数字来命名的吗？</li>
<li>命名规则能够区分局部数据，类的数据和全局数据吗？</li>
<li>规则能够区分类型名，具名常量，枚举类型和变量名吗？</li>
<li>规则能够在编译器不强制检测只读参数的语言里表示出子程序的输入参数吗？</li>
<li>规则能尽可能地与语言的标准规则兼容吗？</li>
<li>名字为可读性而加以格式化了吗？</li>
<li>是否避免只为了省一个字符而缩写的情况？</li>
<li>所有单词的缩写方式都一致吗？</li>
<li>名字能够读出来吗？</li>
<li>避免使用容易被看错和读错的名字吗？</li>
<li>在缩写对照表里对端名字做出说明了吗？</li>
</ul>

<h3 id="toc_7">基本数据类型</h3>

<ul>
<li>代码中避免使用神秘数值了吗？</li>
<li>代码考虑了除零错误了吗？</li>
<li>类型转换很明显吗？</li>
<li>如果一条语句中存在两个不同类型的变量，那么这条语句会像你期望的那样求值吗？</li>
<li>代码避免了混合类型比较吗？</li>
<li>使用整数除法表达式能按预期的那样工作吗？</li>
<li>整数表达式避免整数溢出问题了吗？</li>
<li>代码避免了对数量级相差具体大浮点数做加减运算了吗？</li>
<li>代码系统地阻止了舍入错误的发生吗？</li>
<li>代码避免对浮点数值做等量比较了吗？</li>
<li>代码避免使用神秘字符和字符串了吗？</li>
<li>使用字符串时避免了off-bye-one错误了吗？</li>
<li>程序用额外的布尔变量来说明条件判断了吗？</li>
<li>程序用额外的布尔变量来简化条件判断了吗？</li>
<li>程序用枚举类型而非具名常量来提高可读性和可修改行了吗？</li>
<li>当变量不能用true和false表示的时候，程序用枚举类型来取代布尔变量了吗？</li>
<li>针对枚举类型的才测试检测了非法数值了吗？</li>
<li>把枚举类型的第一项条目保留为“非法的”了吗？</li>
<li>具名常量使用一致吗？没有在某些位置使用具名常量又在其他位置使用文字量？</li>
<li>所有的数组下标都没有超出数组边界吗？</li>
<li>数组引用没有出现off-by-one的错误吗？</li>
<li>所有的多维数组的下标顺序都正确吗？</li>
<li>在嵌套循环里，把正确的变量用于数组下标来避免下标错乱吗？</li>
</ul>

<h3 id="toc_8">不常见的数据类型</h3>

<ul>
<li>你使用结构体而不是使用单纯的变量来组织和操作相关的数据吗？</li>
<li>你考虑过创建一个类来代替使用结构体吗？</li>
<li>所有的变量是否都是局部或者是类范围的？除非绝对有必要才是全局的？</li>
<li>你对所有的全局变量都加以文档说明吗？</li>
<li>避免使用伪全局数据，即被四处传递且含有杂乱数据的的巨大对象吗？</li>
<li>用访问器子程序来取代全局数据了吗？</li>
<li>把访问其子程序和数据组织到类里了吗？</li>
<li>访问器子程序提供了一个在底层数据类型实现之上的抽象层吗？</li>
<li>所有相关的访问器子程序都位于同一抽象层吗？</li>
<li>把指针操作隔离在子程序里了吗？</li>
<li>指针引用合法吗？或者指针有可能成为悬空指针吗？</li>
<li>代码在使用指针之前检查它的有效性了吗？</li>
<li>在使用指针所指向的变量之前检查其有效性了吗？</li>
<li>指针用完后被设置为空了吗？</li>
<li>就可读性而言，代码用了所有需要使用的指针变量了吗？</li>
<li>链表中的指针是按正确的顺序加以释放的吗？</li>
<li>程序分配了一片保留的内存后备区域，以便在耗尽内存的时候能够优雅地退出吗？</li>
<li>是不是在没有其他方法可用的情况下最终才使用指针的？</li>
</ul>

<h3 id="toc_9">组织直线型代码</h3>

<ul>
<li>代码使得语句之间的依赖关系变得明显吗？</li>
<li>子程序的名字使得依赖关系变得明显吗？</li>
<li>子程序的参数使得依赖关系变得明显吗？</li>
<li>如果依赖关系不明确，你是否用注释进行了说明？</li>
<li>你用“内务管理变量”来检查代码中关键位置的顺序依赖关系了吗？</li>
<li>代码容易按照自上而下的顺序阅读吗？</li>
<li>相关的语句组织在一起吗？</li>
<li>把相对独立的语句组放进各自的子程序里吗？</li>
</ul>

<h3 id="toc_10">使用条件语句</h3>

<ul>
<li>代码的正常路径清晰吗？</li>
<li>if-then测试对等量分支的处理方式正确吗？</li>
<li>使用了else字句并加以说明了吗？</li>
<li>else字句用的对吗？</li>
<li>用对了if和else字句，即没有把它们用反吗？</li>
<li>需要执行的正常情况维护if而不是else字句里吗？</li>
<li>if-then-else-if把复杂的判断封装到布尔函数里了吗？</li>
<li>if-then-else-if先判断最常见的情况了吗？</li>
<li>if-then-else-if判断包含所有的情况吗？</li>
<li>if-then-else-if是最佳的实现吗？比Case语句还要好吗？</li>
<li>case子句排序的有意义吗？</li>
<li>case子句的每种情况操作简单吗？必要的时候调用了其它子程序了吗？</li>
<li>case语句检测的是一个真实的变量，而不是为了滥用case语句而而刻意制造变量吗？</li>
<li>默认字句用的合法吗？</li>
<li>用默认字句来检测和报告意料之外的情况了吗？</li>
<li>在c,c++和java里，每一个case的末尾有一个break吗？</li>
</ul>

<h3 id="toc_11">循环</h3>

<ul>
<li>在合适的情况下用while循环取代for循环了吗？</li>
<li>循环是由内到外创建的吗？</li>
<li>是从循环的头部进入循环的吗？</li>
<li>初始化代码是直接位于循环前面吗？</li>
<li>循环是无限循环或者事件循环吗？阿德结构是否清晰？</li>
<li>避免使用像for i = 1 to 9999这样的代码吗？</li>
<li>如果这是一个c++,c或java中的for循环，那么把循环头留给循环控制代码了吗？</li>
<li>循环使用了{}及其等价物来括上循环体，以防止因修改不当而出错吗？</li>
<li>循环体内有内容吗？他是非空的吗？</li>
<li>把内务处理集中地放在循环开始或者循环结束处了吗？</li>
<li>循环像定义良好的子程序那样只执行一件操作吗？</li>
<li>循环短的足以一目了然吗？</li>
<li>循环的嵌套层次不多于3层吗？</li>
<li>把长循环的内容提取成单独的子程序吗？</li>
<li>如果循环很长，那么它非常清晰吗？</li>
<li>如果这是一个for循环，那么其中的代码有没有随意修改循环下标值？</li>
<li>是否把重要的循环下标值保存在另外的变量里，而不是在循环体外使用该循环下标？</li>
<li>循环下标是序数类型或者枚举类型，而不是浮点类型吗?</li>
<li>循环下标的名字有意义吗？</li>
<li>循环避免了下标串话问题吗？</li>
<li>循环是在所有可能的条件下都能终止吗？</li>
<li>如果建立了某种安全计数器标准，循环使用了安全计数器了吗？</li>
<li>循环的退出条件清晰吗？</li>
<li>如果使用了break或者continue，那么它们用对了吗？</li>
<li>不常见的控制结构</li>
<li>每一个子程序都仅在有必要的时候才使用return吗？</li>
<li>使用return有助于增强可读性吗？</li>
<li>递归子程序中包含了停止递归的代码吗？</li>
<li>子程序用安全计数器来确保子程序能停下来吗？</li>
<li>递归只位于一个子程序里面吗？</li>
<li>子程序递归深度处于程序栈容量可以满足的限度内吗？</li>
<li>递归是实现子程序的最佳方法吗？它要好于简单的迭代吗？</li>
<li>是否在万不得已的时候才使用goto？如果用了goto，是否仅仅处于增强可读性和可维护性呢？</li>
<li>如果处于效率因素而使用的goto，那么对这种效率上的提升做出衡量并且加以说明了吗？</li>
<li>一个子程序里最多只用了一个goto标号吗？</li>
<li>所有的goto都向前跳转，而不是向后跳转吗？</li>
<li>所有的goto标号都用到了吗？</li>
</ul>

<h3 id="toc_12">表驱动法</h3>

<ul>
<li>你考虑过把表驱动法作为复杂逻辑的替代方案吗？</li>
<li>你考虑过把表驱动法作为复杂继承结构的替代方案吗？</li>
<li>你考虑过把表数据存储在外部并在运行期间读入，以便在不修改代码的情况下就可以改变这些数据吗？</li>
<li>如果无法用一种简单的数组索引去访问表，那么你把机酸访问键值的功能提取成单独的子程序，而不是在代码中重复地计算键值吗？</li>
</ul>

<h3 id="toc_13">一般控制问题</h3>

<ul>
<li>表达式中用的是true和false，而不是1和0吗？</li>
<li>布尔值和true以及false做比较是隐式进行的吗？</li>
<li>对数值做比较是显式进行的吗？</li>
<li>有没有通过增加新的布尔变量，使用布尔函数和决策表来简化表达式？</li>
<li>布尔表达式是用肯定形式表达的吗？</li>
<li>括号配对吗？</li>
<li>在需要括号来明确的地方都使用括号了吗</li>
<li>判断是按照数轴顺序编写了吗？</li>
<li>如果适当的话，java中的判断用的是a.equals(b)方式，而没有用a==b方式吗？</li>
<li>空语句表述得明显吗？</li>
<li>用重新判断部分条件，转换成if-then-else或者case语句、把嵌套代码提取成单独的子程序、换成一种更面向对象的设计或者其他的改进方法来简化嵌套语句了吗？</li>
<li>如果一个子程序的决策点超过10个，那么能提出不重新设计的理由吗？</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-10-12-activemq-optmization.html">ActiveMQ 优化</a></h1>
			<p class="meta"><time datetime="2013-10-12T17:55:10+08:00" 
			pubdate data-updated="true">2013/10/12</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">1. 启用 NIO Transport Connector</h3>

<pre><code>&lt;transportConnectors&gt;
   &lt;transportConnector name=&quot;nio&quot; uri=&quot;nio://localhost:62828&quot;/&gt;
&lt;/transportConnectors&gt;
</code></pre>

<p>客户端也需要改为 nio。</p>

<h3 id="toc_1">2. 目标策略</h3>

<pre><code>&lt;destinationPolicy&gt;
 &lt;policyMap&gt;
  &lt;policyEntries&gt;
   &lt;policyEntry queue=&quot;&gt;&quot;
           optimizedDispatch=&quot;true&quot;
           producerFlowControl=&quot;false&quot;
           memoryLimit=&quot;128 mb&quot;&gt;
        &lt;pendingSubscriberPolicy&gt;
          &lt;vmCursor /&gt;
        &lt;/pendingSubscriberPolicy&gt;
   &lt;/policyEntry&gt;
  &lt;/policyEntries&gt;
 &lt;/policyMap&gt;
&lt;/destinationPolicy&gt;
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-09-26-rabbitmq-clustering-ha.html">RabbitMQ 集群与高可用配置</a></h1>
			<p class="meta"><time datetime="2013-09-26T17:36:16+08:00" 
			pubdate data-updated="true">2013/9/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">集群概述</h3>

<p>通过 Erlang 的分布式特性（通过 magic cookie 认证节点）进行 RabbitMQ 集群，各 RabbitMQ 服务为对等节点，即每个节点都提供服务给客户端连接，进行消息发送与接收。</p>

<p>这些节点通过 RabbitMQ HA 队列（镜像队列）进行消息队列结构复制。本方案中搭建 3 个节点，并且都是磁盘节点（所有节点状态保持一致，节点完全对等），只要有任何一个节点能够工作，RabbitMQ 集群对外就能提供服务。</p>

<h3 id="toc_1">环境</h3>

<ul>
<li>CentOS 6.4，64位</li>
<li>RabbitMQ 3.1.5</li>
<li>HAProxy 1.4.22</li>
</ul>

<p>RabbitMQ 集群安装在 3 个节点上：192.168.1.1、192.168.1.2、192.168.1.3；<br/>
HAProxy 安装在 192.168.1.4 上，用于对外提供 RabbitMQ 均衡。</p>

<p>所需安装包<a href="http://www.rabbitmq.com/download.html">下载</a>。</p>

<h3 id="toc_2">配置步骤</h3>

<ol>
<li>安装 erlang、rabbitmq
在 192.168.1.1、192.168.1.2、192.168.1.3 三个节点上安装，然后开启 RabbitMQ 监控插件：
<code>
rabbitmq-plugins enable rabbitmq_management
</code></li>
<li>修改 /etc/hosts
加入集群 3 个节点的描述：</li>
</ol>

<pre><code>192.168.1.1 node1
192.168.1.2 node2
192.168.1.3 node3
</code></pre>

<ol>
<li>设置 Erlang Cookie
Erlang Cookie 文件：/var/lib/rabbitmq/.erlang.cookie。这里将 node1 的该文件复制到 node2、node3，由于这个文件权限是 400，所以需要先修改 node2、node3 中的该文件权限为 777：</li>
</ol>

<pre><code># chmod 777 /var/lib/rabbitmq/.erlang.cookie
</code></pre>

<p>然后将 node1 中的该文件拷贝到 node2、node3，最后将权限和所属用户/组修改回来：</p>

<pre><code># chmod 400 /var/lib/rabbitmq/.erlang.cookie
# chown rabbitmq /var/lib/rabbitmq/.erlang.cookie
# chgrp rabbitmq /var/lib/rabbitmq/.erlang.cookie
</code></pre>

<ol>
<li>使用 -detached 参数运行各节点</li>
</ol>

<pre><code># rabbitmqctl stop
# rabbitmq-server -detached
</code></pre>

<ol>
<li>组成集群
将 node2、node3 与 node1 组成集群：</li>
</ol>

<pre><code>node2 # rabbitmqctl stop_app 
node2 # rabbitmqctl join_cluster rabbit@node1
node2 # rabbitmqctl start_app
  
node3 # rabbitmqctl stop_app 
node3 # rabbitmqctl join_cluster rabbit@node1
node3 # rabbitmqctl start_app
</code></pre>

<p>此时 node2 与 node3 也会自动建立连接；如果要使用内存节点，则可以使用<br/>
node2 # rabbitmqctl join_cluster --ram rabbit@node1 加入集群。</p>

<p>集群配置好后，可以在 RabbitMQ 任意节点上执行 rabbitmqctl cluster_status 来查看是否集群配置成功。</p>

<ol>
<li>设置镜像队列策略
在任意一个节点上执行：</li>
</ol>

<pre><code># rabbitmqctl set_policy ha-all &quot;^&quot; &#39;{&quot;ha-mode&quot;:&quot;all&quot;}&#39;
</code></pre>

<p>将所有队列设置为镜像队列，即队列会被复制到各个节点，各个节点状态保持一直。</p>

<p>完成这 6 个步骤后，RabbitMQ 高可用集群就已经搭建好了，最后一个步骤就是搭建均衡器。</p>

<ol>
<li>安装并配置 HAProxy
在 192.168.1.4 上安装 HAProxy，然后修改 /etc/haproxy/haproxy.cfg：</li>
</ol>

<pre><code>listen rabbitmq_cluster 0.0.0.0:5672
 
mode tcp
balance roundrobin
 
server   node1 192.168.1.1:5672 check inter 2000 rise 2 fall 3  
server   node2 192.168.1.2:5672 check inter 2000 rise 2 fall 3
server   node2 192.168.1.3:5672 check inter 2000 rise 2 fall 3
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-08-13-quartz-quick-start.html">Quartz快速入门</a></h1>
			<p class="meta"><time datetime="2013-08-13T17:08:17+08:00" 
			pubdate data-updated="true">2013/8/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">下载和安装</h3>

<p>首先，下载最近的最稳定的<a href="http://quartz-scheduler.org/downloads/">版本</a>，可以跳过注册画面。解压缩安装，这样你的应用程序可以使用Quartz。</p>

<h3 id="toc_1">Quartz Jar文件</h3>

<p>Quartz包中有很多jar，在根目录中。最主要的一个库叫作quartz-all-xxx.jar(xxx是版本号)。为了使用Quartz，你需要把这个jar放在你应用程序的classpath里。</p>

<p>你下载完之后，解压缩包，将quartz-all-xxx.jar这个文件取出来，放到任何你喜欢的地方。</p>

<p>因为我主要将Quartz用在应用服务器的环境中，所以我希望将Quartz jar放在我的程序中(也就是.ear或者.war中)。然而，如果希望多个应用都能使用Quartz，那么就放在你的应用服务器的classpath下吧。如果你只希望有一个独立的应用，那么就放在这个应用的classpath中，和其他的jar放在一起。</p>

<p>Quartz需要依赖很多第三方的库(以jar的形式)，这些jar都放在了lib目录下，要使用所有的功能的话，你需要将所有的jar都放在classpath中。而如果你是建立一个独立的应用，建议你将所有的jar都放在classpath下。但若是在应用服务器的环境下，你可能已经包含其中某些jar了，这时就需要你进行取舍了，确定将什么版本的jar放到classpath下。</p>

<p>在应用服务器的环境下，你需要注意可能会有一些奇怪的结果，是由于你包含了同一个jar的不同版本。例如，Weblogic包含了J2EE的实现，但是不同于servlet.jar。所以，你最好将servlet.jar从classpath中移出来，以便知道真正用到了哪些类。</p>

<h3 id="toc_2">Properties文件</h3>

<p>Quartz使用quartz.properties作为配置文件。你需要进行一些基本的配置，并将其放入classpath下。</p>

<p>再说一次，还是看你是什么环境。我个人而言用WebLogic，所以我将所有的配置文件(包括quartz.properties)放在应用程序根文件夹下。当我将所有的程序都打包到.ear时，这些配置文件都打包到.jar文件里，并包含在最后的.ear文件中。这将自动将quartz.properties文件包含在classpath下。</p>

<p>如果你的应用是.war，那么你可能要将quartz.properties放在WEB-INF/classes文件架下。</p>

<h3 id="toc_3">配置Quartz</h3>

<p>配置是最重要的部分。Quartz是一个配置性很强的应用，最好的配置方法就是修改quartz.properties。</p>

<p>在解压缩包里已经含有了一些配置文件的范例，你可以查看examples/ 文件夹。不过我建议你创建你自己的quartz.properties，而不是直接拷贝范例文件然后删掉你不要的配置。创建你自己的配置文件能让你学到更多的东西.</p>

<p>查看所有有关配置的文档，请查看<a href="http://quartz-scheduler.org/documentation/quartz-2.1.x/configuration">Quartz配置参考文档</a>。</p>

<p>最基本的配置文件quartz.properties如下：</p>

<pre><code>org.quartz.scheduler.instanceName = MyScheduler
org.quartz.threadPool.threadCount = 3
org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore
</code></pre>

<p>这个配置有如下含义：</p>

<ul>
<li>org.quartz.scheduler.instanceName – 调度器的名字是”MyScheduler”。</li>
<li>org.quartz.threadPool.threadCount – 在线程池中有三个线程。这就意味着最多有3个job可以同时运行。</li>
<li>org.quartz.jobStore.class – 所有的Quartz的数据保存在内存中（而不是数据库中）。尽管可能你有数据库，并且希望配合Quartz一起使用。但我仍旧建议你首先使用RAMJobStore，再去接触数据库。</li>
</ul>

<h3 id="toc_4">启动一个示例程序</h3>

<p>现在是时候启动程序了。下面的代码包含了一个调度器，首先启动它，然后关闭它。</p>

<p>QuartzTest.java：</p>

<pre><code>import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.impl.StdSchedulerFactory;
import static org.quartz.JobBuilder.*;
import static org.quartz.TriggerBuilder.*;
import static org.quartz.SimpleScheduleBuilder.*;
 
public class QuartzTest {
 
    public static void main(String[] args) {
 
        try {
            // Grab the Scheduler instance from the Factory 
            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();
 
            // and start it off
            scheduler.start();
 
            scheduler.shutdown();
 
        } catch (SchedulerException se) {
            se.printStackTrace();
        }
    }
}
</code></pre>

<p>一旦你通过StdSchedulerFactory.getDefaultScheduler()获得了一个调度器,你的程序会一直运行，直到调用scheduler.shutdown()方法。</p>

<p>注意还有一些import static ...，下面的代码你会见到它们的作用。</p>

<p>如果你没有设置好logging输出日志，所有的日志都回输出到控制台，可能如下：</p>

<pre><code>[INFO] 21 Jan 08:46:27.857 AM main [org.quartz.core.QuartzScheduler]
Quartz Scheduler v.2.0.0-SNAPSHOT created.
 
[INFO] 21 Jan 08:46:27.859 AM main [org.quartz.simpl.RAMJobStore]
RAMJobStore initialized.
 
[INFO] 21 Jan 08:46:27.865 AM main [org.quartz.core.QuartzScheduler]
Scheduler meta-data: Quartz Scheduler (v2.0.0) &#39;Scheduler&#39; with instanceId &#39;NON_CLUSTERED&#39;
  Scheduler class: &#39;org.quartz.core.QuartzScheduler&#39; - running locally.
  NOT STARTED.
  Currently in standby mode.
  Number of jobs executed: 0
  Using thread pool &#39;org.quartz.simpl.SimpleThreadPool&#39; - with 50 threads.
  Using job-store &#39;org.quartz.simpl.RAMJobStore&#39; - which does not support persistence. and is not clustered.
 
[INFO] 21 Jan 08:46:27.865 AM main [org.quartz.impl.StdSchedulerFactory]
Quartz scheduler &#39;Scheduler&#39; initialized from default resource file in Quartz package: &#39;quartz.properties&#39;
 
[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.impl.StdSchedulerFactory]
Quartz scheduler version: 2.0.0
 
[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.core.QuartzScheduler]
Scheduler Scheduler_$_NON_CLUSTERED started.
 
[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.core.QuartzScheduler]
Scheduler Scheduler_$_NON_CLUSTERED shutting down.
 
[INFO] 21 Jan 08:46:27.866 AM main [org.quartz.core.QuartzScheduler]
Scheduler Scheduler_$_NON_CLUSTERED paused.
 
[INFO] 21 Jan 08:46:27.867 AM main [org.quartz.core.QuartzScheduler]
Scheduler Scheduler_$_NON_CLUSTERED shutdown complete.
</code></pre>

<p>你可以在start()和shutdown()之间添加你想要完成的工作。</p>

<pre><code>// define the job and tie it to our HelloJob class
JobDetail job = newJob(HelloJob.class)
    .withIdentity(&quot;job1&quot;, &quot;group1&quot;)
    .build();
 
// Trigger the job to run now, and then repeat every 40 seconds
Trigger trigger = newTrigger()
    .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
    .startNow()
    .withSchedule(simpleSchedule()
            .withIntervalInSeconds(40)
            .repeatForever())            
    .build();
 
// Tell quartz to schedule the job using our trigger
scheduler.scheduleJob(job, trigger);
</code></pre>

<p>（也许你需要在调用shutdown()之前一段时间，以便job可以被顺利触发和执行。例如，你可以增加一行代码Thread.sleep(60000)）。</p>

<p>现在执行它吧。</p>

<p>英文原文： <a href="http://quartz-scheduler.org/overview/quick-start">Quartz Scheduler</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-07-29-android-simulator-genymotion.html">快到极致的Android模拟器——Genymotion</a></h1>
			<p class="meta"><time datetime="2013-07-29T18:02:45+08:00" 
			pubdate data-updated="true">2013/7/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>还在用Android原生模拟器？向你推荐一款全方位把Android原生模拟器秒成渣渣的神器：<a href="http://www.genymotion.com/">Genymotion</a>！</p>

<h3 id="toc_0">需要理由？</h3>

<ul>
<li>性能卓越作为历史上最快的Android模拟器（没有之一），秒级开机关机速度足够让你膜拜了（粗略估计5-20s不等），Android模拟器应该是1min起吧（如果你够幸运的话）？ 此外，堪比真机的操作体验实在让人欲罢不能（希望你的真机性能足够卓越，不然在Genymotion面前，一切都是浮云）！</li>
<li>返璞归真傻瓜式安装，易于使用，将复杂的技术隐藏于VitualBox、HardWare OpenGL等驱动引擎中。</li>
<li>完美仿真支持绝大部分的模拟器功能与感应器，甚至支持语音、NFC、蓝牙等等…作为Beta版，初出茅庐的Genymotion就坐拥数十万忠实粉丝，其中包括一些知名度极高的业内人士。在Genymotion团队的蓝图中，它将与开发测试完美的契合在一起。截至7月1日，Genymotion的功能已经足够应付开发的需求，胜任测试开发调试等工作。同时它兼容各大系统，提供Eclipse、IntelliJ插件，周到之极，实在是提高生产力的必备神器。然而可惜的是，99.9%墙内的群众却还不知情，Baidu、Google相关中文词条，得到的搜索结果却全是英文。诸君奔走相告吧，将那些受挟或鄙视android模拟器的穷苦屌丝从苦海中拯救出来吧！Android名人Cyril Mottier在博客中强烈推荐将Genmotion，以提高开发者的生产力。在Twitter上，一些Andriod名人对Genymotion赞美之词溢于言表：</li>
<li>If you’re like me, an iOS user with a growing Android curiosity, AndroVM is an awesome up-to-date VirtualBox package. – Kristian F. a Curious Android user</li>
<li>Developing Android apps with AndroVM is fast! Almost as convenient as developing an iOS app ! Richard L. – Android developer</li>
<li>AndroVM, is an awesomely easy way to run the latest version of Android in VirtualBox. Ross S. – Application tester
然而，在一片欢呼声中，总有一小部分反对的声音，比如下面这位：</li>
</ul>

<p>Genymotion太快了，快得一点美感也没有。- 瑞安 未来的Android名人</p>

<p>简易安装教程</p>

<ol>
<li><a href="http://www.genymotion.com/">注册Genymotion账号</a></li>
<li><a href="https://cloud.genymotion.com/page/launchpad/download/">下载Genymotion安装包</a></li>
<li><a href="https://www.virtualbox.org/wiki/Downloads">安装VitualBox</a></li>
<li><a href="https://cloud.genymotion.com/page/launchpad/download/">安装Eclipse或者Intellij插件</a></li>
<li>快速体验</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-07-19-jpa-and-cmt-why-catching-persistence-exception-is-not-enough.html">JPA与CMT – 为什么单纯捕捉持久化异常是不够的？</a></h1>
			<p class="meta"><time datetime="2013-07-19T17:02:55+08:00" 
			pubdate data-updated="true">2013/7/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在EJB和JPA架构中使用CMT（容器控制事务）是很简单的。只要定义一些注解来标示事务边界（或使用默认），无需再手动使用开始、提交或回滚操作。在EJB的业务方法中唯一回滚事务的方法就是抛出非应用异常（或者使用rollback=true标注应用异常）。看起来很简单：如果在某些操作中有可能会抛出一个异常，但你不希望事务回滚只需要捕获异常就可以了。你能够在同一个仍然活动的事务中再次重试这个不稳定的操作。</p>

<p>对于用户组件抛出的应用异常来说是完全成立的。问题是从其他组件抛出的异常会怎么样？比如JPA的EntityManager抛出的一个PersistenceException？这就是撰写本文的原因。</p>

<h3 id="toc_0">我们想要实现什么</h3>

<p>想象一下如下场景：你有一个名为E的实体。包括如下属性：</p>

<ul>
<li>id–主键,</li>
<li>name– 可读的实体名称,</li>
<li>content– 一些存放字符串的随意字段 – 用于模拟“高级属性”例如在持久化/更新时计算的字段并且可能导致错误的。</li>
<li>code– 保存OK 或者ERROR字符串 – 定义高级属性是否成功保存。</li>
</ul>

<p>希望持久化E。假设E的基础属性一直都能成功持久化。而高级属性，需要一些附加计算或操作可能会导致例如数据库抛出的违反约束。当这样的情况发生后，你仍然希望E能够持久化到数据库中（只是基础属性填充，code字段设置为ERROR）<br/>
换句话说你可能希望：</p>

<ul>
<li>持久化E的基本属性</li>
<li>尝试更新高级属性</li>
<li>若步骤2中抛出了PersistenceException – 捕获该异常并设置‘code’属性为ERROR并且清除所有高级属性（因为会引发异常）</li>
<li>更新E</li>
</ul>

<h3 id="toc_1">普通解决方案</h3>

<p>在EJB代码中展示你可能会如何执行（假设为默认的事务属性（TransactionAttributes））</p>

<pre><code>public void mergeEntity() {
 MyEntity entity =newMyEntity(&#39;entityName&#39;,&#39;OK&#39;,&#39;DEFAULT&#39;);
 
 em.persist(entity);
 
 // This will raise DB constraint violation
 entity.setContent(&#39;tooLongContentValue&#39;);
 
 // We don&#39;t need em.merge(entity) - our entity is in managed mode.
 
 try{
 em.flush(); // Force the flushing to occur now, not during method commit.
 }catch(PersistenceException e) {
 // Clear the properties to be able to persist the entity.
 entity.setContent(&#39;&#39;);
 entity.setCode(&#39;ERROR&#39;);
 
 // We don&#39;t need em.merge(entity) - our entity is in managed mode.
 }
 }
</code></pre>

<h3 id="toc_2">示例中有什么问题？</h3>

<p>捕获EntityManager 抛出的PersistenceException 不能够阻止事务回滚。这不像不捕捉EJB中的异常会使得事务回滚，而是EntityManager 抛出的非应用程序异常会将事务标记为回滚。更不用说资源内部可能会标记事务为回滚。意味着实际上你的程序并不能真正控制事务的行为。同时，作为事务回滚的结果，我们的实体被转移至游离（detached ）状态。因此，在方法的最后 em.merge(entity)这样的方法还是需要的。</p>

<h3 id="toc_3">有效方案</h3>

<p>该如何应对事务自动回滚呢？因为我们使用CMT，所以我们唯一的方法就是定义另一个业务方法开始一个全新的事务，并且将所有可能导致异常的操作在那里执行。这样的话即使PersistenceException 被抛出（并且捕获）它只会标注当前新事务回滚，我们的主事务是不会有影响的。如下可以看到一些样例代码（为了简洁去除了日志代码）：</p>

<pre><code>public void mergeEntity() {
 
MyEntity entity =newMyEntity(&#39;entityName&#39;,&#39;OK&#39;,&#39;DEFAULT&#39;);
 
em.persist(entity);
 
try{
self.tryMergingEntity(entity);
}catch(UpdateException ex) {
entity.setContent(&#39;&#39;);
entity.setCode(&#39;ERROR&#39;);
}
}
 
@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
public void tryMergingEntity(finalMyEntity entity) throws UpdateException {
entity.setContent(&#39;tooLongContentValue&#39;);
 
em.merge(entity);
 
try{
em.flush();
}catch(PersistenceException e) {
thrownewUpdateException();
}
}
</code></pre>

<p>注意：<br/>
更新异常（UpdateExceptionis ）也是继承自Exception类的应用异常（所以默认是rollback=false）。用于表示更新动作失败。作为一个可选方式，你可以将 tryMergingEntity(-)方法的返回值由void转为boolean。用这个boolean结果来表示更新动作成功与否。</p>

<p>Self在我们的EJB中是对自身的引用。这在EJB容器代理中是一个必须步骤，使得被调用的方法能够使用@TransactionAttribute，作为一个可选方式，可以使用SessionContext#getBusinessObject(clazz).tryMergingEntity(entity).</p>

<p>em.merge(entity) 方法是很关键的。我们在tryMergingEntity(-)方法中开启一个新事务，所以实体不会存在于持久化上下文中。<br/>
方法中无需再有其他的更新或刷新操作了。CMT的常规特性确保了事务不会被回滚，这意味着实体的所有改动都会在事务提交时自动刷新。<br/>
我们再次强调一下底线：捕获异常并不意味着你当前的事务不会被标记为回滚。PersistenceException 并发应用程序异常，但无论是你否捕捉都会导致你的事务回滚。</p>

<h3 id="toc_4">JTA BMT解决方案</h3>

<p>一直以来我们都讨论的是CMT。那JTA BMT呢？找到下面代码中展示如何使用BMT处理这个问题作为奖励吧：</p>

<pre><code>public void mergeEntity() throws Exception {
 utx.begin();
 MyEntity entity =newMyEntity(&#39;entityName&#39;,&#39;OK&#39;,&#39;DEFAULT&#39;);
 em.persist(entity);
utx.commit();
 
 utx.begin();
 entity.setContent(&#39;tooLongContentValue&#39;);
 
 em.merge(entity);
 
 try{
 em.flush();
 }catch(PersistenceException e) {
 utx.rollback();
 
utx.begin();
 entity.setContent(&#39;&#39;);
 entity.setCode(&#39;ERROR&#39;);
 
 em.merge(entity);
 utx.commit();
 }
 }
</code></pre>

<p>使用JTA BMT我们能够在一个方法中处理所有的问题。是因为我们能够控制事务何时开始与提交/回滚（查看上述代码中的utx.begin()/commit()/rollback()）。然而结果还是一样的，在抛出PersistenceException 之后，我们的事务还是被标记为回滚，你可以使用UserTransaction#getStatus() 来查看并且与常量Status.STATUS_MARKED_ROLLBACK进行比较。</p>

<p>原文地址：<a href="http://piotrnowicki.com/2013/03/jpa-and-cmt-why-catching-persistence-exception-is-not-enough/">JPA and CMT -- Why Catching Persistence Exception is Not Enough?</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-06-10-netbeans-maven-jetty-plugin.html">NetBeans 中使用 maven-jetty-plugin 运行与调试 web 项目</a></h1>
			<p class="meta"><time datetime="2013-06-10T11:26:16+08:00" 
			pubdate data-updated="true">2013/6/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>NetBeans 对于 maven 的支持非常好，结合 maven 插件，很容易就可以定制出一个简单易用的 maven web 开发环境。</p>

<p>这里我们使用 maven-jetty-plugin 插件进行 web 项目的运行与调试，关于该插件的配置细节请参考<a href="http://docs.codehaus.org/display/JETTY/Maven+Jetty+Plugin">这里</a>。</p>

<p>假设你已经配置好了 maven-jetty-plugin（修改 pom.xml 中 build -&gt; plugins 加入该 mvn 插件配置），接下来就需要配置 NetBeans 来使用该插件了。</p>

<h3 id="toc_0">运行 web 项目</h3>

<ol>
<li>右键单击你的 mvn web 项目，选择 Custom -&gt; Goals...</li>
<li>填入如下配置：</li>
</ol>

<p><img src="https://pyqdbw.dm1.livefilestore.com/y2prMeEUUCxLkt_9dXM_38-UKOAHaDNuRU2tIE2wXaC_F_-9qz6kz75lf268lPK2lKjMq-L-gR1nquRwn1c5Q2EYmzJu0q9owLT_sxUGwVUaBc/mvn-jetty-plugin-run.jpg?psid=1" alt="netbeans maven-jetty-plugin run"/></p>

<h3 id="toc_1">调试 web 项目</h3>

<ol>
<li>右键单击你的 mvn web 项目，选择 Custom -&gt; Goals...</li>
<li>填入如下配置：</li>
</ol>

<p><img src="https://pyqdbw.dm1.livefilestore.com/y2pt-HEt5uc7hfmsEVEXsqcQ89y3Evcfye6F98Fw900Mqau7t1NPGvNjCDzjiH0By8BL1hR5doYMgGIHvYsuHurhe05td-XKViT-RGzokny1RY/mvn-jetty-plugin-debug.jpg?psid=1" alt="netbeans maven-jetty-plugin debug"/></p>

<p>最终，我们可以右键单击项目，找到刚才配置的 maven-jetty-plugin 插件进行运行或调试项目：</p>

<p><img src="https://pyqdbw.dm1.livefilestore.com/y2pXZTNkZbJw6q85_mutPEATkeV899Mzron7BJeGZIREcuINDcWM0Qd0LQmUoibR90rTDCE-05KdmUj7Xd8UxczzsNR0Nbo1Pg7NWIg0WOwRl4/mvn-jetty-plugin.jpg?psid=1" alt="netbeans maven-jetty-plugin"/></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-06-04-app-dev-accumulation.html">应用开发积累</a></h1>
			<p class="meta"><time datetime="2013-06-04T11:23:40+08:00" 
			pubdate data-updated="true">2013/6/4</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">用户向导程序独立——开始总是困难的，这里没有复用</h3>

<p>向导程序一般功能为初始化配置参数，持久化用户选择的默认参数。这部分逻辑应该是与正常的配置逻辑有重叠的，用户界面上也可能有重叠。</p>

<p>但在设计时最好不要去考虑去复用，向导程序只是使用一次，而且会有些与正常功能有不同的细节。另外，向导程序独立逻辑实现也可能有助于性能。</p>

<p>比如，在博客程序中，初始化后需要发布一篇“Hello World”文章，初始化的发布文章的实现是可以复用正常发布功能的。但是这样会导致初始化的性能比较低，也会增加修改文章功能的复杂。</p>

<p>调用接口地址——系统间的调用接口地址应该保存在项目的配置文件中，而不应该存放于数据库表中</p>

<p>在一个非分布式服务的设计体系中，系统间的调用没有统一的服务接口配置（注册）中心，系统间的调用只能通过显示指定调用接口地址的方式。调用接口地址指的是 host，在开发环境中，数据库往往是所有开发共用一个，在联调系统接口的时候接口地址应该是从本地配置中加载的，否则的话开发环境很难做到配置独立，开发之间会互相影响。</p>

<p>比如，我在系统 A 上新开发了一个接口，和我联调的开发负责修改系统 B 来调用该接口，此时，如果系统 A 的调用地址是配置在数据库中，则联调的时候只能修改开发库的配置，这样就会影响到其他的开发（开发环境一般都公用一个开发数据库）；而如果系统 A 的调用地址是配置在配置文件中，则可以灵活地进行系统 B 的本地配置修改。</p>

<p>当然，调用接口地址使用域名并设置本地 hosts 也是一种可行的做法，但从整体服务内部接口调用这个角度出发，hosts 的方式是不提倡的，因为需要进行域名解析。</p>

<h3 id="toc_1">配置文件——配置文件也是源代码的一部分</h3>

<p>有的时候硬编码和做成配置文件其实在根本上是没有区别的，典型的例子就是依赖注入容器使用上，IoC 实现一般会同时提供注解、XML 配置、API 方式。</p>

<p>而如果是决定系统运行时的环境参数，是必须做成配置文件的。比如框架根据环境配置启用模块特性、切换运行模式。至少包含两套运行环境：开发环境和生产环境，这样方便部署切换。</p>

<p>另外，有的时候会有特殊需求要求运行期修改配置文件能够生效，如果有这样的动态配置需求，应该考虑使用数据库存取配置，而不是使用配置文件。</p>

<h3 id="toc_2">开发环境副本——做一个变更时，开发环境应该是完全独立的，在理想情况下</h3>

<p>开发环境包括源代码版本分支、本地开发环境、应用服务器、数据库服务、依赖的远程服务。</p>

<p>实际情况下，最好时应该可以做到源代码版本分支独立、本地开发环境独立、应用服务器、依赖的远程服务独立，但数据库服务是基本不可能独立的，因为配置数据库系统与导数据是非常耗费时间的。</p>

<p>开发环境的搭建是比较乏味且易出错的工作，即使是搭建环境本身可以通过一些工具脚本进行，众多的应用服务器管理成本也是较高的。</p>

<h3 id="toc_3">消息系统——松耦合不是系统的最终目标</h3>

<p>消息服务是异步地整合系统间调用的一种方式，至少提供两种模式：发布/订阅（组播），点到点（单播）。</p>

<p>其最大的特点是异步处理，而发布方与接收方之间的松耦合只是消息系统的副产品，不应该认为松耦合是消息系统的特性。</p>

<p>消息系统的机制从调用角度看是一种隐式调用，既调用方与被调用方不直接在源码上依赖，而是将调用关系隐含在主题类型上。理论上所有应用场景实现上的调用都可以通过消息系统来实现，但实际不存在完全基于消息系统的架构，因为维护这样松耦合的架构成本更高。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-05-18-jelly-bean-native-rtl.html">Android 4.2原生支持从右到左的文字排列格式</a></h1>
			<p class="meta"><time datetime="2013-05-18T15:59:40+08:00" 
			pubdate data-updated="true">2013/5/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Android 4.1(Jelly Bean)  在 <a href="http://developer.android.com/reference/android/widget/TextView.html">TextView</a> 和 <a href="http://developer.android.com/reference/android/widget/EditText.html">EditText</a> 元素里对“<a href="http://developer.android.com/about/versions/jelly-bean.html#intl">双向文字顺序</a>”提供了有限的功能支持，允许应用程序在编辑和显示字符的时候，能够同时支持从左到右（LTR）以及从右到左（RTL）的排列格式。Android 4.2目前已经对“从右到左”的文字排列顺序给予了<a href="http://developer.android.com/about/versions/jelly-bean.html#42-native-rtl">原生级别的全面支持</a>，包括提供了一个布局镜面工具，使得开发者把能够将优质的用户体验带给每一位用户，不管该用户的书写顺序是从左到右，还是从右到左。</p>

<p>Android 4.2保证了该新特性不会影响到目前已经存在程序，如果之前的程序代码不修改，其应用的外观将维持现状。如果你想要修改程序，那么仅仅需要很小的改动，应用就可以自动地被“镜面反射”，这样就能轻易地将系统语言设置为从右到左的书写格式（阿拉伯语，希伯来语和波斯语都采用这种格式）。例如，下面的截图就展示了上述的设置效果：</p>

<p><img src="/resource/image/2013-05-18-jelly-bean-native-rtl/setings-ltr.png" alt="从左到右的布局方式"/><br/>
从左到右的布局方式</p>

<p><img src="/resource/image/2013-05-18-jelly-bean-native-rtl/setings-rtl.png" alt="从右到左的布局方式"/><br/>
从右到左的布局方式</p>

<p>要实现RTL（从右到左）的布局镜面反射，仅仅需要遵循下列步骤就可以做到：</p>

<ol>
<li><p>在你的应用程序声明文件（manifest）里声明开启RTL mirroring的支持。具体做法是：在manifest.xml声明文件的<application>元素中，添加 android:supportsRtl=”true”</p></li>
<li><p>修改应用程序中所有的“left/right”布局属性，改为对应的”start/end”布局</p></li>
</ol>

<p>1）如果你的应用程序是针对Android 4.2目标平台（应用的targetSdkVersion或者minSdkVersion是17或者更高), 那么你就应当用“start”和“end”替换原来的“left”和“right”。例如，android:paddingLeft应当被替换为android:paddingStart。</p>

<p>2)  如果你想让你的应用程序与Android 4.2之前的版本保持兼容（也就是与targetSdkVersion或者minSdkVersion为16或者更早的版本），那么你应当既加上“start”和“end”，又加上“left”和“right”。例如，你应当同时写上：adnroid:paddingLeft和android:paddingStart。</p>

<p>为了更精确地控制应用程序在UI上的文字书写顺序（从左到右，或者从右到左），Android 4.2 引入了如下的API：</p>

<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:layoutDirection">android:layoutDirection</a> —该属性设置组件的布局排列方向</p>

<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:textDirection">android:textDirection</a> — 该属性设置组件的文字排列方向</p>

<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:textAlignment">android:textAlignment</a> — 该属性设置文字的对齐方式</p>

<p><a href="http://developer.android.com/reference/android/text/TextUtils.html#getLayoutDirectionFromLocale(java.util.Locale)">getLayoutDirectionFromLocale()</a> —该方法用于获取指定地区的惯用布局方式</p>

<p>在使用从右到左的排列方式时，你甚至创建自定义的布局方式，可绘制对象，以及其他资源。仅仅是简单地使用资源匹配器“ldrtl”对你的资源进行一下标识，你就可以把资源定义为“从右到左方向的资源”。在调试和优化从右到左的布局方面，HierarchyViewer目前支持对start/end属性，布局方向，文字方向，文字对齐方式等所有信息的层次化显示。</p>

<p>那么现在是时候为所有的用户开发优美的Android应用程序了，无论用户的文字语言习惯是从左到右，还是从右到左。我们非常期待看到这些优美应用的产生！</p>

<p>原文地址: <a href="http://android-developers.blogspot.com/2013/03/native-rtl-support-in-android-42.html">Native RTL support in Android 4.2</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-05-16-android-studio.html">Google I/O 2013隆重推出Android Studio</a></h1>
			<p class="meta"><time datetime="2013-05-16T16:52:45+08:00" 
			pubdate data-updated="true">2013/5/16</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Google刚刚在I/O 2013开发者大会的keynote演讲上隆重推出了全新的Android IDE(集成开发环境）——Android Studio。Android Studio基于Jetbrains公司的标志性Java IDE——IntelliJ（开发者社区开源版本）开发，该产品在功能和设计上别具匠心，可以让开发者更容易地处理开发和布局设计工作。</p>

<p><img src="/resource/image/2013-05-16-android-studio/Android-Studio.jpg" alt="Android Studio"/></p>

<p>Google IO现场对Android Studio进行了功能演示，演示是直接用代码的形式进行的，IDE可以检查硬编码情况，直接查看颜色编码，还可以对不同尺寸的设备布局进行预览——无论是3.7英寸的电话设备，还是10英寸的平板设备，都不在话下。IDE甚至还可以对不同语言布局情况进行预览，以检验在不同的国际化产品环境下文字是否会出现排版溢出。</p>

<p><img src="/resource/image/2013-05-16-android-studio/android-ui-designer.png" alt="android-ui-designer"/></p>

<p>与会的开发者无不为Android Studio的强大演示功能所折服，因此我们几乎可以确定，不管是对Android开发老鸟还是菜鸟，这款IDE都会成为其爱不释手的开发工具。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-04-17-mybatis-mysql-oracle-paging-plugin.html">MyBatis MySQL Oracle 分页插件</a></h1>
			<p class="meta"><time datetime="2013-04-17T11:17:55+08:00" 
			pubdate data-updated="true">2013/4/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>MyBatis 的 MySQL、Oracle 分页插件，使用相同的分页接口。</p>

<pre><code>/**
 * 分页对象
 */
public final class Page implements Serializable {
 
    /**
     * 默认的序列化版本 id.
     */
    private static final long serialVersionUID = 1L;
    /**
     * 分页查询开始记录位置.
     */
    private int               begin;
    /**
     * 分页查看下结束位置.
     */
    private int               end;
    /**
     * 每页显示记录数.
     */
    private int               length           = 20;
    /**
     * 查询结果总记录数.
     */
    private int               totalRecords;
    /**
     * 当前页码.
     */
    private int               pageNo;
    /**
     * 总共页数.
     */
    private int               pageCount;
 
    public Page() {
    }
 
    /**
     * 构造函数.
     * 
     * @param begin
     * @param length
     */
    public Page(int begin, int length) {
        this.begin = begin;
        this.length = length;
        this.end = this.begin + this.length;
        this.pageNo = (int) Math.floor((this.begin * 1.0d) / this.length) + 1;
    }
 
    /**
     * @param begin
     * @param length
     * @param count
     */
    public Page(int begin, int length, int totalRecords) {
        this(begin, length);
        this.totalRecords = totalRecords;
    }
 
    /**
     * 设置页数，自动计算数据范围.
     * 
     * @param pageNo
     */
    public Page(int pageNo) {
        this.pageNo = pageNo;
        pageNo = pageNo &gt; 0 ? pageNo : 1;
        this.begin = this.length * (pageNo - 1);
        this.end = this.length * pageNo;
    }
 
    /**
     * @return the begin
     */
    public int getBegin() {
        return begin;
    }
 
    /**
     * @return the end
     */
    public int getEnd() {
        return end;
    }
 
    /**
     * @param end
     *            the end to set
     */
    public void setEnd(int end) {
        this.end = end;
    }
 
    /**
     * @param begin
     *            the begin to set
     */
    public void setBegin(int begin) {
        this.begin = begin;
        if (this.length != 0) {
            this.pageNo = (int) Math.floor((this.begin * 1.0d) / this.length) + 1;
        }
    }
 
    /**
     * @return the length
     */
    public int getLength() {
        return length;
    }
 
    /**
     * @param length
     *            the length to set
     */
    public void setLength(int length) {
        this.length = length;
        if (this.begin != 0) {
            this.pageNo = (int) Math.floor((this.begin * 1.0d) / this.length) + 1;
        }
    }
 
    /**
     * @return the totalRecords
     */
    public int getTotalRecords() {
        return totalRecords;
    }
 
    /**
     * @param totalRecords
     *            the totalRecords to set
     */
    public void setTotalRecords(int totalRecords) {
        this.totalRecords = totalRecords;
        this.pageCount = (int) Math.floor((this.totalRecords * 1.0d) / this.length);
        if (this.totalRecords % this.length != 0) {
            this.pageCount++;
        }
    }
 
    /**
     * @return the pageNo
     */
    public int getPageNo() {
        return pageNo;
    }
 
    /**
     * @param pageNo
     *            the pageNo to set
     */
    public void setPageNo(int pageNo) {
        this.pageNo = pageNo;
        pageNo = pageNo &gt; 0 ? pageNo : 1;
        this.begin = this.length * (pageNo - 1);
        this.end = this.length * pageNo;
    }
 
    /**
     * @return the pageCount
     */
    public int getPageCount() {
        if (pageCount == 0) {
            return 1;
        }
        return pageCount;
    }
 
    /**
     * @param pageCount
     *            the pageCount to set
     */
    public void setPageCount(int pageCount) {
        this.pageCount = pageCount;
    }
 
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder(&quot;begin=&quot;).append(begin).append(&quot;, end=&quot;)
                .append(end).append(&quot;, length=&quot;).append(length).append(&quot;, totalRecords=&quot;).append(
                        totalRecords).append(&quot;, pageNo=&quot;).append(pageNo).append(&quot;, pageCount=&quot;)
                .append(pageCount);
 
        return builder.toString();
    }
}
</code></pre>

<pre><code>/**
 * Oracle 分页生成插件
 */
public class OraclePaginationPlugin extends PluginAdapter {
 
    @Override
    public boolean modelExampleClassGenerated(TopLevelClass topLevelClass,
            IntrospectedTable introspectedTable) {
        // add field, getter, setter for limit clause
        addPage(topLevelClass, introspectedTable, &quot;page&quot;);
        return super.modelExampleClassGenerated(topLevelClass, introspectedTable);
    }
 
    @Override
    public boolean sqlMapDocumentGenerated(Document document, IntrospectedTable introspectedTable) {
        XmlElement parentElement = document.getRootElement();
 
        // 产生分页语句前半部分
        XmlElement paginationPrefixElement = new XmlElement(&quot;sql&quot;);
        paginationPrefixElement.addAttribute(new Attribute(&quot;id&quot;, &quot;OracleDialectPrefix&quot;));
        XmlElement pageStart = new XmlElement(&quot;if&quot;);
        pageStart.addAttribute(new Attribute(&quot;test&quot;, &quot;page != null&quot;));
        pageStart.addElement(new TextElement(
                &quot;select * from ( select row_.*, rownum rownum_ from ( &quot;));
        paginationPrefixElement.addElement(pageStart);
        parentElement.addElement(paginationPrefixElement);
 
        // 产生分页语句后半部分
        XmlElement paginationSuffixElement = new XmlElement(&quot;sql&quot;);
        paginationSuffixElement.addAttribute(new Attribute(&quot;id&quot;, &quot;OracleDialectSuffix&quot;));
        XmlElement pageEnd = new XmlElement(&quot;if&quot;);
        pageEnd.addAttribute(new Attribute(&quot;test&quot;, &quot;page != null&quot;));
        pageEnd
                .addElement(new TextElement(
                        &quot;&lt;![CDATA[ ) row_  where rownum &lt;= #{page.end} ) where rownum_ &gt; #{page.begin}  ]]&gt;&quot;));
        paginationSuffixElement.addElement(pageEnd);
        parentElement.addElement(paginationSuffixElement);
 
        return super.sqlMapDocumentGenerated(document, introspectedTable);
    }
 
    @Override
    public boolean sqlMapSelectByExampleWithoutBLOBsElementGenerated(XmlElement element,
            IntrospectedTable introspectedTable) {
 
        XmlElement pageStart = new XmlElement(&quot;include&quot;); //$NON-NLS-1$   
        pageStart.addAttribute(new Attribute(&quot;refid&quot;, &quot;OracleDialectPrefix&quot;));
        element.getElements().add(0, pageStart);
 
        XmlElement isNotNullElement = new XmlElement(&quot;include&quot;); //$NON-NLS-1$   
        isNotNullElement.addAttribute(new Attribute(&quot;refid&quot;, &quot;OracleDialectSuffix&quot;));
        element.getElements().add(isNotNullElement);
 
        return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element, introspectedTable);
    }
 
    /**
     * @param topLevelClass
     * @param introspectedTable
     * @param name
     */
    private void addPage(TopLevelClass topLevelClass, IntrospectedTable introspectedTable,
            String name) {
        topLevelClass.addImportedType(new FullyQualifiedJavaType(
                &quot;com.yuanxin.framework.mybatis.Page&quot;));
        CommentGenerator commentGenerator = context.getCommentGenerator();
        Field field = new Field();
        field.setVisibility(JavaVisibility.PROTECTED);
        field.setType(new FullyQualifiedJavaType(&quot;com.yuanxin.framework.mybatis.Page&quot;));
        field.setName(name);
        commentGenerator.addFieldComment(field, introspectedTable);
        topLevelClass.addField(field);
        char c = name.charAt(0);
        String camel = Character.toUpperCase(c) + name.substring(1);
        Method method = new Method();
        method.setVisibility(JavaVisibility.PUBLIC);
        method.setName(&quot;set&quot; + camel);
        method.addParameter(new Parameter(new FullyQualifiedJavaType(
                &quot;com.yuanxin.framework.mybatis.Page&quot;), name));
        method.addBodyLine(&quot;this.&quot; + name + &quot;=&quot; + name + &quot;;&quot;);
        commentGenerator.addGeneralMethodComment(method, introspectedTable);
        topLevelClass.addMethod(method);
        method = new Method();
        method.setVisibility(JavaVisibility.PUBLIC);
        method.setReturnType(new FullyQualifiedJavaType(&quot;com.yuanxin.framework.mybatis.Page&quot;));
        method.setName(&quot;get&quot; + camel);
        method.addBodyLine(&quot;return &quot; + name + &quot;;&quot;);
        commentGenerator.addGeneralMethodComment(method, introspectedTable);
        topLevelClass.addMethod(method);
    }
 
    /**
     * This plugin is always valid - no properties are required
     */
    @Override
    public boolean validate(List&lt;String&gt; warnings) {
        return true;
    }
}
</code></pre>

<pre><code>/**
 * MySQL 分页生成插件
 */
public final class MySQLPaginationPlugin extends PluginAdapter {
 
    @Override
    public boolean modelExampleClassGenerated(TopLevelClass topLevelClass,
            IntrospectedTable introspectedTable) {
        // add field, getter, setter for limit clause
        addPage(topLevelClass, introspectedTable, &quot;page&quot;);
        return super.modelExampleClassGenerated(topLevelClass, introspectedTable);
    }
 
    @Override
    public boolean sqlMapSelectByExampleWithoutBLOBsElementGenerated(XmlElement element,
            IntrospectedTable introspectedTable) {
        XmlElement page = new XmlElement(&quot;if&quot;);
        page.addAttribute(new Attribute(&quot;test&quot;, &quot;page != null&quot;));
        page.addElement(new TextElement(&quot;limit #{page.begin} , #{page.length}&quot;));
        element.addElement(page);
 
        return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element, introspectedTable);
    }
 
    /**
     * @param topLevelClass
     * @param introspectedTable
     * @param name
     */
    private void addPage(TopLevelClass topLevelClass, IntrospectedTable introspectedTable,
            String name) {
        topLevelClass.addImportedType(new FullyQualifiedJavaType(
                &quot;com.yuanxin.framework.mybatis.Page&quot;));
        CommentGenerator commentGenerator = context.getCommentGenerator();
        Field field = new Field();
        field.setVisibility(JavaVisibility.PROTECTED);
        field.setType(new FullyQualifiedJavaType(&quot;com.yuanxin.framework.mybatis.Page&quot;));
        field.setName(name);
        commentGenerator.addFieldComment(field, introspectedTable);
        topLevelClass.addField(field);
        char c = name.charAt(0);
        String camel = Character.toUpperCase(c) + name.substring(1);
        Method method = new Method();
        method.setVisibility(JavaVisibility.PUBLIC);
        method.setName(&quot;set&quot; + camel);
        method.addParameter(new Parameter(new FullyQualifiedJavaType(
                &quot;com.yuanxin.framework.mybatis.Page&quot;), name));
        method.addBodyLine(&quot;this.&quot; + name + &quot;=&quot; + name + &quot;;&quot;);
        commentGenerator.addGeneralMethodComment(method, introspectedTable);
        topLevelClass.addMethod(method);
        method = new Method();
        method.setVisibility(JavaVisibility.PUBLIC);
        method.setReturnType(new FullyQualifiedJavaType(&quot;com.yuanxin.framework.mybatis.Page&quot;));
        method.setName(&quot;get&quot; + camel);
        method.addBodyLine(&quot;return &quot; + name + &quot;;&quot;);
        commentGenerator.addGeneralMethodComment(method, introspectedTable);
        topLevelClass.addMethod(method);
    }
 
    /**
     * This plugin is always valid - no properties are required
     */
    public boolean validate(List&lt;String&gt; warnings) {
        return true;
    }
}
</code></pre>

<p>使用时在 generatorConfig.xml 中配置对应的插件即可，最终，在生成的 Criteria 中就会存在 Page 字段，用于设置分页。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-04-10-gae-java-sdk-1.7.7-release.html">GAE Java 1.7.7 发布</a></h1>
			<p class="meta"><time datetime="2013-04-10T11:16:34+08:00" 
			pubdate data-updated="true">2013/4/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>The Sockets API, which allows applications to make outgoing TCP connections and send/receive UDP packets to the Internet using both IPv4 and IPv6, is now available as an experimental feature. </li>
<li>The Java runtime now defaults to Java7. If you still need to use the Java6 runtime, please use the --use_java6 flag when deploying your app. We encourage you to move to Java7 as soon as possible.</li>
<li>Billing enabled apps will no longer be subject to a $2.10 minimum weekly spend. Instead, apps will only be charged for their actual usage.</li>
<li>Fixed an issue where Datastore auto ids assigned by the scattered id policy were too large to be represented as floating point numbers in the SDK.</li>
<li><p>Fixed an issue with sort by doc_id not translating correctly causing InvalidRequest errors in the Search API</p>

<ul>
<li><a href="https://code.google.com/p/googleappengine/issues/detail?id=8958">https://code.google.com/p/googleappengine/issues/detail?id=8958</a></li>
</ul></li>
</ul>

<ol>
<li>终于支持 Sockets API 了，不过目前还是实验特性</li>
<li>默认运行环境升级到了 Java7</li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-29-zookeeper-znode-type.html">ZooKeeper 节点类型</a></h1>
			<p class="meta"><time datetime="2013-03-29T11:10:19+08:00" 
			pubdate data-updated="true">2013/3/29</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>ZooKeeper 节点是有生命周期的，这取决于节点的类型。在 ZooKeeper 中，节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），以及时序节点（SEQUENTIAL ），具体在节点创建过程中，一般是组合使用，可以生成以下 4 种节点类型。</p>

<h3 id="toc_0">持久节点（PERSISTENT）</h3>

<p>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。</p>

<h3 id="toc_1">持久顺序节点（PERSISTENT_SEQUENTIAL）</h3>

<p>这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。</p>

<h3 id="toc_2">临时节点（EPHEMERAL）</h3>

<p>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。</p>

<h3 id="toc_3">临时顺序节点（EPHEMERAL_SEQUENTIAL）</h3>

<p>可以用来实现分布式锁</p>

<p>客户端调用create()方法创建名为“_locknode_/guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。<br/>
客户端调用getChildren(“_locknode_”)方法来获取所有已经创建的子节点，注意，这里不注册任何Watcher。<br/>
客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点序号最小，那么就认为这个客户端获得了锁。<br/>
如果在步骤3中发现自己并非所有子节点中最小的，说明自己还没有获取到锁。此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时注册事件监听。<br/>
之后当这个被关注的节点被移除了，客户端会收到相应的通知。这个时候客户端需要再次调用getChildren(“_locknode_”)方法来获取所有已经创建的子节点，确保自己确实是最小的节点了，然后进入步骤3。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-19-zoundry-raven.html">Zoundry Raven: ’Nonetype’ object has no attribute ‘tagName’</a></h1>
			<p class="meta"><time datetime="2013-03-19T11:08:44+08:00" 
			pubdate data-updated="true">2013/3/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Zoundry Raven 是个不错的离线博客客户端，今天试用时发现一个问题，在打开文章的时候会出现：’Nonetype’ object has no attribute ‘tagName’</p>

<p>环境：Win7 32位，IE9 </p>

<p>解决：在“程序和功能” -&gt; “查看已安装的更新”中找到并卸载 IE9，重启。</p>

<p>应该是 Zoundry Raven 用到了 IE 的组件，而 IE9 不兼容造成的。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2013-03-18-xmpp-simple-irc-psyc.html">即时消息协议预研</a></h1>
			<p class="meta"><time datetime="2013-03-18T11:00:44+08:00" 
			pubdate data-updated="true">2013/3/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>选取了主流的四种即时消息协议作为预研对象，分别描述了这四种消息技术的原理、适用场景以及限制。</p>

<h3 id="toc_0">XMPP</h3>

<p>XMPP（The Extensible Messaging and Presence Protocol，可扩展的消息通讯与呈现协议），前身是开源即时消息协议 <a href="http://www.jabber.org/">Jabber</a>，现在已经被 IETF 标准化（<a href="http://www.ietf.org/rfc/rfc3920.txt">RFC 3920</a>）。</p>

<p>应用非常广泛，可选择的实现很多，<a href="http://www.igniterealtime.org/projects/openfire/">Openfire</a> 是目前比较成熟的。</p>

<p><img src="https://py8ifw.dm1.livefilestore.com/y1pIDQtf-tFsJZ_2e0f4a6C02OuBYE5Qr2WpFLYgQoc_wXaRB_vz13zpAoNPkbaY7KD6Sr7bqPtYwldqB6lQTV6Gq758-fbIQl8/xmpp.gif?psid=1" alt="XMPP"/></p>

<h3 id="toc_1">SIMPLE</h3>

<p>SIMPLE（SIP for Instant Messaging and Presence Leveraging Extensions，基于 SIP 的即时消息与呈现扩展），IBM/微软主推的即时消息协议，虽然 Java 有相关 JSRs（164、165）定义了接口，但没有找到适合的实现。</p>

<p><img src="https://py8ifw.dm1.livefilestore.com/y1p4KVz3qLNvK7CoVUFkHOnnPMV0zNntw81J_c2uC5PDkoVycAhsBO-mFG_nbNwV1TNoPBO_UP6o738vPOvdVys_95bMuYHQanE/simple.png?psid=1" alt="SIMPLE"/></p>

<p>各实体功能如下：</p>

<ul>
<li>Presence Service：接收、存储和分发 presence information。Presence Service 既可以是一个物理实体上的 server，也可以只是 presentity 和 watcher 之间的直接通信。在具体实现中前者比较常见，后者是 P2P 的模式</li>
<li>Presentity：用于提供 presence information 给 Presence Service</li>
<li>Watcher：向 Presence Service 请求获取 Presentity 的 presence information 或者自身的 watcher information</li>
<li>Principal：指单个的人、程序或者设备，也可以是人、程序、设备的集合体。对于 Presence Service 来说，各个 Principal 是不同的</li>
<li>Presence User Agent：为 Principal 提供手段来操作 0 个或者多个 Presentity，Principal 操作 Presence User Agent 改变 Presentity 的状态。是 Principal 和 Presentity 交互的 interface</li>
<li>Watcher User Agent：类似 Presence User Agent，Principal 通过其来操作 0 个或多个 Watcher，Watcher 收到 Presentity 的新状态之后也通过 Watcher User Agent 呈现给 Principal</li>
<li>Presence Protocol：定义了 Presentity 和 Presence Service，Watcher 和 Presence Service 之间交换消息的一组标准</li>
<li>在具体的实现中最常见的是把 Presence Service 实现为一个 Presence Server，Presence User Agent 和 Presentity 组合在一起，Watcher 和 Watcher User Agent 组合在一起，由一个终端来同时支持这两种组合体，这样，一个终端就既能订阅别人的也能发布自己的 presence information</li>
</ul>

<h3 id="toc_2">IRC</h3>

<p>IRC（Internet Relay Chat，互联网中继聊天协议），以服务器中转为原理进行消息转发，机制成熟稳定，应用广泛，可选择的实现较多。</p>

<p><img src="https://py8ifw.dm1.livefilestore.com/y1pYk_HjXE41e-TbezFqQ9VdnWRBcaLlNfkC5_lIfnE7ZKOkLkV20-JdTwxV-3AIbyRetleM8LCZxXFOWV-WpaSmqbIaXbp03UN/irc.png?psid=1" alt="IRC"/></p>

<p>A作为客户端连接到了服务器 S1 的 ChannelX 频道，B 作为客户端连接到了服务器 S2 的 ChannelX 频道，此时 A 发消息后通过 S1 转发给 S2，然后 S2 有把消息发送给了 B。</p>

<p>其中频道是一个广播组，用户可以进入频道，也可以离开频道。当一个用户在频道里发消息时，频道里的其他所有用户都能够收到该消息。当第一个用户进入频道，频道被创建，当最后一个用户离开此频道时，频道被销毁。</p>

<p>在 IRC 服务器网络中，频道由这些服务器共同维护，频道相当于一条通信管道，将所有开通此项频道的服务器贯穿起来，消息在这个管道中流通。</p>

<h3 id="toc_3">PSYC</h3>

<p>PSYC（Protocol for SYnchronous Conferencing，同步会话协议），设计用来取代 IRC，兼容 IRC/XMPP 客户端，据称其可以无限扩容，弥补 IRC/XMPP 中使用 s2s 后服务器网络拓扑膨胀时性能急剧下降的缺陷。</p>

<p>比较新，应用较少，可选择的实现较少。<a href="http://about.psyc.eu/Comparison">http://about.psyc.eu/Comparison</a>。</p>

<h3 id="toc_4">结论</h3>

<p>可选择 XMPP 作为即时消息底层支持协议，Openfire 作为实现。</p>

<p>在单机 Openfire 不能满足用户数时可考虑使用 Openfire Connection Manager 模块增加客户端连接数；配置 Openfire 集群增加整体容量。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_7.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_5.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2017-01-01-continuous-deployment-at-instagram.html">Instagram 是如何做持续部署的</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-30-life-2016.html">2016 总结 - 工作十小时，休息五分钟</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-28-wechat-small-app.html">张小龙首次公开解读小程序：1月9号上线</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-27-benefits-and-pitfalls-of-micro-service.html">微服务的好处和陷阱</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>