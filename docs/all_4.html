
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-02-optionals-case-study.html">Swift中Optional类型的使用案例分析：valuesForKeys</a></h1>
			<p class="meta"><time datetime="2014-09-02T22:53:15+08:00" 
			pubdate data-updated="true">2014/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这篇文章将带我们探索在Swift中如何使用Optional类型保证强类型的安全性。我们将创建一个Swift版本的Objective-C的API。虽然在Swift中这个API存在的意义不是很大，但是这将会是一个很有趣的例子。</p>

<p>在Objective-C中，NSDictionary类有一个方法，名为-objectsForKeys:notFoundMarker:，它的作用是根据第一个NSArray类型参数中的值作为该字典的key，查找这些key对应的字典中的值，并放到一个新的NSArray中返回，如果找不到对应的值，那么就返回第二个参数指定的对象。在官方文档中对该方法有这么一句描述“返回的数组中的第N个对象，对应着第一个数组参数中的第N个值”。假如说以第一个数组参数中的第三个值作为key在字典中查不到值怎么办呢？这时候就需要notFoundMarker参数登场了。这种情况下就会返回notFoundMarker参数指定的对象了。在Foundation框架中还有专门针对该情况适用的一个类，那就是NSNull，就是当你也没有备选返回对象的时候，就可以返回NSNull对象。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-09-02-optionals-case-study.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-01-closure-expressions-in-swift.html">Swift中的闭包（Closure）</a></h1>
			<p class="meta"><time datetime="2014-09-01T22:57:30+08:00" 
			pubdate data-updated="true">2014/9/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>闭包在Swift中非常有用。通俗的解释就是一个Int类型里存储着一个整数，一个String类型包含着一串字符，同样，闭包是一个包含着函数的类型。有了闭包，你就可以处理很多在一些古老的语言中不能处理的事情。这是因为闭包使用的多样性，比如你可以将闭包赋值给一个变量，你也可以将闭包作为一个函数的参数，你甚至可以将闭包作为一个函数的返回值。它的强大之处可见一斑。</p>

<p>在Swift的很多文档教材中都说函数是“一等公民”，起初我还不是很理解“一等公民”是什么意思，但当我理解了闭包以及它的强大功能后，我恍然大悟、茅塞顿开、醍醐灌顶。原来闭包的这些特性就是“一等公民”的特性啊！参见维基百科<a href="http://en.wikipedia.org/wiki/First-class_citizen">First-class citizen</a>。</p>

<p>Swift中的闭包类似Objective-C中的Block。其实，如果你想在Swift中实现Objective-C里的Block功能，你可以直接使用闭包来代替。Block和闭包的区别只是语法的不同而已，而且闭包的可读性比较强。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-09-01-closure-expressions-in-swift.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-27-change-ubuntu-display-resolution.html">修改 Ubuntu 分辨率</a></h1>
			<p class="meta"><time datetime="2014-08-27T23:02:01+08:00" 
			pubdate data-updated="true">2014/8/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>通常我们可以在 Settings -&gt; Hardware -&gt; Display 中选择适合的分辨率，但有些情况下这里没有列出合适的分辨率，此时我们可以通过命令调整显示分辨率。</p>

<ol>
<li><p>先通过 xrandr 获取当前的显示设备名</p></li>
<li><p>然后通过 cvt 命令获取需要的显示模式编辑行</p></li>
<li><p>新建显示模式 xrandr --newmode &quot;1368x768_60.00&quot; 85.25 1368 1440 1576 1784 768 771 781 798 -hsync +vsync</p></li>
<li><p>添加显示模式 xrandr --addmode VBOX0 &quot;1368x768_60.00&quot;</p></li>
<li><p>应用显示模式 xrandr --output VBOX0 --mode &quot;1368x768_60.00&quot;</p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-18-swift-value-and-reference-types.html">Swift中的值类型和引用类型</a></h1>
			<p class="meta"><time datetime="2014-08-18T22:49:02+08:00" 
			pubdate data-updated="true">2014/8/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Swift中，类型分为两类：第一种是值类型，该类型的每个实例持有数据的副本，并且该副本对于每个实例来说是独一无二的一份，比如结构体（struct）、枚举（enum）、元组（tuple）都是值类型。第二种是参照类型，该类型的实例共享数据唯一的一份副本（在native层面说的话，就是该类型的每个实例都指向内存中的同一个地址），比如类（class）就是参照类型。在这篇文章中，我们将深入探讨值类型和参照类型的使用价值，以及如何在某种场景下选择正确的类型。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-08-18-swift-value-and-reference-types.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-13-swift-nil-coalescing.html">Swift中 Nil Coalescing 运算符的使用技巧</a></h1>
			<p class="meta"><time datetime="2014-08-13T22:43:15+08:00" 
			pubdate data-updated="true">2014/8/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Swift官方《The Swift Programming Language》文档的Basic Operators一节中添加了Nil Coalescing Operator小结，介绍了一个新的运算符Nil Coalescing，符号是??，它的表现形成如下：</p>

<pre><code>let c = a ?? b
</code></pre>

<p>这个运算符有两个条件：</p>

<ul>
<li>a必须是Optional类型的。</li>
<li>b的类型必须要和a解包后的值类型一致。</li>
</ul>

<p>符合这两个条件后，我们来解释一下上述这行代码，意思就是c的值是a或b中一个的值，但有前提条件，就是当a解包后值不为nil时，那么就将a解包后的值赋值给c，如果a解包后值为nil，那么就将b的值赋值给c。</p>

<p>我们还可以用三目运算来更形象的解释这个运算符：</p>

<pre><code>let c = a != nil ? a! : b
</code></pre>

<p>从上面的代码我们很容易理解，当a的值不等于nil时，将a解包后的值赋值给c，否则将b的值赋值给c。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-08-13-swift-nil-coalescing.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-11-golang-ztree.html">Golang 与 zTree</a></h1>
			<p class="meta"><time datetime="2014-08-11T23:00:08+08:00" 
			pubdate data-updated="true">2014/8/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<pre><code>package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;path/filepath&quot;
    &quot;sort&quot;
)

func main() {
    rootpath := &quot;/projects&quot;

    root := FileNode{&quot;projects&quot;, rootpath, []*FileNode{}}
    fileInfo, _ := os.Lstat(rootpath)

    walk(rootpath, fileInfo, &amp;root)

    data, _ := json.Marshal(root)

    fmt.Printf(&quot;%s&quot;, data)
}

type FileNode struct {
    Name      string      `json:&quot;name&quot;`
    Path      string      `json:&quot;path&quot;`
    FileNodes []*FileNode `json:&quot;children&quot;`
}

func walk(path string, info os.FileInfo, node *FileNode) {
    // 列出当前目录下的所有目录、文件
    files := listFiles(path)

    // 遍历这些文件
    for _, filename := range files {
        // 拼接全路径
        fpath := filepath.Join(path, filename)

        // 构造文件结构
        fio, _ := os.Lstat(fpath)

        // 将当前文件作为子节点添加到目录下
        child := FileNode{filename, fpath, []*FileNode{}}
        node.FileNodes = append(node.FileNodes, &amp;child)

        // 如果遍历的当前文件是个目录，则进入该目录进行递归
        if fio.IsDir() {
            walk(fpath, fio, &amp;child)
        }
    }

    return
}

func listFiles(dirname string) []string {
    f, _ := os.Open(dirname)

    names, _ := f.Readdirnames(-1)
    f.Close()

    sort.Strings(names)

    return names
}
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-04-sso-via-cross-domain-cookie.html">跨域 Cookie 实现单点登录</a></h1>
			<p class="meta"><time datetime="2014-08-04T22:44:00+08:00" 
			pubdate data-updated="true">2014/8/4</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">单点登录</h3>

<p>单点登录（SSO - Single Sign On）：对于同一个客户端（例如 Chrome 浏览器），只要登录了一个子站（例如 a.com），则所有子站（b.com、c.com）都认为已经登录。</p>

<p>比如用户在登录淘宝后，跳转到天猫时就已经登录了。</p>

<h3 id="toc_1">用例步骤</h3>

<p>未登录用户访问子站 a.com 进行登录，自动跳转到账户中心的统一登录页 account.com/login<br/>
用户在统一登录页进行登录，登录成功后显示登录跳转页<br/>
显示登录跳转页后自动跳转回 a.com，单点登录完成<br/>
用户在访问 b.com 时无需再次登录</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-08-04-sso-via-cross-domain-cookie.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-07-22-saas-essay.html">云平台之 SaaS 随想</a></h1>
			<p class="meta"><time datetime="2014-07-22T22:50:24+08:00" 
			pubdate data-updated="true">2014/7/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">SaaS 平台</h3>

<h4 id="toc_1">以应用为中心</h4>

<p>“平台”本来就比较泛，再加上“SaaS”的话就更飘渺了。</p>

<p>我们先从一个简单的场景来看：</p>

<ol>
<li>开发者开发应用后在市场上线</li>
<li>用户购买应用使用</li>
<li>开发者通过市场反馈调整运维，为后续版本计划提供依据</li>
<li>新版本上线，用户升级使用</li>
</ol>

<p>这是以应用为中心的一个闭环（市场-开发-运维-市场），实现了应用的整个生命周期，我们可以把平台看成是这个场景的支撑，场景中的所有活动都是在平台上完成的，整个场景就是一个 SaaS 生态系统。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-07-22-saas-essay.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-06-30-swift-underline-sharp.html">Swift中下划线和＂#＂的妙用</a></h1>
			<p class="meta"><time datetime="2014-06-30T22:31:55+08:00" 
			pubdate data-updated="true">2014/6/30</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Swift中，下划线和&quot;#&quot;有很多妙用，这里将已经看到的妙用进行总结，希望可以帮助更多学习Swift的朋友。下面先介绍下划线。</p>

<h4 id="toc_0">1.格式化数字字面量</h4>

<p>通过使用下划线可以提高数字字面量的可读性，例如：</p>

<pre><code>let paddedDouble = 123.000_001   
let oneMillion = 1_000_000
</code></pre>

<h4 id="toc_1">2.忽略元组的元素值</h4>

<p>当我们使用元组时，如果有的元素不需要使用，这时可以使用下划线将相应的元素进行忽略，例如：</p>

<pre><code>let http404Error = (404, &quot;Not Found&quot;)   
let (_, errorMessage) = http404Error 
</code></pre>

<p>代码中，只关心http404Error中第二个元素的值，所以第一个元素可以使用下划线进行忽略。</p>

<h4 id="toc_2">3.忽略区间值</h4>

<pre><code>let base = 3   
let power = 10   
var answer = 1   
for _ in 1...power {   
    answer *= base   
}  
</code></pre>

<p>有时候我们并不关心区间内每一项的值，可以使用下划线来忽略这些值。</p>

<h4 id="toc_3">4.忽略外部参数名</h4>

<p>(1)忽略方法的默认外部参数名<br/>
在使用方法（类方法或者实例方法）时，方法的第二个参数名及后续的参数名，默认既是内部参数名，又是外部参数名，如果不想提供外部参数名，可以在参数名前添加下划线来忽略外部参数名。</p>

<pre><code>class Counter {   
    var count: Int = 0   
    func incrementBy(amount: Int, numberOfTimes: Int) {   
        count += amount * numberOfTimes   
    }   
}  
</code></pre>

<p>在上面的代码中，方法incrementBy()中的numberOfTimes具有默认的外部参数名：numberOfTimes，如果不想使用外部参数名可以使用下划线进行忽略，代码可以写为（不过为了提高代码的可读性，一般不进行忽略）：</p>

<pre><code>class Counter {   
    var count: Int = 0   
    func incrementBy(amount: Int, _ numberOfTimes: Int) {   
        count += amount * numberOfTimes   
    }   
}  
</code></pre>

<p>(2)忽略具有默认值的参数的外部参数名<br/>
当函数（或者方法）的参数具有默认值时，Swift自动为该参数提供与参数名一致的默认外部参数名，因此在进行函数调用的时候，要提供默认参数名，可以使用下划线进行忽略默认外部参数名(但是不推荐忽略外部参数名，这主要是为了调用的时候可以方便地知道每个参数的含义)。</p>

<pre><code>func join(s1: String, s2: String, joiner: String = &quot; &quot;) -&gt; String {   
    return s1 + joiner + s2   
}   
// call the function.   
join(&quot;hello&quot;, &quot;world&quot;, joiner: &quot;-&quot;) 
</code></pre>

<p>如果不想使用默认外部参数名，可以进行如下修改：</p>

<pre><code>func join(s1: String, s2: String, _ joiner: String = &quot; &quot;) -&gt; String {   
    return s1 + joiner + s2   
}   
// call the function.   
join(&quot;hello&quot;, &quot;world&quot;, &quot;-&quot;)  
</code></pre>

<p>在Swift中，&quot;#&quot;有一些妙用：</p>

<h4 id="toc_4">1.配置外部参数名</h4>

<p>在函数（或者方法）的参数名前添加&quot;#&quot;，可以使该参数拥有相同的本地参数名和外部参数名。</p>

<p>注：在方法中，第二个及后续的参数，默认是具有和内部参数一致的外部参数名的，只有第一个参数没有，可以使用&quot;#&quot;符号来强制给第一个参数添加与本地参数名一致的外部参数名，但是不推荐。</p>

<p>(1)函数</p>

<pre><code>func incrementBy(amount: Int, #numberOfTimes: Int) {   
    count += amount * numberOfTimes   
} 
</code></pre>

<p>numberOfTimes的本地参数名（只能在函数内部使用）和外部参数名（在调用函数的时候作为标签使用）都是numberOfTimes。</p>

<p>(2)方法</p>

<pre><code>class Counter {   
    var count: Int = 0   
    func incrementBy(#amount: Int, numberOfTimes: Int) {   
        count += amount * numberOfTimes   
    }   
}   
</code></pre>

<p>numberOfTimes默认具有本地参数名和外部参数名，amount没有外部参数名，使用&quot;#&quot;为amount强制指定外部参数名，在调用该方法的时候，必须使用外部参数名，否则会出现编译错误，提示缺少参数标签。</p>

<pre><code>var counter = Counter()   
counter.incrementBy(amount: 4, numberOfTimes: 5)   
println(counter.count) // the result is 20  
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-06-23-full-text-search-elasticsearch.html">全文搜索之 Elasticsearch</a></h1>
			<p class="meta"><time datetime="2014-06-23T11:17:45+08:00" 
			pubdate data-updated="true">2014/6/23</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">概述</h3>

<p>Elasticsearch （ES）是一个基于 Lucene 的开源搜索引擎，它不但稳定、可靠、快速，而且也具有良好的水平扩展能力，是专门为分布式环境设计的。</p>

<h3 id="toc_1">特性</h3>

<ul>
<li>安装方便：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</li>
<li>JSON：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</li>
<li>RESTful：基本所有操作（索引、查询、甚至是配置）都可以通过 HTTP 接口进行</li>
<li>分布式：节点对外表现对等（每个节点都可以用来做入口）；加入节点自动均衡</li>
<li>多租户：可根据不同的用途分索引；可以同时操作多个索引</li>
</ul>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-06-23-full-text-search-elasticsearch.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-06-19-standard-functions-in-swift.html">Swift中的标准函数</a></h1>
			<p class="meta"><time datetime="2014-06-19T22:25:18+08:00" 
			pubdate data-updated="true">2014/6/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Swift中共有74个内建函数，但是在Swift官方文档（“<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097">The Swift Programming Language</a>”）中只记录了7中。剩下的67个都没有记录。</p>

<p>本文将列举Swift所有的内建函数。本文中提到的所谓的内建函数是指那些在Swift中不需要导入任何模块（如Foundation等）或者引用任何类就可以使用的函数。</p>

<p>abs(signedNumber): 返回给定的有符号数字的绝对值。很简单，但是没有在文档中记录。</p>

<pre><code>abs(-1) == 1 
abs(-42) == 42 
abs(42) == 42 
</code></pre>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-06-19-standard-functions-in-swift.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-06-06-angularjs-and-emberjs.html">AngularJS 与 EmberJS</a></h1>
			<p class="meta"><time datetime="2014-06-06T18:52:27+08:00" 
			pubdate data-updated="true">2014/6/6</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">前端 JavaScript 框架对比</h3>

<p>目前比较主流的几个浏览器客户端 JavaScript 框架对比：</p>

<p><img src="https://nxnzra.dm2301.livefilestore.com/y2pafIzX9SMSGf4O3f8UjQHYUBnfLBgX7xKJbgDt7P2CXdvbrXbfT9cNRWQJOc5AOYZBxLgxMop-PeRQD1nc3B81s3yXwsKtUhc7B9VxkMdme4/mvw%20%E5%AF%B9%E6%AF%94.png?psid=1" alt="前端 mvw 框架对比"/></p>

<p>从左到右是框架提供的功能特性由少到多，对应用开发的支持逐渐丰富；<br/>
从下到上是框架设计复杂度/上手难度由简单到复杂。</p>

<h3 id="toc_1">AngularJS v.s. EmberJS</h3>

<p>这里重点对比 EmberJS 和 AngularJS 的差异：</p>

<table>
<thead>
<tr>
<th></th>
<th>AngularJS</th>
<th>EmberJS</th>
</tr>
</thead>

<tbody>
<tr>
<td>模版</td>
<td>通过HTML标签</td>
<td>自定义标签字符串</td>
</tr>
<tr>
<td>社区支持</td>
<td>Google</td>
<td>个人</td>
</tr>
<tr>
<td>性能</td>
<td>略好</td>
<td>略差</td>
</tr>
<tr>
<td>标准化</td>
<td>可能性较大</td>
<td>可能性较小</td>
</tr>
</tbody>
</table>

<p>这两者都是浏览器客户端的 MVW 框架，从使用上看对开发的要求是基本相近的，都需要开发者以 MVC 的视角去设计前端（而不是针对页面、DOM 进行实现），这和服务器端的设计思路非常类似，有助于复杂应用进行模块化开发。细节上 AngularJS 的设计也更贴近 Java 风格的开发者（比如依赖注入、路由 API 等）。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-06-06-angularjs-and-emberjs.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-06-03-hello-swift.html">美国一名程序员对Swift语言的看法</a></h1>
			<p class="meta"><time datetime="2014-06-03T00:32:58+08:00" 
			pubdate data-updated="true">2014/6/3</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>近20年来，苹果一直把Objective-C作为主要的编程语言，而在今天举行的全球开发者大会上，苹果推出了一个全新的编程语言Swift。据悉，苹果此次发布的Swift兼容Objective-C语言，从其开发者指南中，我们看到Swift从Python和JavaScript中吸取了许多东西，从而让Swift更易读，或者说更为“口语化”。</p>

<p>然而，对这类语法更为简洁的语言，许多人会质疑其运行效率。对此苹果指出，Swift在许多方面性能都比Objective-C好。</p>

<p>美国一名程序员看完了Swift的指南后，写出了自己对这个新编程语言的看法。以下为译文：</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-06-03-hello-swift.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-05-30-cloud-app-platform-multitenancy.html">云平台之多租户</a></h1>
			<p class="meta"><time datetime="2014-05-30T10:57:55+08:00" 
			pubdate data-updated="true">2014/5/30</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在云领域我们经常会听到一个词：多租户。这个词在不同的语境中有着不同的含义，本文将介绍云平台中的多租户的概念以及实现多租户支持的思路。</p>

<h3 id="toc_0">什么是租户</h3>

<p>刚开始接触这个概念时，你肯定感觉“租户”这个词怪怪的，但如果我们换个词，我相信你马上就有感觉了，这个词就是“客户”（这里的客户指的就是商业上面的客户）。一个租户就是一个客户，比如我们开发的服务是给 XXX 企业使用的，那该企业就是我们的一个客户/租户；如果这个服务是面向互联网的，那么使用该服务的每个互联网用户都是一个客户/租户。</p>

<h3 id="toc_1">为什么需要多租户支持</h3>

<p>开发者辛辛苦苦开发出一个服务，提供给了个人/企业使用，这样就完事了么？当然不应该只是这样，我们开发出一个服务，最好是能够同时提供给多个个人/企业使用，而且这些客户最好是共享同一套服务运行时（Runtime），这样可以大大降低服务的运维成本：</p>

<ul>
<li>服务运行时如果分开，则运维的成本与客户数成正比（比如更新部署大量客户的场景）</li>
<li>节省资源（将服务所需资源利用最大化：运维团队统一、硬件使用）</li>
</ul>

<p>另外，这样也可以降低服务的开发成本：</p>

<ul>
<li>我们只需要考虑如何实现单用户的服务逻辑：业务逻辑对应其所有客户都是相同的，无论什么客户来使用，程序提供的服务都是一样的。进一步说，在业务层面我们开发这个服务时理论上不需要考虑多客户支持，我们只用关注该服务的业务逻辑如何实现</li>
<li>多客户的管理功能可以进行统一：开发者应该不用考虑客户管理功能，这部分应该是由云平台统一提供的</li>
</ul>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-05-30-cloud-app-platform-multitenancy.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-05-08-elegant-uninstall-default-git.html">优雅的卸载Mac默认的Xcode附带的git</a></h1>
			<p class="meta"><time datetime="2014-05-08T00:32:32+08:00" 
			pubdate data-updated="true">2014/5/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这里说的优雅的卸载其实不是真正的卸载，而是不用动Xcode附带的git，通过用户~/.bash_profile的文件来优雅的完成。仅仅需要在~/.bash_profile文件后追加如下的导出变量代码即可:</p>

<pre><code>export GIT_HOME=/usr/local/git
export PATH=$GIT_HOME/bin:$PATH
</code></pre>

<p>通git官网下载的mac安装包进行安装，git会被安装到</p>

<pre><code>/usr/local/git
</code></pre>

<p>Xcode附带的git被安装到</p>

<pre><code>/usr/bin
</code></pre>

<p>不必移动或者删除这里的git版本，仅仅需要更改一下用户下面的~/.bash_profile的文件即可优雅的解决git版本的问题.</p>

<p>如果您非要卸载旧的也可以通过下面的命令来完成</p>

<pre><code>sudo cd /usr/bin
sudo mkdir old-git
sudo mv git* old-git
ln -s /usr/local/git ./
</code></pre>

<p>~/.bash_profile文件这个文件除了导出GIT_HOME，也会导出其他的HOME，下面是我常用的一些导出</p>

<pre><code>export COCOS2DX_ROOT=/Users/Lamb/Applications/cocos2d/cocos2d-x-2.2.1
export PATH=$COCOS2DX_ROOT:$PATH

export NDK_ROOT=/Users/Lamb/Applications/android-ndk-r9c
export ANDROID_NDK_ROOT=/Users/Lamb/Applications/android-ndk-r9c
export ANDROID_SDK_ROOT=/Users/Lamb/Applications/android-sdk-macosx
export PATH=$NDK_ROOT:$PATH
export PATH=$ANDROID_NDK_ROOT:$PATH
export PATH=$ANDROID_SDK_ROOT:$PATH

export M2_HOME=/Users/Lamb/Applications/maven/apache-maven-3.2.1
export PATH=$M2_HOME/bin:$PATH
export GRADLE_HOME=/Users/Lamb/Applications/gradle/gradle-1.11
export PATH=$GRADLE_HOME/bin:$PATH

export MONGO_HOME=/Users/Lamb/Applications/mongodb/mongodb-osx-x86_64-2.6.1
export PATH=$MONGO_HOME/bin:$PATH
</code></pre>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_5.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_3.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2017-06-24-ios-arm.html">iOS开发 - 制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-10-wechat-redenvelop-tweak-for-non-jailbroken-iphone.html">不越狱iOS自动抢红包</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-01-continuous-deployment-at-instagram.html">Instagram 是如何做持续部署的</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-30-life-2016.html">2016 总结 - 工作十小时，休息五分钟</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>