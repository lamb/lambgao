
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-11-small-test-node-core-module.html">小试Node 核心模块</a></h1>
			<p class="meta"><time datetime="2012-10-11T18:29:58+08:00" 
			pubdate data-updated="true">2012/10/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Node核心模块提供了很多方便的系统级的API，如文件、数据流、网络、进程等。Node 的特点是采用事件驱动、非阻塞/异步IO模型，所以它提供的大部分API都是基于事件模型、异步的编程风格。下面让我们来深入了解Node的核心模块，熟悉Node的异步编程风格。</p>

<h3 id="toc_0">4.1　全局变量相关模块</h3>

<p>本小节介绍的这些对象在全局范围内均可使用，我们可以在任何位置访问这些对象。</p>

<h4 id="toc_1">4.1.1 Global Objects</h4>

<p>global {Object}<br/>
global（全局）对象可以说是ECMAScript中最特别的一个对象，这是一个看不见摸不着仿佛不存在但确又存在的对象。不属于任何其他对象的属性和方法，其实都是它的属性和方法。换句话说，所有在全局作域中定义的属性和方法，都是global对象的属性。ECMAScript对于如何访问global对象并没有给出标准定义，但是浏览器都不约而同是将这个全局对象作为window对象的一部分加以实现的。在浏览器中顶级作用域就是全局作用域，在全局作用域下通过var something即定义了一个全局变量，也可以说window多了一个something的属性。而Node中并不如此，顶级作用域并非是全局作用域，在Node的一个模块中（即一个文件中）通过var something 定义的变量仅仅作用于该模块。<br/>
process {Object}<br/>
进程对象，在4.1.5中会详细描述。<br/>
console {Object}<br/>
标准输出对象，在4.1.2中会详细描述。<br/>
Buffer {Object}<br/>
缓冲区对象，在4.1.6中会详细描述。<br/>
__filename {String}<br/>
当前正在被执行的脚本的文件名。这是一个完整的绝对路径。<br/>
<strong>dirname {String}<br/>
当前正在被执行的脚本的目录名。<br/>
module {Object}<br/>
指向当前模块对象的引用。<br/>
require() {Function}<br/>
加载模块的方法。<br/>
require.resolve()  {Function}<br/>
使用内部方法require的机制查找一个模块的位置，而不是加载模块。如果查找模块成功，会返回</strong>filename，否则抛出一个找不到模块的错误。<br/>
require.cache {Object}<br/>
模块缓存对象。模块被首次加载会以键值对的形式缓存在此对象中，键为__filename，值为module。如果模块缓存对象中的某一个键值被删除，再次加载此模块时会被重新加载。<br/>
require.paths {Array}<br/>
查找模块搜索路径数组。我们可以通过修改该数组自定义搜索路径。这个变量在0.5.x版本被移除。<br/>
exports {Object}<br/>
模块导出对象，在4.1.4中会详细描述。exports是module.exports引用的拷贝，指向同一对象。<br/>
module、require、exports、__filename和__dirname实际上并不真正是全局的，确切的说对于每个模块是局部的。<br/>
setTimeout(cb, ms) {Function}<br/>
clearTimeout(t) {Function}<br/>
setInterval(cb, ms) {Function}<br/>
clearInterval(t) {Function}<br/>
定时器方法，在4.1.3中会详细描述。</p>

<h4 id="toc_2">4.1.2 STDIO</h4>

<p>console {Object}<br/>
大部分浏览器都提供了标准输出对象提供打印输出功能。console这个对象与浏览器中的标准输出对象相似，也提供打印输出的功能。<br/>
console.log() {Function}<br/>
console.info() {Function}<br/>
console.warn() {Function}<br/>
console.error() {Function}<br/>
输出一行标准信息或标准错误到控制台。这些方法可以接收多个参数。例如：<br/>
var count = 1;<br/>
console.log(&#39;count: %d&#39;, count);//count: 1<br/>
如果方法检查到第一个参数没有格式化元素，那么会对每一个参赛调用util.inspect方法并打印输出其返回值。util.inspect方法在4.5.1中会详细描述。<br/>
console.dir(obj) {Function}<br/>
调用util.inspect方法并打印输出返回值。<br/>
console.time(label) {Function}<br/>
console.timeEnd(label) {Function}<br/>
统计一段程序运行所需时间的方法。例如：<br/>
console.time(&#39;100-elements&#39;);<br/>
for (var i = 0; i &lt; 100; i++) {<br/>
  ;<br/>
}<br/>
console.timeEnd(&#39;100-elements&#39;);// 100-elements: 0ms<br/>
console.trace(message) {Function}<br/>
在当前位置打印堆栈轨迹的方法。此方法后的代码会继续正常运行。<br/>
console.assert(expression, [message]) {Function}<br/>
断言某个表达式是否为true的方法，同断言方法assert.ok()。</p>

<h4 id="toc_3">4.1.3 Timers</h4>

<p>setTimeout(callback, delay, [arg], [...]) {Function}<br/>
该方法用于在指定的delay毫秒后单次调用callback回调函数，并可以设定要传递给回调函数的参数，返回值timeoutId可用于clearTimeout()。<br/>
clearTimeout(timeoutId) {Function}<br/>
清楚指定timeoutId的定时器。<br/>
setInterval(callback, delay, [arg], [...]) {Function}<br/>
该方法用于在指定的delay毫秒后多次重复调用callback回调函数，并可以设定要传递给回调函数的参数，返回值intervalId可用于clearInterval ()。<br/>
clearInterval(intervalId) {Function}<br/>
清楚指定intervalId的定时器。<br/>
代码示例：<br/>
var timeoutId = setTimeout(function(o, b){<br/>
  console.log(&quot;This is callback&quot;);//This is callback<br/>
  console.log(o.a);//1<br/>
  console.log(b);//2<br/>
}, 3000, {&quot;a&quot;:1}, 2);</p>

<p>clearTimeout(timeoutId);</p>

<h4 id="toc_4">4.1.4 Modules</h4>

<p>module.exports {Object} <br/>
module.exports对象是用于向外导出方法或者变量以供外部使用。在初始时，module.exports对象就是一个空对象{}，向外导出的方法和变量都将作为module.exports对象的属性。需要注意的是，module.exports需要直接快速的赋值，不能在任何回调函数中完成这个操作。以下这样的使用，会产生不期望的效果：<br/>
x.js:<br/>
setTimeout(function() {<br/>
  module.exports = { a: &quot;hello&quot; };<br/>
}, 0);<br/>
y.js:<br/>
var x = require(&#39;./x&#39;);<br/>
console.log(x.a);//undefined<br/>
我们也可以使用exports对象来完成模块导出操作。exports是module.exports引用的拷贝，指向同一对象。在使用时，我们需要避免这样的错误：<br/>
a.js:<br/>
module.exports = {a: 1};<br/>
exports.b = 2;<br/>
b.js:<br/>
var a = require(&#39;./a&#39;);<br/>
console.log(a);//{ a: 1 }<br/>
这里输出的并不是预期的{ a: 1, b: 2 }。仔细分析一下就可以明白产生这样不是预期结果的原因：module.exports和exports是引用到的同一个对象，module.exports = {}这样的赋值操作修改了module.exports的引用，但是exports的引用并没有改变，调用require()方法的时候所引用的是module.exports 对象，自然exports变量的引用就会被忽略掉了。这种问题的解决方法也很简单，一种方法是同时重写两者的引用，一种是从不重写二者的引用。<br/>
exports = module.exports = { a: 1, b: 2 };</p>

<p>exports.a = 1;<br/>
exports.b = 2;<br/>
module.require(id) {Function}<br/>
加载指定模块标识符id的方法。<br/>
module.id {String}<br/>
模块的标识符。一般为一个完整的绝对路径。<br/>
module.filename {String}<br/>
模块文件的文件名。这是一个完整的绝对路径。<br/>
module.loaded {Boolean}<br/>
模块是否加载完成。<br/>
module.parent {Object}<br/>
加载该模块的父模块对象。<br/>
module.children {Array}<br/>
模块加载的子模块对象数组。<br/>
require.main {Object}<br/>
主模块对象。我们可以使用require.main === module来判断是否是主模块。</p>

<h4 id="toc_5">4.1.5 Process</h4>

<p>process {Object}<br/>
进程对象。它是一个EventEmitter的实例。<br/>
Event: &#39;exit&#39;<br/>
当进程退出时，此事件被触发。这是一个检查模块状态的好时机（比较单元测试）。由于在exit事件触发回调函数完成后主事件循环将终止，所以计时器不会生效。<br/>
监听exit事件的示例，onexit.js：<br/>
process.on(&#39;exit&#39;, function () {<br/>
  process.nextTick(function () {<br/>
   console.log(&#39;This will not run&#39;);<br/>
  });<br/>
  console.log(&#39;About to exit.&#39;);<br/>
});<br/>
Event: &#39;uncaughtException&#39;<br/>
当发生一个未处理的异常时，此事件会被触发。如果该异常有这样一个监听器，那么不执行默认行为（即打印错误堆栈信息并结束应用程序的执行）。<br/>
监听uncaughtException事件的示例，uncaughtException.js：<br/>
process.on(&#39;uncaughtException&#39;, function (err) {<br/>
  console.log(&#39;Caught exception: &#39; + err);<br/>
});</p>

<p>setTimeout(function () {<br/>
  console.log(&#39;This will still run.&#39;);<br/>
}, 500);</p>

<p>// Intentionally cause an exception, but don&#39;t catch it.<br/>
nonexistentFunc();<br/>
console.log(&#39;This will not run.&#39;);<br/>
注意，uncaughtException事件是一种非常粗糙的异常处理机制。我们可以在程序中使用try/catch来更好的控制程序流程。特别是对于在服务器端程序，因为它要持续运行，所以uncaughtException事件是个很有用的安全机制。<br/>
Signal Events<br/>
当进程接收到信号时，此事件会被触发。具体信号名请查看sigaction(2)中的标准POSIX信号名称列表，比如SIGINT、SIGUSR1等。<br/>
监听SIGINT信号的示例，SIGINT.js：<br/>
// Start reading from stdin so we don&#39;t exit.<br/>
process.stdin.resume();</p>

<p>process.on(&#39;SIGINT&#39;, function () {<br/>
  console.log(&#39;Got SIGINT.  Press Control-D to exit.&#39;);<br/>
});<br/>
发送SIGINT信号最简单的方法是使用CTRL+C，大多数情况下这会终止应用程序的执行。<br/>
process.stdout {Object}<br/>
标准输出流对象。console.log方法的定义：<br/>
console.log = function (d) {<br/>
  process.stdout.write(d + &#39;\n&#39;);<br/>
};<br/>
process.stderr {Object}<br/>
错误输出流对象。<br/>
process.stdout 和process.stderr不像Node中的其他数据流，它们在写入时通常阻塞。他们在被指向到普通文件或者TTY文件描述符时是阻塞的；指向到数据通道时是非阻塞的。<br/>
process.stdin {Object}<br/>
标准输入流对象。默认情况下标准输入流会阻塞程序，要读取输入内容需要调用方法process.stdin.resume()。<br/>
下面是打开标准输入并监听它的两个事件的示例，stdin.js:<br/>
process.stdin.resume();<br/>
process.stdin.setEncoding(&#39;utf8&#39;);</p>

<p>process.stdin.on(&#39;data&#39;, function (chunk) {<br/>
  process.stdout.write(&#39;data: &#39; + chunk);<br/>
});</p>

<p>process.stdin.on(&#39;end&#39;, function () {<br/>
  process.stdout.write(&#39;end&#39;);<br/>
});<br/>
process.argv {Array}<br/>
命令行参数数组。第一个参数是&quot;node&quot;，第二个参数是JavaScript文件的绝对路径。接下来是附加的命令行参数。<br/>
argv.js:<br/>
// print process.argv<br/>
process.argv.forEach(function (val, index, array) {<br/>
  console.log(index + &#39;: &#39; + val);<br/>
});<br/>
上面的代码将产生如下输出：<br/>
$ node process-2.js one two=three four<br/>
0: node<br/>
1: /Users/mjr/work/node/process-2.js<br/>
2: one<br/>
3: two=three<br/>
4: four<br/>
process.execPath {String}<br/>
进程可执行文件的绝对路径。<br/>
process.cwd() {Function}<br/>
返回进程的当前工作目录。<br/>
process.chdir(directory) {Function}<br/>
改变进程的当前工作目录，失败时抛出异常。<br/>
chdir.js<br/>
console.log(&#39;Starting directory: &#39; + process.cwd());<br/>
try {<br/>
  process.chdir(&#39;/tmp&#39;);<br/>
  console.log(&#39;New directory: &#39; + process.cwd());<br/>
}<br/>
catch (err) {<br/>
  console.log(&#39;chdir: &#39; + err);<br/>
}<br/>
process.env {Object}<br/>
装有用户环境变量的对象。<br/>
process.exit([code]) {Function}<br/>
使用指定的退出代码进程退出进程。如果不指定参数，方法将使用表示成功的代码0。退出程序并返回错误状态的示例，exit.js:<br/>
process.exit(1);<br/>
执行node的shell将会得到返回值1。<br/>
process.getgid() {Function}<br/>
获取进程的群组标识（详见getgid(2)）。这是一个数字的群组ID，不是群组名称。<br/>
process.setgid(id) {Function}<br/>
设置进程的群组标识（详见setgid(2)）。参数可以是一个数字ID或者群组名字符串。如果指定了一个群组名，这个方法会阻塞等待将群组名解析为数字ID。<br/>
gid.js:<br/>
console.log(&#39;Current gid: &#39; + process.getgid());<br/>
try {<br/>
  process.setgid(501);<br/>
  console.log(&#39;New gid: &#39; + process.getgid());<br/>
}<br/>
catch (err) {<br/>
  console.log(&#39;Failed to set gid: &#39; + err);<br/>
}<br/>
process.getuid() {Function}<br/>
获取进程的用户ID（详见getuid(2)）。这是一个数字用户ID，不是用户名。<br/>
process.setuid(id) {Function}<br/>
设置进程的用户ID（详见setuid(2)）。参数可以是一个数字ID或者用户名字符串。如果指定了一个用户名，那么该方法会阻塞等待将用户名解析为数字ID。<br/>
uid.js：<br/>
console.log(&#39;Current uid: &#39; + process.getuid());<br/>
try {<br/>
  process.setuid(501);<br/>
  console.log(&#39;New uid: &#39; + process.getuid());<br/>
}<br/>
catch (err) {<br/>
  console.log(&#39;Failed to set uid: &#39; + err);<br/>
}<br/>
process.version {String}<br/>
一个编译内置的属性，用于显示Node的版本。<br/>
version.js:<br/>
console.log(&#39;Version: &#39; + process.version);<br/>
process.versions {Object}<br/>
用于显示Node依赖库的版本的对象。<br/>
versions.js:<br/>
console.log(process.versions);<br/>
输出如下：<br/>
{ node: &#39;0.6.19&#39;,<br/>
  v8: &#39;3.6.6.25&#39;,<br/>
  ares: &#39;1.7.5-DEV&#39;,<br/>
  uv: &#39;0.6&#39;,<br/>
  openssl: &#39;0.9.8r&#39; }<br/>
process.installPrefix {String}<br/>
一个编译内置的属性，用于显示Node的安装目录的前缀NODE_PREFIX。<br/>
installPrefix.js:<br/>
console.log(&#39;Prefix: &#39; + process.installPrefix);<br/>
process.kill(pid, [signal]) {Function}<br/>
向一个进程发送信号，参数pid为进程ID，参数signal是一个描述要发送信号的字符串，如“SIGINT”或者“SIGUSR1”。如果不指定，默认发送“SIGTERM”信号。更多信息请查看kill(2)。<br/>
注意，虽然此方法名为process.kill，但是它仅仅用于发送信号，就像kill系统调用一样。发送的信号除了可以结束目标进程外，还可以完成其他的操作。<br/>
发送信号的示例，kill.js:<br/>
process.on(&#39;SIGHUP&#39;, function () {<br/>
  console.log(&#39;Got SIGHUP signal.&#39;);<br/>
});</p>

<p>setTimeout(function () {<br/>
  console.log(&#39;Exiting.&#39;);<br/>
  process.exit(0);<br/>
}, 100);</p>

<p>process.kill(process.pid, &#39;SIGHUP&#39;);<br/>
process.pid {String}<br/>
进程PID。<br/>
process.title {String}<br/>
设置、获取ps命令中显示的名称。<br/>
process.arch {String}<br/>
运行程序的处理器架构：“arm”、“ia32”、“x64”。<br/>
process.platform {String}<br/>
程序运行的平台，如“linux2”、“darwin”等。<br/>
process.memoryUsage() {Function}<br/>
返回一个描述Node进程内存使用情况的对象。<br/>
memoryUsage.js:<br/>
console.log(process.memoryUsage());<br/>
输出如下：<br/>
{ rss: 8552448, heapTotal: 2546784, heapUsed: 1234140 }<br/>
heapTotal和heapUsed指V8内存使用情况。<br/>
process.nextTick(callback) {Function}<br/>
在事件循环的下一轮执行callback回调函数。这个方法不是setTimeout(fn, 0)的别名，它更加高效。<br/>
nextTick.js：<br/>
process.nextTick(function () {<br/>
  console.log(&#39;nextTick callback&#39;);<br/>
});<br/>
process.umask([mask]) {Function}<br/>
设置或读取进程的文件创建模式掩码，子进程会从父进程继承这个掩码。如果使用此方法设置新的掩码，则它返回旧的掩码，否则返回当前掩码。<br/>
umask.js:<br/>
var oldmask, newmask = 0644;<br/>
oldmask = process.umask(newmask);<br/>
console.log(&#39;Changed umask from: &#39; + oldmask.toString(8) + &#39; to &#39; + newmask.toString(8));<br/>
process.uptime() {Function}<br/>
返回Node进程运行的时间，单位为秒。<br/>
uptime.js:<br/>
console.log(process.uptime());</p>

<h4 id="toc_6">4.1.6 Buffer</h4>

<p>Buffer {Class}<br/>
纯JavaScript语言对Unicode很友好，但是难以处理二进制数据。在处理TCP数据流和文件时不可避免地需要操作字节流。Node提供一些方法来创建、操作和接收二进制数据。<br/>
原始的数据被存放在Buffer的实例中。Buffer类似于一个整数数组，不同之处在于它和V8内存堆之外分配的一段内存数据相对应。Buffer对象的大小不能动态调整。Buffer是全局的，不需要在使用前还需每次&quot;require(&#39;buffer&#39;)&quot;后才能够使用它，并有多种不同的方法实例化。<br/>
Buffer和JavaScript中的String对象之间的转换需要指定编码方式。如下是Node支持的编码方式:<br/>
&#39;ascii&#39; - 仅对应7位的ASCII数据。这种编码方式速度很快，它会删除字节的高位。<br/>
&#39;utf-8&#39; - Unicode字符。许多网页和其他文档使用这种编码方式。<br/>
&#39;ucs2&#39; - 2字节的，低字节序编码Unicode字符。它只能编码BMP（基本多语言面，U+0000-U+FFFF）字符。<br/>
&#39;base64&#39; - base64字符串编码。<br/>
&#39;binary&#39; - 一种只使用每个字符前8个字节将原始二进制数据编码进字符串的方式。这个方式已经废弃，应当尽量使用buffer对象。这个编码将在未来版本中移除。<br/>
&#39;hex&#39; - 将一个字节编码为两个16进制字符。<br/>
new Buffer(size) {ClassMethod}<br/>
创建指定大小的Buffer对象。<br/>
new Buffer(array) {ClassMethod}<br/>
用数组新建Buffer对象。<br/>
new Buffer(str, [encoding]) {ClassMethod}<br/>
新建一个保存指定字符串的Buffer对象。字符编码默认&#39;utf-8&#39;。<br/>
buf.write(string, [offset], [length], [encoding]) {Function}<br/>
使用指定的编码方式将字符串从指定偏移量开始写入Buffer，然后返回实际写入的大小。编码默认是&#39;utf-8&#39;，偏移量默认是0，length为写入的字节长度。如果Buffer空间不足，则只会写入部分字符串。这种方式不会出现一个字符被拆分成半个字符被写入。下面是将一个utf-8字符串写入buffer，然后打印出来的示例，write.js：<br/>
buf = new Buffer(256);<br/>
len = buf.write(&#39;\u00bd + \u00bc = \u00be&#39;, 0);<br/>
console.log(len + &quot; bytes: &quot; + buf.toString(&#39;utf8&#39;, 0, len));<br/>
//12 bytes: ½ + ¼ = ¾<br/>
buf.toString([encoding], [start], [end]) {Function}<br/>
使用指定的编码方式将Buffer从指定起始位置到指定结束位置解码为字符串并返回。编码默认是&#39;utf-8&#39;，起始位置默认是0，结束位置默认为Buffer的长度。<br/>
buf[index] {Byte}<br/>
获取或设置位于索引字节的值。由于返回值为单个的字节，因此其范围应该在0x00到0xff（16进制）或者0到255（10进制）之间。下面是将一个ASCII字符串复制进Buffer，每次一个字节，index.js：<br/>
str = &quot;node.js&quot;;<br/>
buf = new Buffer(str.length);<br/>
for (var i = 0; i &lt; str.length ; i++) {<br/>
  buf[i] = str.charCodeAt(i);<br/>
}<br/>
console.log(buf);<br/>
Buffer.isBuffer(obj) {ClassMethod}<br/>
验证传入的对象是否是Buffer的一个实例。<br/>
Buffer.byteLength(string, [encoding]) {ClassMethod}<br/>
返回字符串的实际字节数。这个方法和String.prototype.length不同，后者返回字符串的字符数。<br/>
byteLength.js：<br/>
str = &#39;\u00bd + \u00bc = \u00be&#39;;</p>

<p>console.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +<br/>
  Buffer.byteLength(str, &#39;utf8&#39;) + &quot; bytes&quot;);</p>

<p>// ½ + ¼ = ¾: 9 characters, 12 bytes<br/>
buf.length {Number}<br/>
Buffer的大小（以字节为单位）。请注意，这个不是存放内容的大小，而是分配buffer对象的内存大小。这个大小不随Buffer中存放内容的多少而改变。<br/>
length.js：<br/>
buf = new Buffer(1234);</p>

<p>console.log(buf.length);// 1234<br/>
buf.write(&quot;some string&quot;, &quot;ascii&quot;, 0);<br/>
console.log(buf.length);// 1234<br/>
buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd]) {Function}<br/>
在两个Buffer之间执行内存拷贝。targetStart和sourceStart默认为0，sourceEnd默认为buf.length。例如，新建连个buffer对象，然后将buf1中16至19字节拷贝到buf2中第8字节开始的空间中。<br/>
copy.js：<br/>
buf1 = new Buffer(26);<br/>
buf2 = new Buffer(26);</p>

<p>for (var i = 0 ; i &lt; 26 ; i++) {<br/>
  buf1[i] = i + 97; // 97 is ASCII a<br/>
  buf2[i] = 33; // ASCII !<br/>
}</p>

<p>buf1.copy(buf2, 8, 16, 20);<br/>
console.log(buf2.toString(&#39;ascii&#39;, 0, 25));<br/>
// !!!!!!!!qrst!!!!!!!!!!!!!<br/>
buf.slice([start], [end]) {Function}<br/>
返回指定起始位置和结束位置的原Buffer引用的分片。当修改新Buffer时也将会被体现在原Buffer上，因为两个Buffer指向同一段内存地址。例如，使用字母表简历一个Buffer对象，并分片出一个新的Buffer，然后修改原始Buffer的一个字节。<br/>
slice.js：<br/>
var buf1 = new Buffer(26);</p>

<p>for (var i = 0 ; i &lt; 26 ; i++) {<br/>
  buf1[i] = i + 97; // 97 is ASCII a<br/>
}</p>

<p>var buf2 = buf1.slice(0, 3);<br/>
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));// abc<br/>
buf1[0] = 33;// ASCII !<br/>
console.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));// !bc<br/>
buf.fill(value, [offset], [end]) {Function}<br/>
用指定的值填充Buffer。如果偏移量offset（默认0）和结束位置end（默认buf.length）都没有值，它将填充整个Buffer。<br/>
fill.js：<br/>
var b = new Buffer(50);<br/>
b.fill(&quot;h&quot;);<br/>
console.log(b);<br/>
buf.inspect()<br/>
返回Buffer的字符串表示，每个字节用十六进制表示。当调用console.dir的时候打印的就是这个方法返回的结果。当Buffer超长（默认为50）时，会用...省略超长的内容。<br/>
buffer.INSPECT_MAX_BYTES  {Number}<br/>
这个数值会在调用buffer.inspect()方法时被用到，默认为50，我们可以直接对这个属性赋值来修改其值的大小。<br/>
注意，这是buffer核心模块的一个属性，需要通过调用require(&#39;buffer&#39;)返回的对象来访问，它不是全局的Buffer或者Buffer实例的属性。<br/>
SlowBuffer {Class}<br/>
SlowBuffer 这个类主要是内部使用。JavaScript程序应该使用Buffer，避免使用SlowBuffer 。SlowBuffer 不是全局的，需要导入后才可以使用。为了避免频繁的给Buffer对象分配小内存块，对于创建小于8k的Buffer，其实是从一个池中分片得来的，只有大于8k的Buffer才会每次都新创建一个SlowBuffer实例。<br/>
Buffer.poolSize {Number}<br/>
Buffer类创建的池大小，大于此值则每次new一个SlowBuffer，否则从池中slice返回一个Buffer，如果池剩余空间不够，则新创建一个SlowBuffer做为池。我们可以直接对这个属性赋值来修改池的大小。<br/>
除了上述方法外，Buffer模块还提供了许多读取和写入各种数值类型的方法，我们可以在Node的官方文档Buffer模块（<a href="http://www.nodejs.org/api/buffer.html%EF%BC%89%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%86%8D%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E3%80%82">http://www.nodejs.org/api/buffer.html）中查看到，这里就不再详细描述。</a></p>

<h3 id="toc_7">4.2　事件模块</h3>

<h4 id="toc_8">4.2.1 Events</h4>

<p>events.EventEmitter {Class}<br/>
事件驱动是Node一个很重要的特点。Node中有很多对象都会触发事件，比如一个进程退出时会触发事件。所有能够触发事件的对象都是EventEmitter的实例。我们可以通过require(&quot;events&quot;)来访问这个模块，通过调用require(&#39;events&#39;).EventEmitter可以使用事件触发器类。通常，事件名称采用驼峰式命名法，不过目前没有对事件名称作任何限制，也就是说任何字符串都可以被用作事件名。<br/>
Event: &#39;newListener&#39;<br/>
可以将函数注册给对象，使其在事件触发时执行，此类函数被称作监听器。当新的事件监听器被添加时，事件触发器都会触发&#39;newListener&#39;事件。<br/>
Event: &#39;error&#39;<br/>
当事件触发器遇到错误时，会触发&#39;error&#39;事件。这个事件特殊的地方在于：如果没有监听器处理这个事件，它将会输出堆栈信息，并退出应用程序。<br/>
emitter.addListener(event, listener) {Function}<br/>
emitter.on(event, listener) {Function}<br/>
这两个方法都可以将一个监听器添加到指定的事件监听器数组的末尾。<br/>
server.on(&#39;connection&#39;, function (stream) {<br/>
  console.log(&#39;someone connected!&#39;);<br/>
});<br/>
emitter.once(event, listener) {Function}<br/>
这个方法可以添加一次性的监听器。该监听器在事件触发第一次时执行，随后被移除。<br/>
server.once(&#39;connection&#39;, function (stream) {<br/>
  console.log(&#39;Ah, we have our first user!&#39;);<br/>
});<br/>
emitter.removeListener(event, listener) {Function}<br/>
将监听器从指定的事件的监听器数组中移除出去。非常值得注意的是：这个操作将会改变监听器数组的下标。<br/>
var callback = function(stream) {<br/>
  console.log(&#39;someone connected!&#39;);<br/>
};<br/>
server.on(&#39;connection&#39;, callback);<br/>
// ...<br/>
server.removeListener(&#39;connection&#39;, callback);<br/>
emitter.removeAllListeners([event]) {Function}<br/>
将指定事件的所有监听器从监听器数组中移除。<br/>
emitter.setMaxListeners(n) {Function}<br/>
默认情况下，当事件触发器注册了超过10个以上的监听器时，系统会打印警告信息。这个默认配置将有助于我们查找内存泄漏问题。很显然并不是所有的事件触发器都需要进行10个监听器的限制，此方法允许我们手动设置该数量值。如果这个值被设置为0，意味着没有数量限制。<br/>
emitter.listeners(event) {Function}<br/>
返回指定事件的监听器数组。我们可以对该数组进行操作，比如删除监听器等。<br/>
server.on(&#39;connection&#39;, function (stream) {<br/>
  console.log(&#39;someone connected!&#39;);<br/>
});<br/>
var listeners = server.listeners(&#39;connection&#39;);<br/>
console.log(util.inspect(listeners);// [ [Function] ]<br/>
emitter.emit(event, [arg1], [arg2], [...]) {Function}<br/>
顺序执行监听器列表中的每个监听器函数并传递相应的参数。</p>

<h3 id="toc_9">4.3　文件和数据流相关模块</h3>

<h4 id="toc_10">4.3.1 Stream</h4>

<p>Stream（流）是一个抽象接口，Node中有很多实例对象实现了这个接口。例如，请求http服务器的request是一个流。所有的流都是EventEmitter的实例。流可以分为可读的、可写的或者既可读又可写。所以下面分两部分来介绍流，一部分为可读流，另一部分来可写流。<br/>
Readable Stream（可读流）具有下述的事件、成员和方法。<br/>
Event: &#39;data&#39; function (data) { }<br/>
&#39;data&#39;事件的回调函数参数默认情况下是一个Buffer对象。如果使用了setEncoding()则参数为一个字符串。<br/>
Event: &#39;end&#39; function () { }<br/>
此事件在流中遇到EOF（TCP中为FIN）时被触发，表示流不会再有数据（不会触发&#39;data事件&#39;）。如果流同时也是可写的，那它还可以继续写入。<br/>
Event: &#39;error&#39; function (exception) { }<br/>
此事件在读取数据出错时被触发。<br/>
Event: &#39;close&#39; function () { }<br/>
当底层的文件描述符被关闭时触发此事件，并不是所有的流都会触发这个事件。例如，一个http请求就不会触发&#39;close&#39;事件。<br/>
Event: &#39;fd&#39; function (fd) { }<br/>
当流读取到文件描述符信息时触发此事件。一个文件数据流包含两部分信息：文件描述符信息和文件数据信息。此事件只支持Unix流，其他类型的流不会触发此事件。<br/>
stream.readable {Boolean}<br/>
这是一个布尔值，默认为true。当读取流遇到错误（&#39;error&#39;事件）或者读到结尾（&#39;end&#39;事件）或者调用destroy()方法后，该值会设置为false。<br/>
stream.setEncoding(encoding) {Function}<br/>
调用此方法后，&#39;data&#39;事件的回调函数参数会由默认的Buffer变为字符串。这个方法的参数编码类型科研室&#39;utf-8&#39;、&#39;ascii&#39;或&#39;base64&#39;。<br/>
stream.pause() {Function}<br/>
暂停&#39;data&#39;事件的触发。<br/>
stream.resume() {Function}<br/>
恢复被pause()方法暂停的&#39;data&#39;事件。<br/>
stream.destroy() {Function}<br/>
关闭底层的文件描述符。流将不会再触发任何事件。<br/>
stream.pipe(destination, [options]) {Function}<br/>
这是Stream.prototype（Stream原型对象）的一个方法，所有Stream对象都可以使用它。这个方法用于将这个可读流与流向目标连接起来，传入这个流中数据将会写入的流向目标中。通过在必要时暂停和恢复流，使来源流和目的流得以保持同步。以模拟Unix系统的cat命令为例：<br/>
process.stdin.resume();<br/>
process.stdin.pipe(process.stdout);<br/>
默认情况下，当来源流的&#39;end&#39;事件出发时，目的流的end()方法会被调用，此时目的流将不再可写入。要在这种情况下为了保持目的流仍然可写入，可将options参数设置为{ end: false}。这使process.stdout保存打开状态，因此&quot;Goodbye&quot;可以在end事件发生后被写入。<br/>
process.stdin.resume();</p>

<p>process.stdin.pipe(process.stdout, { end: false });</p>

<p>process.stdin.on(&quot;end&quot;, function() {<br/>
  process.stdout.write(&quot;Goodbye\n&quot;);<br/>
});<br/>
注意：如果来源流不支持pause()和resume()方法，pipe此方法将在来源流对象上增加这两个方法的简单定义，使其可以触发&#39;pause&#39;和&#39;resume&#39;事件。<br/>
Writable Stream（可写流）具有下述的事件、成员和方法。<br/>
Event: &#39;drain&#39; function () { }<br/>
当在write()方法被调用并返回false后触发此事件。此事件被触发说明缓冲区已空，再次写入是安全的。<br/>
Event: &#39;error&#39; function (exception) { }<br/>
此事件在发生错误的时候被触发，回调函数接受一个异常参数exception。<br/>
Event: &#39;close&#39; function () { }<br/>
底层文件描述符被关闭时触发此事件。<br/>
Event: &#39;pipe&#39; function (src) { }<br/>
当此可写流作为参数传给一个可读流的pipe方法时触发此事件。<br/>
stream.writable {Boolean}<br/>
这是一个布尔值，默认为true。当读取流遇到错误（&#39;error&#39;事件）或者end()/destroy()方法被调用后，该值会设置为false。<br/>
stream.write(string, [encoding], [fd]) {Function}<br/>
使用指定编码encoding将字符串string写入到流中。如果字符串被成功写入内核缓冲区，此方法返回true。如果内核缓冲区已满，此方法返回false，数据将在未来被写出。当内核缓冲区再次被清空后，&#39;drain&#39;事件将被触发。Encoding参数默认为&#39;utf-8&#39;。<br/>
如果指定了可选参数fd，它将被作为一个文件描述符通过流传送。此功能仅被Unix流所支持，对于其他流此操作将被忽略而没有任何提示。当使用此方法传送一个文件描述符时，如果在流没有清空前关闭此文件描述符，将造成传送一个无效（已关闭）FD的风险。<br/>
stream.write(buffer) {Function}<br/>
与上面的write方法类似，写入一个Buffer对象。<br/>
stream.end() {Function}<br/>
使用EOF或FIN结束一个流的输出。<br/>
stream.end(string, encoding) {Function}<br/>
以指定的字符编码encoding写入一个字符串string，然后使用EOF或FIN结束流的输出。这对降低数据包传输量有所帮助。<br/>
stream.end(buffer) {Function}<br/>
与上面的end方法类似，写入一个Buffer对象，然后使用EOF或FIN结束流的输出。<br/>
stream.destroy() {Function}<br/>
关闭底层的文件描述符。流将不会再触发任何事件。<br/>
stream.destroySoon() {Function}<br/>
清空当前的写队列（写操作完成），然后关闭文件描述符。</p>

<h4 id="toc_11">4.3.2 Readline</h4>

<p>Readline模块可以帮助我们一行一行地读取一个流（如STDIN）。我们可以调用require(&#39;readline&#39;)来使用此模块。<br/>
注意：一旦我们调用这个模块，Node程序不会终止，直到我们关闭这个接口和STDIN流。如何正常终止我们的程序，请看下面的例子。<br/>
createInterface.js:<br/>
var rl = require(&#39;readline&#39;);</p>

<p>var i = rl.createInterface(process.stdin, process.stdout, null);<br/>
i.question(&quot;What do you think of node.js?&quot;, function(answer) {<br/>
  // TODO: Log the answer in a database<br/>
  console.log(&quot;Thank you for your valuable feedback.&quot;);</p>

<p>// These two lines together allow the program to terminate. <br/>
  // Without them, it would run forever.<br/>
  i.close();<br/>
  process.stdin.destroy();<br/>
});<br/>
rl.createInterface(input, output, completer) {Function}<br/>
创建一个读行接口，方法接收的参数是输入input与输出output两个流。参数completer是一个方法，用于自动完成。当接收到一个子串，它会返回[[substr1, substr2, ...], originalsubstring]。Completer方法也可以在异步模式下运行，这样它需要接收两个参数：<br/>
function completer(linePartial, callback) { callback(null, [[&#39;123&#39;], linePartial]); }<br/>
createInterface这个方法常与process.stdin和 process.stdout并用，以接收用户输入。<br/>
Interface {Class}<br/>
用于stdin和stdout这两个流进行一行一行读取流操作的抽象接口类。<br/>
rl.setPrompt(prompt, length) {Function}<br/>
设置提示。比如当你在Node命令行模式（在终端上直接运行node命令不带任何参数即可进入命令行模式）上时，你会看到这样的提示&#39;&gt;&#39;。<br/>
rl.prompt() {Function}<br/>
用当前的提示信息新起一行以供用户输入，并准备好从用户输入读取一行。<br/>
rl.question(query, callback) {Function}<br/>
先显示提示信息query，然后调用callback这个回调函数来响应用户的输入。<br/>
rl.close() {Function}<br/>
关闭TTY。<br/>
rl.pause() {Function}<br/>
暂停TTY。<br/>
rl.resume() {Function}<br/>
恢复TTY。<br/>
rl.write() {Function}<br/>
写入TTY。<br/>
Event: &#39;line&#39; function (line) {}<br/>
当在流中接收到\n就会触发此事件。通常当用户敲打回车或者退出就会触发此事件。这是一个很好的钩子去监听用户的输入。例如这样监听每一行的输入：<br/>
rl.on(&#39;line&#39;, function (cmd) {<br/>
  console.log(&#39;You just typed: &#39;+cmd);<br/>
});<br/>
Event: &#39;close&#39; function () {}<br/>
当在流中接收到<sup>C（SIGINT）或<sup>D（EOT）就会触发此事件。这是一个探知用户已经完成使用应用程序的很好的方式。例如可以这样监听close事件，并随后退出程序:</sup></sup><br/>
rl.on(&#39;close&#39;, function() {<br/>
  console.log(&#39;goodbye!&#39;);<br/>
  process.exit(0);<br/>
});<br/>
这里有一个如何融合使用前面介绍的事件和方法模拟出一个简单的命令行交互的例子，readline.js:<br/>
var readline = require(&#39;readline&#39;),<br/>
  rl = readline.createInterface(process.stdin, process.stdout),<br/>
  prefix = &#39;OHAI&gt; &#39;;</p>

<p>rl.on(&#39;line&#39;, function(line) {<br/>
  switch(line.trim()) {<br/>
    case &#39;hello&#39;:<br/>
      console.log(&#39;world!&#39;);<br/>
      break;<br/>
    default:<br/>
      console.log(&#39;Say what? I might have heard <code>&#39; + line.trim() + &#39;</code>&#39;);<br/>
      break;<br/>
  }<br/>
  rl.setPrompt(prefix, prefix.length);<br/>
  rl.prompt();<br/>
}).on(&#39;close&#39;, function() {<br/>
  console.log(&#39;Have a great day!&#39;);<br/>
  process.exit(0);<br/>
});<br/>
console.log(prefix + &#39;Good to see you. Try typing stuff.&#39;);<br/>
rl.setPrompt(prefix, prefix.length);<br/>
rl.prompt();</p>

<h4 id="toc_12">4.3.3 TTY</h4>

<p>在Linux中，TTY也许是跟终端有关系的最为混乱的术语。TTY是TeleTYpe的一个老缩写。Teletypes，或者teletypewriters，原来指的是电传打字机，是通过串行线用打印机键盘通过阅读和发送信息的东西，和古老的电报机区别并不是很大。之后，当计算机只能以批处理方式运行时(当时穿孔卡片阅读器是唯一一种使程序载入运行的方式)，电传打字机成为唯一能够被使用的“实时”输入/输出设备。最终，电传打字机被键盘和显示器终端所取代，但在终端或TTY接插的地方，操作系统仍然需要一个程序来监视串行端口。TTY也可以简单理解为一个程序监视物理的TTY/终端接口。我们可以调用require(&#39;tty&#39;)来使用此模块。<br/>
tty.js:<br/>
var tty = require(&#39;tty&#39;);<br/>
process.stdin.resume();<br/>
tty.setRawMode(true);<br/>
process.stdin.on(&#39;keypress&#39;, function(char, key) {<br/>
  if (key &amp;&amp; key.ctrl &amp;&amp; key.name == &#39;c&#39;) {<br/>
    console.log(&#39;graceful exit&#39;);<br/>
    process.exit();<br/>
  }<br/>
});<br/>
tty.isatty(fd) {Function}<br/>
这个方法返回一个布尔值。这取决于文件描述符fd是否和本终端有关联，有关联返回true，否则返回false。<br/>
tty.setRawMode(mode) {Function}<br/>
参数mode是一个布尔值，可以被设置为true或false。此方法可以改变当前进程的stdin（标准输入）为原始设备方式或默认方式。</p>

<h4 id="toc_13">4.3.4 Path</h4>

<p>Path模块包含很多用于处理文件路径的小工具。几乎所有方法仅仅是执行字符串的转换，并没有去文件系统检查是否是有效的路径。Path.exists和path.existsSync这两个方法是例外，很容易发现这两个方法是在访问文件系统。我们可以调用require(&#39;path&#39;)来使用此模块。<br/>
path.normalize(p)<br/>
该方法用于标准化一个字符型的路径。请注意&#39;..&#39;和&#39;.&#39;的使用。当发现有多个斜杠（/）时，系统会将他们替换为一个斜杠；如果路径末尾中包含有一个斜杠，那么系统会保留这个斜杠。在Windows中，上述路径中的斜杠（/）要换成反斜杠（\）。<br/>
normalize.js:<br/>
var path = require(&#39;path&#39;);<br/>
var string = &#39;/foo/bar//baz/asdf/quux/..&#39;;<br/>
string = path.normalize(string);<br/>
console.log(string);<br/>
// returns  &#39;/foo/bar/baz/asdf&#39;<br/>
path.join([path1], [path2], [...])<br/>
该方法用于合并传入的参数得到一个标准化的路径字符串。<br/>
join.js：<br/>
var path = require(&#39;path&#39;);<br/>
var string = path.join(&#39;/foo&#39;, &#39;bar&#39;, &#39;baz/asdf&#39;, &#39;quux&#39;, &#39;..&#39;);<br/>
console.log(string);<br/>
// returns  &#39;/foo/bar/baz/asdf&#39;<br/>
path.resolve([from ...], to)<br/>
将参数to解析为绝对路径。如果参数 to当前不是绝对的，系统会将from 参数按从右到左的顺序依次前缀到to上，直到在from中找到一个绝对路径时停止。如果遍历所有from中的路径后，系统依然没有找到一个绝对路径，那么当前工作目录也会作为参数使用。最终得到的路径是标准化的字符串，并且标准化时系统会自动删除路径末尾的斜杠，但是如果获取的路径是解析到根目录的，那么系统将保留路径末尾的斜杠。你也可以将这个方法理解为Shell中的一组cd命令。path.resolve(&#39;foo/bar&#39;, &#39;/tmp/file/&#39;, &#39;..&#39;, &#39;a/../subfile&#39;)就类似于：<br/>
cd foo/bar<br/>
cd /tmp/file/<br/>
cd ..<br/>
cd a/../subfile<br/>
pwd<br/>
该方法与cd命令的区别在于该方法中不同的路径不一定存在，而且这些路径也可能是文件。<br/>
resolve.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;)<br/>
// returns &#39;/foo/bar/baz&#39;</p>

<p>path.resolve(&#39;/foo/bar&#39;, &#39;/tmp/file/&#39;)<br/>
// returns &#39;/tmp/file&#39;</p>

<p>path.resolve(&#39;wwwroot&#39;, &#39;static_files/png/&#39;, &#39;../gif/image.gif&#39;)<br/>
// if currently in /home/myself/node, it returns<br/>
// &#39;/home/myself/node/wwwroot/static_files/gif/image.gif&#39;<br/>
path.relative(from, to)<br/>
解析参数，返回相对路径。有时我们有两个绝对路径，我们需要获得从一个到另一个的相对路径。这实际上相当于path.resolve的反向转换，就像这样：<br/>
path.resolve(from, path.relative(from, to)) == path.resolve(to)<br/>
relative.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.relative(&#39;C:\orandea\test\aaa&#39;, &#39;C:\orandea\impl\bbb&#39;);<br/>
// returns &#39;..\..\impl\bbb&#39;</p>

<p>path.relative(&#39;/data/orandea/test/aaa&#39;, &#39;/data/orandea/impl/bbb&#39;);<br/>
// returns &#39;../../impl/bbb&#39;<br/>
path.dirname(p)<br/>
该方法返回一个路径的目录名，类似于Unix中的dirname命令。<br/>
dirname.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.dirname(&#39;/foo/bar/baz/asdf/quux&#39;)<br/>
// returns &#39;/foo/bar/baz/asdf&#39;<br/>
path.basename(p, [ext])<br/>
该方法返回一个路径中最低一级目录名，类似于Unix中的 basename命令。<br/>
basename.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;);<br/>
// returns &#39;quux.html&#39;</p>

<p>path.basename(&#39;/foo/bar/baz/asdf/quux.html&#39;, &#39;.html&#39;);<br/>
// returns &#39;quux&#39;<br/>
path.extname(p)<br/>
该方法返回路径中的文件扩展名，即路径最低一级的目录中&#39;.&#39;字符后的任何字符串。如果路径最低一级的目录中&#39;没有&#39;.&#39; 或者只有&#39;.&#39;，那么该方法返回一个空字符串。<br/>
extname.js:<br/>
var path = require(&#39;path&#39;);<br/>
path.extname(&#39;index.html&#39;);<br/>
// returns &#39;.html&#39;</p>

<p>path.extname(&#39;index&#39;);<br/>
// returns &#39;&#39;<br/>
path.exists(p, [callback])<br/>
该方法用于测试参数p中的路径是否存在。然后以true或者false作为参数调用callback回调函数。<br/>
exists.js:<br/>
var path = require(&#39;path&#39;);<br/>
var util = require(&#39;util&#39;);<br/>
path.exists(&#39;/etc/passwd&#39;, function (exists) {<br/>
  util.debug(exists ? &quot;it&#39;s there&quot; : &quot;no passwd!&quot;);<br/>
});<br/>
path.existsSync(p)<br/>
path.exists的同步方法。</p>

<h4 id="toc_14">4.3.5 File System</h4>

<p>文件的I/O是由标准POSIX函数封装而成。需要使用require(&#39;fs&#39;)访问这个模块。所有的方法都提供了异步和同步两种方式。异步形式下，方法的最后一个参数需要传入一个执行完成时的回调函数。传给回调函数的参数取决于具体的异步方法，但第一个参数总是保留给异常对象。如果操作成功，那么该异常对象就变为null或者undefined。<br/>
这里是一个异步调用的例子：<br/>
var fs = require(&#39;fs&#39;);<br/>
fs.unlink(&#39;/tmp/hello&#39;, function (err) {<br/>
  if (err) throw err;<br/>
  console.log(&#39;successfully deleted /tmp/hello&#39;);<br/>
});<br/>
这里是进行相同操作的同步调用的例子：<br/>
var fs = require(&#39;fs&#39;);<br/>
fs.unlinkSync(&#39;/tmp/hello&#39;)<br/>
console.log(&#39;successfully deleted /tmp/hello&#39;);<br/>
由于异步方法调用无法保证执行的顺序，所以下面的代码容易导致出现错误。<br/>
fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, function (err) {<br/>
  if (err) throw err;<br/>
  console.log(&#39;renamed complete&#39;);<br/>
});<br/>
fs.stat(&#39;/tmp/world&#39;, function (err, stats) {<br/>
  if (err) throw err;<br/>
  console.log(&#39;stats: &#39; + JSON.stringify(stats));<br/>
});<br/>
这样做有可能导致fs.stat在fs.rename之前执行，正确的做法是链式调用回调函数。<br/>
fs.rename(&#39;/tmp/hello&#39;, &#39;/tmp/world&#39;, function (err) {<br/>
  if (err) throw err;<br/>
  fs.stat(&#39;/tmp/world&#39;, function (err, stats) {<br/>
    if (err) throw err;<br/>
    console.log(&#39;stats: &#39; + JSON.stringify(stats));<br/>
  });<br/>
});<br/>
当需要频繁操作时，强烈建议使用异步方法。同步方式在其完成之前将会阻塞当前的整个进程，即搁置所有连接。</p>

<p>Node会跳到上层目录完成同样的动作，知道模块被找到，或者到达根目录为止。例如，如果在文件&#39;/home/ry/projects/foo.js&#39;中调用require(&#39;bar.js&#39;)，Node会在下列位置查找，顺序如下：<br/>
/home/ry/projects/node_modules/bar.js<br/>
/home/ry/node_modules/bar.js<br/>
/home/node_modules/bar.js<br/>
/node_modules/bar.js<br/>
Node允许用户在独立的文件夹中方便的组织程序，为这个文件夹指定一个单一的入口后可以把这个文件夹当作模块被加载。</p>

<h4 id="toc_15">4.3.6 Crypto</h4>

<p>有三种方式可以将文件夹作为require函数的参数。第一种方式是在该文件夹中创建package.json文件，指定一个main模块，一个简单的package.json文件会是这样：<br/>
{ &quot;name&quot; : &quot;some-library&quot;,<br/>
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }<br/>
如果此文件位于./some-library文件夹，加载这个文件夹可以调用require(&#39;./some-library&#39;)，这时会尝试加载./some-library/lib/some-library.js。如果Node在该文件夹下没有找到package.json这个文件，那么Node将依次尝试加载改文件夹下的index.js或index.node文件。例如，如果上面的例子找不到package.json，那么会依次尝试加载：<br/>
./some-library/index.js<br/>
./some-library/index.node</p>

<h4 id="toc_16">4.3.7 ZLIB</h4>

<p>Node模块在首次加载成功后会被缓存起来，这意味着同一模块每次调用require方法得到的是完全相同的对象。</p>

<p>整理后记：这四篇文章以前是想整理一本node书籍的，但是由于琐事没坚持下来。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-10-small-test-node-module.html">小试Node Node模块</a></h1>
			<p class="meta"><time datetime="2012-10-10T18:28:07+08:00" 
			pubdate data-updated="true">2012/10/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>模块是Node的基本单位，让我们从模块开始深入了解Node。</p>

<h3 id="toc_0">3.1　CommonJS规范</h3>

<p>JavaScript是一门强大的面向对象的语言，但是JavaScript的标准定义是为了构建基于浏览器的应用程序，它没有一个用于更广泛的应用程序的标准库。CommonJS（官方主页 <a href="http://www.commonjs.org">http://www.commonjs.org</a> ）定义了很多用于普通应用程序（主要指非浏览器应用）使用的API，从而弥补了这个空白。</p>

<p>CommonJS是一种规范，内容包括模块、二进制、编码、文件、系统、断言、套接字、事件队列等。Node是CommonJS的一种实现，但是只实现了它的部分规范。CommonJS有很多实现，如SeaJS、CouchDB和RequireJS等。这些项目大部分也只实现了CommonJS的部分规范（可以在这里查看某个项目的实现部分 <a href="http://www.commonjs.org/impl/">http://www.commonjs.org/impl/</a> ）。</p>

<p>先简要说明一下CommonJS规范对模块的定义。每个模块都有对应的标识符，而标识符有两种：相对标识符与绝对标识符。模块的上下文中有require、exports两个变量。模块的加载是通过模块中的require函数完成，参数是模块的标识符，返回值是被加载模块向外exports导出的属性或方法。</p>

<h3 id="toc_1">3.2　第一个 Node模块</h3>

<p>Node有一个简明的模块加载系统。一个文件就可以被作为一个模块使用，比如，在foo.js文件中加载同一目录下的circle.js模块。</p>

<p>circle.js：</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre>

<p>foo.js：</p>

<pre><code>var circle = require(&#39;./circle.js&#39;);
console.log( &#39;The area of a circle of radius 4 is &#39;+ circle.area(4));
</code></pre>

<p>Node模块的定义和使用都非常的简单，只需调用require方法加载模块即可。在foo.js文件中调用require方法完成对circle.js的加载，这样就可以在foo.js文件中使用circle.js文件中定义并exports导出的函数了。这里require的参数是一个相对路径定义的模块标识符。使用相对路径定义的模块的标识符以“./”或者“../”开头，前者表示当前文件夹，后者表示上级文件夹。使用绝对路径定义的模块的标识符以“/”开头，这种方法定义的标识符和文件系统的根目录相关。</p>

<h3 id="toc_2">3.3　模块的分类和加载</h3>

<p>Node模块可以分成两类，一类为核心模块，一类为文件模块。<br/>
核心模块在Node源代码编译的时候已经被编译成了二进制可执行文件。核心模块的源代码在Node源代码的lib文件夹中可以找到。调用require函数加载模块时，核心模块总是优先被加载。核心模块的模块标识符就是模块名，前面米有路径。例如，require(&#39;http&#39;)总是返回核心模块HTTP模块。核心模块的说明文档可以在官网上面很容易被找到。</p>

<p>文件模块是动态加载的，加载速度较核心模块较慢。文件模块包含三种文件，扩展名分别为.js、.json和.node。文件模块的模块标识符是使用相对路径或者绝对路径定义的模块标识符。如果模块标识符不包含文件的扩展名，显然这样Node无法找到确切的文件，Node将依次将.js、.json、.node三种扩展名添加上再进行加载。例如执行require(&#39;./circle&#39;)时首先查找当前目录circle文件，然后再尝试circle.js文件，加载成功即返回。.js文件被视为JavaScript文本文件，通过核心模块fs模块被读取后编译并执行；.json文件被视为JSON文本文件，读取后会调用JSON.parse被解析加载；.node被视为已编译的C/C++插件模块，通过dlopen方法进行加载。</p>

<p>如果传递给require函数的模块标识符不以“/”、“./”或“../”开头，也不是核心模块名，这时Node会从当前模块所在的目录下的node_modules这个文件夹下查找文件尝试加载。如果还是没有找到，那么Node会跳到上层目录完成同样的动作，知道模块被找到，或者到达根目录为止。例如，如果在文件&#39;/home/ry/projects/foo.js&#39;中调用require(&#39;bar.js&#39;)，Node会在下列位置查找，顺序如下：</p>

<pre><code>/home/ry/projects/node_modules/bar.js
/home/ry/node_modules/bar.js
/home/node_modules/bar.js
/node_modules/bar.js
</code></pre>

<p>Node允许用户在独立的文件夹中方便的组织程序，为这个文件夹指定一个单一的入口后可以把这个文件夹当作模块被加载。有三种方式可以将文件夹作为require函数的参数。第一种方式是在该文件夹中创建package.json文件，指定一个main模块，一个简单的package.json文件会是这样：</p>

<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }
</code></pre>

<p>如果此文件位于./some-library文件夹，加载这个文件夹可以调用require(&#39;./some-library&#39;)，这时会尝试加载./some-library/lib/some-library.js。如果Node在该文件夹下没有找到package.json这个文件，那么Node将依次尝试加载改文件夹下的index.js或index.node文件。例如，如果上面的例子找不到package.json，那么会依次尝试加载：</p>

<pre><code>./some-library/index.js
./some-library/index.node
</code></pre>

<p>除了上述的查找目录，Node还会去全局的模块目录查找。如果在系统的环境变量中添加了NODE_PATH，Node会去NODE_PATH 设置的目录中去查找。NODE_PATH 配置的目录为绝对路径，允许多个，用冒号:隔开（Windows下使用分号;）。如果模块还没有找到，Node还会从下面的目录查找：</p>

<pre><code>$HOME/.node_modules
$HOME/.node_libraries
$PREFIX/lib/node
</code></pre>

<p>\(HOME是用户主目录，\)PREFIX是Node安装目录的前缀。</p>

<p>Node模块在首次加载成功后会被缓存起来，这意味着同一模块每次调用require方法得到的是完全相同的对象。</p>

<h3 id="toc_3">3.4　NPM Node包管理器</h3>

<p>NPM（Node  Package Manager），是一个Node包管理工具。NPM可以帮助你很方便的进行包的下载、安装和管理。NPM的实现大部分也遵循CommonJS规范中对包的定义（ <a href="http://wiki.commonjs.org/wiki/Packages/1.0">http://wiki.commonjs.org/wiki/Packages/1.0</a> ）。</p>

<p>一个NPM包有如下结构：<br/>
* package.json文件位于包顶级目录下，记录包的相关信息；<br/>
* bin目录下存放C/C++扩展编译后的二进制文件；<br/>
* lib目录下存放JavaScript代码文件。<br/>
* doc目录下存放文档；<br/>
* test目录下存放测试代码。</p>

<p>一个基本的package.json文件是这样的：</p>

<pre><code>{
  &quot;name&quot;: &quot;chapter3&quot;, 
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;main&quot;: &quot;./index.js&quot;, 
  &quot;dependencies&quot;: {
    &quot;pinyin&quot;: &quot;0.0.1&quot;
  }
}
</code></pre>

<p>name是包名，在NPM库中是唯一的；version是用于标识包的版本，通常为x.y.z；dependencies用于声明需要的依赖。其他字段的说明可以在CommonJS规范中对包的定义的文档中查看。</p>

<h3 id="toc_4">3.5　NPM常用命令介绍</h3>

<p>NPM通过使用npm命令来完成对包的管理操作，这些命令涉及到一个Node包整个生命周期的每一个操作，包括发布、下载、使用或者移除等。</p>

<p>npm install packageName<br/>
安装一个指定包名的Node包到当前文件夹。<br/>
npm install -g packageName<br/>
安装一个指定包名的Node包到Node的安装目录。<br/>
npm install<br/>
如果命令中不指定包名，则在当前文件中中寻找package.json文件读取dependencies的值进行安装。<br/>
npm uninstall packageName<br/>
卸载一个指定包名的Node包。<br/>
npm update packageName<br/>
更新一个指定包名的Node包。<br/>
npm adduser<br/>
在NPM仓库上注册一个账号，需要填写用户名、密码和电子邮件地址。<br/>
npm init<br/>
初始化一个Node包，根据输入的内容创建一个package.json文件。<br/>
npm publish<br/>
发布一个Node包。<br/>
npm unpublish<br/>
移除一个Node包。<br/>
npm search packageName<br/>
查找一个指定包名的Node包。<br/>
npm help <command><br/>
获取npm的帮助信息。</p>

<p>以上仅仅只介绍了一些相对比较常用的命令，其他命令及详细使用说明可以使用help命令查看，或者在NPM的官方网站（ <a href="http://npmjs.org/">http://npmjs.org/</a> ）查看。NPM除了提供search命令用来查找Node包，NPM也提供了网页的形式（ <a href="http://search.npmjs.org/">http://search.npmjs.org/</a> ）供访问。现在通过NPM发布的Node包的数量已经达到一万多。如果你开发了一个Node包，非常期待你发布到NPM上去，为Node平台添砖加瓦。</p>

<h3 id="toc_5">3.6　依赖的问题</h3>

<h4 id="toc_6">3.6.1  循环依赖</h4>

<p>循环依赖，是指两个文件互引用对方。例如a.js文件中require b.js文件，而b.js文件中又require a.js文件，这样造成一个死循环。让我们来看一下的代码：<br/>
 a.js：</p>

<pre><code>console.log(&#39;a starting&#39;);
exports.done = false;
var b = require(&#39;./b.js&#39;);
console.log(&#39;in a, b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a done&#39;);
</code></pre>

<p>b.js：</p>

<pre><code>console.log(&#39;b starting&#39;);
exports.done = false;
var a = require(&#39;./a.js&#39;);
console.log(&#39;in b, a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b done&#39;);
</code></pre>

<p>main.js：</p>

<pre><code>console.log(&#39;main starting&#39;);
var a = require(&#39;./a.js&#39;);
var b = require(&#39;./b.js&#39;);
console.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done);

</code></pre>

<p>当main.js加载a.js时，a.js也会加载b.js。在这个时候b.js也会反过来加载a.js。为了防止这样一个死循环，a.js返回了一个未完成的exports对象给b.js。当b.js加载完成，它会将它的exports对象返回给a.js，然后a.js会继续完成加载。运行main.js输出如下：</p>

<pre><code>main starting 
a starting 
b starting 
in b, a.done = false 
b done 
in a, b.done = true 
a done 
in main, a.done=true, b.done=true 
</code></pre>

<h4 id="toc_7">3.6.1  传递依赖</h4>

<p>传递依赖，是指重复的间接依赖。Node对模块有缓存机制，Node是靠模块的路径来判断是否已经被加载的，当这个模块的路径变了，就会被重新加载。当然在我们自己的应用中不会把一个文件拷贝成双份放到两个不同的目录然后去使用，这种重复加载的情况完全可以避免。但是当Node包出现传递依赖的时候，就会出现模块被重复加载。例如，一个项目同时依赖mine包和express包，express也依赖mine包，使用NPM安装包后文件目录结构如下：</p>

<pre><code>./node_modules
├── mime
└── express
    └── node_modules
        └── mime
</code></pre>

<p>从目录上可以看到mime包出现了两次，可以说有两个完全相同的包，这个包中的模块会被重复加载两次，产生了两个模块的实例。</p>

<p>如果你对Maven很熟悉，你会知道Maven在处理传递依赖的版本确定规则为：深度越浅，越被优先选择；若两个依赖包处于依赖树的同一层则优先选择排列在前面的。Node中的包是以文件夹的形式存在的，所以不会存在同一层中存在相同的包。当两个依赖包处于不同层时，Maven不管两个包的版本只会选择深度较浅的那个依赖包，也就是说只会选择一个版本。Node则不然，Node会产生两个不同的实例，会多版本共存。如果你想避免这种重复加载，你可以手动删除深度较深的包，只保留在公共路径上的包。</p>

<p>当嵌套依赖关系的层次很深时，文件的查找列表可能会变的很长。因此Node在查找时进行如下优化：/node_modules不会附加到一个以/node_modules结尾的文件夹后面。例如，如果在文件&#39;/home/ry/projects/foo/node_modules/bar/node_modules/baz/quux.js&#39;中调用require函数时，会搜索如下目录：</p>

<pre><code>/home/ry/projects/foo/node_modules/bar/node_modules/baz/node_modules/
/home/ry/projects/foo/node_modules/bar/node_modules/node_modules/
/home/ry/projects/foo/node_modules/bar/node_modules/
/home/ry/projects/foo/node_modules/node_modules/
/home/ry/projects/foo/node_modules/
/home/ry/projects/node_modules/
/home/ry/node_modules/
/home/node_modules/
/node_modules/
</code></pre>

<h3 id="toc_8">3.7　小结</h3>

<p>我们在这一章学习了Node的模块和包，具体内容如下：<br/>
* CommonJS是一种规范，Node是CommonJS的一种实现； <br/>
* Node模块可以分成两类，一类为核心模块，一类为文件模块；<br/>
* NPM，是一个Node包管理工具，过使用npm命令来完成对包的管理操作；<br/>
* Node模块存在循环依赖和传递依赖这两种问题，在使用中需要注意。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-09-small-test-hello-node.html">小试Node Hello Node</a></h1>
			<p class="meta"><time datetime="2012-10-09T18:26:57+08:00" 
			pubdate data-updated="true">2012/10/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Node还很年轻，正处于快速发展中，版本更新速度也很快。下面内容介绍的是最新的0.6.x（笔者使用的是0.6.18版本，如果版本号不同，只需替换版本号即可）的版本安装和配置。如果你想使用旧版本（比如0.4.x），安装和配置会不尽相同，请借助搜索引擎搜索安装和配置方法。</p>

<h3 id="toc_0">2.1　安装Node</h3>

<h4 id="toc_1">2.1.1  Windows平台下安装</h4>

<p>在Node官方网站上面下载安装文件（ <a href="http://nodejs.org/dist/v0.6.18/node-v0.6.18.msi">http://nodejs.org/dist/v0.6.18/node-v0.6.18.msi</a> ），双击即可在程序的引导下完成安装。完成以上操作后，检查一下是否安装成功：</p>

<p><code>node -v</code></p>

<p>检查是否返回：</p>

<p><code>v0.6.18</code></p>

<p>至此，Node已经安装完成。如需卸载，可以在控制面板\程序\程序和功能中找到Node进行卸载。</p>

<h4 id="toc_2">2.1.1  Unix/Linux平台下安装</h4>

<pre><code>wget http://nodejs.org/dist/v0.6.18/node-v0.6.18.tar.gz 
tar zxvf node-v0.6.1.tar.gz 
cd node-v0.6.1 
./configure 
</code></pre>

<p>上面几行命令是通过wget命令下载最新版本的代码，并解压之。./configure命令将会检查环境是否符合Node的编译要求。如果检查没有通过，请安装提示需要的库。如果configure命令执行成功，就可以进行编译了：</p>

<pre><code>make 
make install 
</code></pre>

<p>Node通过make工具进行编译和安装（如果make install不成功，请使用sudo以确保拥有权限）。完成以上操作后，检查一下是否安装成功：</p>

<p><code>node -v</code></p>

<p>检查是否返回：</p>

<p><code>v0.6.18</code></p>

<p>至此，Node已经编译并安装完成。如需卸载，可以执行make uninstall进行卸载。</p>

<h3 id="toc_3">2.2　安装NPM</h3>

<p>NPM(Node Package Manager)是Node的模块管理器。最新版本的Node已经内置了NPM，无需另行安装。可以在安装Node完成后，检查NPM是否已经安装成功：</p>

<p><code>npm -v</code></p>

<p>检查是否返回：</p>

<p><code>1.1.21</code></p>

<p>至此，Node和NPM都已经安装完成。</p>

<h3 id="toc_4">2.3　Hello World!</h3>

<p>我们从最简单的Hello World开始我们的Node之旅。新建一个文件helloworld.js，并编写代码。</p>

<p><code>console.log(&#39;Hello World!&#39;);</code></p>

<p>现在我们要运行这个代码文件。这个操作非常简单，直接输入以下命令即可运行：</p>

<pre><code>node helloworld.js 
Hello World! 
</code></pre>

<p>用node命令加上文件名即可运行代码文件，在运行成功后打印输出了HelloWorld!，打印完成后程序自动停止退出。<br/>
下面我们来启动一个HTTP服务器，当在浏览器访问时，会向浏览器输出HelloWorld!。新建一个文件http.js，并编写代码。</p>

<pre><code>var http = require(&#39;http&#39;);
http.createServer(function (req, res) {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;Hello World!\n&#39;);
}).listen(1337, &#39;127.0.0.1&#39;);
console.log(&#39;Server running at http://127.0.0.1:1337/&#39;);
</code></pre>

<p>使用node命令运行这个文件：</p>

<pre><code>node http.js 
Server running at http://127.0.0.1:1337/ 
</code></pre>

<p>这样就启动了一个用Node编写的最简单的HTTP服务器。你会发现这次运行的代码在运行到最后一行后不会自动停止退出，去系统进程列表可以找到一个node的进程一直在运行。这是因为listen函数创建了一个监听1337端口的监听器。这个事件监听器会使http.js一直保持执行状态，知道你在终端窗口中执行退出操作，如Ctrl+C。你可以在任意浏览器中访问<a href="http://127.0.0.1:1337/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E5%A6%82%E5%9B%BE%E6%89%80%E7%A4%BA%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9A">http://127.0.0.1:1337/就可以看到如图所示的结果：</a></p>

<p><img src="/resource/image/2012-10-09-small-test-hello-node/helloworld.png" alt="浏览器结果"/></p>

<h3 id="toc_5">2.4　小结</h3>

<p>我们在这一章学习了Node和NPM的安装，并编写和运行了两个简单的Node程序。<br/>
本章具体内容包括：<br/>
* Node和NPM的安装，并验证是否安装成功； <br/>
* 如何运行和停止代码；<br/>
* 用Node编写的一个最简单的HTTP服务器。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-10-08-small-test-node-introduction.html">小试Node 简介</a></h1>
			<p class="meta"><time datetime="2012-10-08T18:25:34+08:00" 
			pubdate data-updated="true">2012/10/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Node（或者Node.js），是一个构建于Google Chrome JavaScript运行环境（runtime）之上的一个平台，为了提供一种简单的构建快速、可伸缩的网络程序的方法。Node采用事件驱动、非阻塞/异步IO模型，使得它轻量高效，可完美地构建运行于分布式环境的数据密集型即时应用程序。</p>

<h3 id="toc_0">1.1　Node不是什么</h3>

<p>Node不是JavaScript，也不是JavaScript应用。Node是一个平台，是一个JavaScript运行环境。Node可以让JavaScript摆脱浏览器的束缚，在浏览器之外运行JavaScript，但是Node绝对不仅仅是JavaScript。Node之所以采用了Google Chrome浏览器的V8引擎来解释和执行JavaScript代码，除了V8引擎性能优异，还因为V8引擎可以独立运行，并支持将其嵌入任何C++应用程序进行扩展。Node除了提供可以运行JavaScript的运行环境，还用编写了很多系统级的API，比如网络，文件等。这样Node就可以用来开发系统级或者服务器端的应用程序。</p>

<h3 id="toc_1">1.2　Node的特点</h3>

<h4 id="toc_2">1.2.1　事件驱动、非阻塞/异步IO</h4>

<p>Node以单进程、单线程的模式运行，它通过事件轮询来完成并行操作。Node内部采用了一些非阻塞“库”来支持实现事件轮询，目的就是可以为耗费资源的操作提供回调操作。当你像文件系统发送一个请求时，无需等待硬盘完成复杂的寻址和检索文件操作，硬盘在完成这些耗时操作时会触发完成事件通知Node，继续调用执行回调函数完成后序操作。Node代码在运行时会一直执行，不会阻塞的等待某个结果返回（如请求访问一个文件），阻塞的部分会靠事件监听来完成，这样就构成了事件驱动模型。</p>

<h4 id="toc_3">1.2.2　性能优异</h4>

<p>创始人Ryan Dahl在早期分享过一个测试程序（<a href="http://nodejs.org/cinco_de_node.pdf">http://nodejs.org/cinco_de_node.pdf</a> ），该程序返回一个1M的缓冲Buffer，Node每秒处理822个请求，而Nginx每秒处理708个。Node有很强大的吞吐能力，每秒可以响应更多的请求数。你完全不必为Node的性能担忧和顾虑，放心地使用它。</p>

<p>你也许会担心在不同平台下面的性能差异。Node在0.6.x版本后可以直接在Windows平台上运行，不需要借助Cygwin的支持。Node在Windows平台上的性能和Unix/Linux平台已经相差无几，而且在某些方面性能要更优。Ryan Dahl分享了具体测试数据：</p>

<p>| Linux v 0.4.12 | Linux v 0.6.0<br/>
http_simple.js /bytes/1024 | 5461 r/s | 6263 r/s<br/>
io.js 读 | 19.75 MB/s | 26.63 MB/s<br/>
io.js 写 | 21.60 MB/s | 17.40 MB/s<br/>
startup.js | 74.7 ms | 49.6 ms</p>

<p>| Windows v 0.4.12 | Windows v 0.6.0<br/>
http_simple.js /bytes/1024 | 3858 r/s | 5823 r/s<br/>
io.js 读 | 12.41 MB/s | 26.51 MB/s<br/>
io.js 写 | 12.61 MB/s | 33.58 MB/s<br/>
startup.js | 152.81 ms | 52.04 ms</p>

<h4 id="toc_4">1.2.3　JavaScript &amp; V8</h4>

<p>Node支持的语言是JavaScript。JavaScript对Web开发人员来说一定很熟悉，它是一门动态弱类型语言，能按需非正式声明和可动态扩展对象。匿名函数、闭包等特性也非常适合事件驱动、异步编程。你如果已经对JavaScript熟悉，那么你无需学习新的语言，你可以很快上手Node。</p>

<p>一个完整的JavaScript实现应该包括三个部分：ECMAScript(核心)、BOM(浏览器模型)和DOM(文档对象模型)。Node没有BOM和DOM，只有ECMAScript。</p>

<p>Node受益于V8引擎的JIT(Just In Time)编译功能，Node的运行速度可以和本地代码媲美。随着V8引擎的发展与进步，Node也会同时从中收益。V8实现了ECMA-262第五版(<a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">http://www.ecma-international.org/publications/standards/Ecma-262.htm</a> )。不同的浏览器使用了不同的JavaScript引擎，例如Chakra(IE9)、SpiderMonkey(Firefox)、JavaScriptCore(Safari)。不同的引擎对ECMA-262的实现会略有不同，需要加以注意。</p>

<h3 id="toc_5">1.3　Node不是银弹</h3>

<p>Node的出现，引发了很激烈的讨论，有人支持有人反对。很多人在公开发表自己的看法，《如果你正在使用Node，你就是误入歧途》就是其中很有名的一篇文章（英文原文地址：<a href="http://codeslinger.posterous.com/if-youre-using-nodejs-youre-doing-life-wrong">http://codeslinger.posterous.com/if-youre-using-nodejs-youre-doing-life-wrong</a> ）。当然，也会有人针对回应，一位自由软件开发者Craig回应《Node不是银弹，而仍然是一颗子弹》（英文原文地址：<a href="http://crgwbr.com/details/41/nodejs-isnt-a-silver-bullet-but-still-a-bullet/">http://crgwbr.com/details/41/nodejs-isnt-a-silver-bullet-but-still-a-bullet/</a> ）。在这里并不想讨论孰对孰错的问题，因为根本无法定论。Bjarne Stroustrup曾经说过的一句话：“世界上只有两种语言：整天被人喷的语言，没有人用的语言。”或许这句话可以解释一切。</p>

<h3 id="toc_6">1.4　谁在使用Node</h3>

<p>虽然Node诞生刚刚两年多，还很年轻，但是发展速度迅猛。有很多企业在生产环境中使用了Node，那么我们来看看几个企业应用中的案例。<br/>
在社交网站LinkedIn最新发布的移动应用中，HTML5技术抢占前端开发，而Node则是该移动应用的后台基础。LinkedIn移动开发主管Kiran Prasad对媒体表示，其整个移动软件平台都由Node构建而成。选择Node的原因，第一是因为其灵活性；第二是Node擅长与其他服务通信。</p>

<p>知名项目托管网站GitHub也尝试了Node应用，其开发人员在博客中介绍了使用Node的情况。该Node应用称为NodeLoad，是一个存档下载服务器（每当你下载某个存储分支的tarball或者zip文件时就会用到它）。GitHub之前的存档下载服务器采用Ruby编写。在旧系统中，下载存档的请求会创建一个Resque任务。该任务实际上在存档服务器上运行一个git archive命令，从某个文件服务器中取出数据。然后，初始的请求分配给你一个小型Ruby Sinatra应用等待该任务。它其实只是在检查memcache flag是否存在，然后再重定向到最终的下载地址上。旧系统运行大约3个Sinatra实例和3个Resque worker。GitHub的开发人员觉得这是Node应用的好机会。Node基于事件驱动，相比Ruby的阻塞模型，Node能够更好地处理git存档。在编写新下载服务器过程中，开发人员觉得Node非常适合该功能，此外，他们还利用了Node库socket.io来监控下载状态。</p>

<p>国内知名电子商务平台淘宝网在产品中也实际应用了Node。MyFOX是一个数据处理中间件，负责从一个MySQL集群中提取数据，计算，并输出统计结果。用户提交一段SQL语句，MyFOX根据该SQL命令的语义，生成各个数据库分片所需要执行的查询语句，并发送至各个分片，再将结果进行汇总和计算。 MyFOX的特点是CPU密集，无文件IO，并只处理只读数据。起初MyFOX使用PHP编写，但遇到许多问题。例如PHP是单线程的，MySQL又需要阻塞查询，因此很难并发请求数据，后来的解决方案是使用Nginx和Dirzzle，并基于HTTP协议实现接口，并通过curl_multi_get命令进行请求。不过MyFOX项目组最终还是决定使用Node来实现MyFOX。</p>

<h3 id="toc_7">1.5　小结</h3>

<p>本章简要介绍了Node，具体包括：</p>

<ul>
<li>Node不仅仅是JavaScript； </li>
<li>Node采用事件驱动、非阻塞/异步IO模型；</li>
<li>Node性能优异，可跨平台，平台间的性能相差无几；</li>
<li>Node支持的语言是JavaScript，但是没有DOM和BOM；</li>
<li>Node已经不少在企业生产环境中的成功案例；</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-09-14-plsql-developer-oracle-min-client.html">PL/SQL Developer 与 Oracle 精简客户端</a></h1>
			<p class="meta"><time datetime="2012-09-14T18:20:40+08:00" 
			pubdate data-updated="true">2012/9/14</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>本文介绍如何安装 PL/SQL Developer 9 与 Oracle 精简客户端。</p>

<ol>
<li><p>下载 <a href="https://www.allroundautomations.com/bodyplsqldevreg.html">PL/SQL Dev</a></p></li>
<li><p>下载 <a href="http://www.oracle.com/technetwork/database/features/instant-client/index-097480.html">Oracle 精简客户端</a></p></li>
<li><p>安装 PL/SQL Dev 以及汉化包</p></li>
<li><p>解压 Oracle 精简客户端，比如解压目录为 D:\oracle10g</p></li>
<li><p>配置 Oracle 连接。D:\oracle10g\tnsnames.ora，D:\oracle10g\NETWORK\ADMIN\tnsnames.ora</p></li>
<li><p>配置系统环境变量</p>

<ol>
<li><p>ORACLE_HOME</p>

<p>值：D:\oracle10g</p></li>
<li><p>TNS_ADMIN<br/>
值：D:\oracle10g</p></li>
<li><p>NLS_LANG<br/>
值：SIMPLIFIED CHINESE_CHINA.ZHS16GBK</p></li>
</ol></li>
<li><p>配置 PL/SQL Dev</p></li>
</ol>

<p>工具 -&gt; 首选项，Oracle 主目录名：D:\oracle10g，OCI 库：D:\oracle10g\oci.dll</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-09-08-ten-jdbc-best-practices.html">十个 JDBC 最佳实践</a></h1>
			<p class="meta"><time datetime="2012-09-08T18:18:10+08:00" 
			pubdate data-updated="true">2012/9/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>JDBC是Java为多种关系型数据库提供的统一的访问接口，以下是我长期使用JDBC总结的十个最佳实践。</p>

<h4 id="toc_0">JDBC最佳实践1：使用PrearedStatement</h4>

<p>任何一个使用过JDBC的Java程序员几乎都知道这个，PreparedStatment可以通过预编译的方式避免我们在拼接SQL时造成SQL注入。</p>

<h4 id="toc_1">JDBC最佳实践2、使用ConnectionPool（连接池）</h4>

<p>使用连接池作为最佳实践几乎都成了公认的标准。一些框架已经提供了内建的连接池支持，例如Spring中的Database Connection Pool，如果你的应用部署在JavaEE的应用服务器中，例如JBoss，WAS，这些服务器也会有内建的连接池支持，例如DBCP。使用连接的原因简单的说就是因为创建JDBC连接耗时比较长，如果每次查询都重新打开一个连接，然后关闭，性能将会非常低，而如果事先创建好一批连接缓存起来，使用的时候取出，不使用的时候仍不关闭，将会节省大量的创建关闭连接的时间。</p>

<h4 id="toc_2">JDBC最佳实践3、禁用自动提交</h4>

<p>这个最佳实践在我们使用JDBC的批量提交的时候显得非常有用，将自动提交禁用后，你可以将一组数据库操作放在一个事务中，而自动提交模式每次执行SQL语句都将执行自己的事务，并且在执行结束提交。</p>

<h4 id="toc_3">JDBC最佳实践4、使用Batch Update</h4>

<p>JDBC的API提供了通过addBatch()方法向batch中添加SQL查询，然后通过executeBatch()执行批量的查询。JDBC batch update可以减少数据库数据传输的往返次数，从而提高性能。</p>

<h5 id="toc_4">JDBC最佳实践5：使用列名获取ResultSet中的数据，从而避免invalidColumIndexError</h5>

<p>JDBC中的查询结果封装在ResultSet中，我们可以通过列名和列序号两种方式获取查询的数据，当我们传入的列序号不正确的时候，就会抛出invalidColumIndexException，例如你传入了0，就会出错，因为ResultSet中的列序号是从1开始的。另外，如果你更改了数据表中列的顺序，你也不必更改JDBC代码，保持了程序的健壮性。有一些Java程序员可能会说通过序号访问列要比列名访问快一些，确实是这样，但是为了程序的健壮性、可读性，我还是更推荐你使用列名来访问。</p>

<h4 id="toc_5">JDBC最佳实践6：使用变量绑定而不是字符串拼接</h4>

<p>在第一条最佳实践中，我们已经说过要使用PreparedStatment可以防止注入，而使用？或者其他占位符也会提升性能，因为这样数据库就可以使用不同的参数执行相同的查询，这个最佳实践带来更高的性能的同时也防止了SQL注入。</p>

<h4 id="toc_6">JDBC最佳实践7：要记住关闭Statement、PreparedStatement和Connection</h4>

<p>通常的做法是在finally块中关闭它们，这样做的好处是不论语句执行正确与否，不管是否有异常抛出，都能保证资源被释放。在Java 7中，可以通过Automatic Resource Management Block来自动的关闭资源。</p>

<h4 id="toc_7">JDBC最佳实践8：选择合适的JDBC驱动</h4>

<p>有四种JDBC驱动，分别是</p>

<ul>
<li>第一种JDBC驱动叫做JDBC-ODBC Bridge driver (bridge driver)</li>
<li>第二种JDBC驱动叫做Native-API/partly Java driver (native driver)</li>
<li>第三种JDBC驱动叫做AllJava/Net-protocol driver (middleware driver)</li>
<li>第四种JDBC驱动叫做All Java/Native-protocol driver (Pure java driver)</li>
</ul>

<h4 id="toc_8">JDBC最佳实践9：尽量使用标准的SQL语句，从而在某种程度上避免数据库对SQL支持的差异</h4>

<p>不同的数据库厂商的数据库产品支持的SQL的语法会有一定的出入，为了方便移植，我推荐使用标准的ANSI SQL标准写SQL语句。</p>

<h4 id="toc_9">JDBC最佳实践10：使用正确的getXXX()方法</h4>

<p>当从ResultSet中读取数据的时候，虽然JDBC允许你使用getString()和getObject()方法获取任何数据类型，推荐使用正确的getter方法，这样可以避免数据类型转换。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-08-30-bae-sae-gae.html">BAE、SAE 与 GAE 对比</a></h1>
			<p class="meta"><time datetime="2012-08-30T18:05:40+08:00" 
			pubdate data-updated="true">2012/8/30</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>从数据库、应用配置、计费、域名绑定、平台服务对比了 BAE、SAE 以及 GAE 的优劣，最后给出云平台选型的建议。</p>

<h3 id="toc_0">数据库</h3>

<p>SAE 不支持 InnoDB（可申请支持），BAE 默认支持。</p>

<p>BAE 不支持数据库连接池（c3p0、BoneCP 已测不支持），数据库连接不能长时间保持。</p>

<p>GAE 使用 Datasotre 存取数据，最近也提供了云 SQL（MySQL），但申请比较困难，配额/性能笔者未测试过。</p>

<p>另外，SAE 显式给出了主从库的访问方式，应用可以比较灵活地设计存取策略，例如读写分离。并且 SAE 是每个应用都拥有自己的数据库，而 BAE 是所有应用共用一个库。</p>

<h3 id="toc_1">应用配置</h3>

<p>BAE 的 duapp-web.xml 基本是抄袭 GAE 的 appengine-web.xml，元素基本一致。</p>

<p>比较奇葩的是 BAE 静态资源配置默认所有后缀为静态文件类型（例如 .html）的请求路径都默认假设为静态资源，需要在 duapp-web.xml 中指定排除。</p>

<h3 id="toc_2">计费与配额</h3>

<p>SAE 按应用天计费“豆豆”，服务也按流量计费、CPU 时间、调用次数计费。注册或活动送配额，否则需要购买。</p>

<p>BAE 目前还没有详细的计费，只限定了应用数。公测结束后应该会细化计费模型。</p>

<p>GAE 目前的计费模型主要是按 API 调用计数，流量分为 In/Out 配额。每天会定时刷新免费配额。</p>

<p>综上，GAE 的计费一目了然，主要就是 API 调用次数；SAE 的计费比较复杂，不同服务有不同的计费策略；BAE 还没有明确的计费模型。</p>

<h3 id="toc_3">域名绑定</h3>

<p>GAE 开通企业套件后随便绑，企业套件有免费版。</p>

<p><del>SAE 需要确认通过域名备案才能绑定，并且绑定后的流量计费翻倍。</del></p>

<p>SAE 目前可以随便绑，但没备案的话绑定域名的请求走海外中转，流量计费翻倍（原二级域名请求计费不变）。</p>

<p>BAE 目前可以随便绑，但没备案的后果自负。</p>

<h3 id="toc_4">平台服务</h3>

<p>SAE 提供了 SDK 包，包含了开发需要的本地服务实现。</p>

<p>BAE 则分别提供了服务 Jar，调用方式按不同服务而异。</p>

<p>GAE 提供了完整的 SDK 包，包含了开发需要的本地运行环境和配置客户端。</p>

<p>综上，GAE 提供了完整的平台化服务，覆盖了从开发到上线运维的一系列工具；SAE 则提供了部分工具，平台化不完整，增加了开发、运维难度；BAE 则是分别提供不同服务给开发，没有统一的 SDK 与调用方式。</p>

<p>另外，值得一提的是 BAE 虽然服务没有整合到一个 SDK 中，但其分散的服务也比较适合应用自己选择。 其中云消息（消息服务）以及云触发（数据变更通知）是 GAE/SAE 没有提供的服务，某些业务场景应该会非常适用。</p>

<h3 id="toc_5">结论</h3>

<p>SAE 与 BAE 主要还是面向应用部署托管，普通应用修改后易迁移部署到 BAE 或 SAE。</p>

<p>新应用开发可以选择和平台绑死（依赖平台服务）或按照普通应用开发。</p>

<p>使用配置工具来上传、更新应用配置其实是非常好的方式，但目前 SAE/J、BAE/J 都没有提供客户端配置工具，这增加了使用者的维护工作量。</p>

<p>GAE 提供了比较完整的服务平台，覆盖了应用的生命周期，最近也提供了云 MySQL 服务以吸引更多开发者。</p>

<p>需要根据应用类型来考虑平台选型，例如 GAE 基本以 API 计数的配额就不适合做社交应用，‘墙’的问题也需要考虑解决方案。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-08-13-dispel-your-windjs's-doubts.html">消除你对Wind.js的疑虑</a></h1>
			<p class="meta"><time datetime="2012-08-13T00:28:55+08:00" 
			pubdate data-updated="true">2012/8/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">eval is (always) evil</h3>

<p>eval大概也算是整个ECMAScript语言中最强大的一个方法，<br/>
他就像是一个完整的ECMAScript解析器。你说它evil,我也承认这个<br/>
方法会存在危险，有可能带来安全问题，特别是在用它执行用户输入<br/>
数据的情况下。但Wind.js是用eval来运行已经“编译”后的代码，<br/>
让你更舒服顺畅的来编写异步回调的代码。这些代码是你自己写的，<br/>
所以不必担心代码注入、跨站脚本攻击这样的安全问题。没有这这个<br/>
困扰和担忧，我相信eval应该是美好的。</p>

<h3 id="toc_1">API太丑，eval为什么不封装？</h3>

<p>通过eval执行的代码是被认为是包含该次调用的执行环境的一部分，<br/>
因此被执行的代码具有与该执行环境有着相同的作用域链。</p>

<pre><code>var Wind = require(&quot;wind&quot;);

var msg = &#39;hello world&#39;;
eval(&quot;console.log(msg)&quot;);//hello world

var msg = &#39;hello world&#39;;
var newFunc = eval(Wind.compile(&quot;async&quot;, function () { 
    console.log(msg);
}));
newFunc().start();//hello world
</code></pre>

<p>变量msg是在eval外定义的，但eval中还是能够打印&quot;hello world&quot;。<br/>
如果包装起来如法访问到msg这个变量。</p>

<pre><code>var Wind = require(&quot;wind&quot;);

var vm = require(&quot;vm&quot;);
var sandbox = {
      Wind: Wind,
      console:console
};

function $async(fun){
    var script = vm.createScript(Wind.compile(&quot;async&quot;, fun));
    return script.runInNewContext(sandbox);
}

var msg = &#39;hello world&#39;;
var newFunc = $async(function () { 
    console.log(msg);
});
newFunc().start();//[WARNING] An unhandled error occurred: ReferenceError: msg is not defined
</code></pre>

<p>上面的例子中看到我们使用vm模块对eval有一个简单的包装，可以直接<br/>
使用$async方法来替换以前的写法。从打印信息中，你很容易看出访问<br/>
不到msg这个参数。麻烦请注意一下调用script.runInNewContext()方法<br/>
时传入了一个sandbox对象，这相当于往代码运行环境中添加上下文参数。<br/>
如果sanbox这个参数不传递，运行上端代码会报ReferenceError: Wind <br/>
is not defined的错误。这就是eval为什么无法包装的原因。</p>

<p>如果你的代码不需要依赖上下文你可以用上述方法包装，例如这样：</p>

<pre><code>var Wind = require(&quot;wind&quot;);

var vm = require(&quot;vm&quot;);
var sandbox = {
      Wind: Wind,
      console:console
};

function $async(fun){
    var script = vm.createScript(Wind.compile(&quot;async&quot;, fun));
    return script.runInNewContext(sandbox);
}

var fib = $async(function () {

    $await(Wind.Async.sleep(1000));
    console.log(0);

    $await(Wind.Async.sleep(1000));
    console.log(1);

    var a = 0, current = 1;
    while (true) {
        var b = a;
        a = current;
        current = a + b;

        $await(Wind.Async.sleep(1000));
        console.log(current);
    }
});

fib().start();
</code></pre>

<h3 id="toc_2">Wind.js很重很慢不适合前端</h3>

<p>Wind.js基础组件及异步运行库共计4K大小（Minified + GZipped），<br/>
Wind.js完全不会给前端带来负担，给你带来顺畅舒服的异步编程体验。</p>

<h3 id="toc_3">生成的代码看不懂，难以调试</h3>

<p>Wind.js生产的代码也完全是Javascript代码，你无需为调试担忧。<br/>
下面是一个例子，我相信你很容易就可以看懂。</p>

<pre><code>// Original: 
function () {

    $await(Wind.Async.sleep(1000));
    console.log(0);

    $await(Wind.Async.sleep(1000));
    console.log(1);

    var a = 0, current = 1;
    while (true) {
        var b = a;
        a = current;
        current = a + b;

        $await(Wind.Async.sleep(1000));
        console.log(current);
    }
}

// Windified: 
/* async &lt;&lt; function () { */     (function () {
                                     var _builder_$0 = Wind.builders[&quot;async&quot;];
                                     return _builder_$0.Start(this,
                                         _builder_$0.Delay(function () {
/*     $await(Wind.Async.sleep(1000)); */    return _builder_$0.Bind(Wind.Async.sleep(1000), function () {
/*     console.log(0); */                        console.log(0);
/*     $await(Wind.Async.sleep(1000)); */        return _builder_$0.Bind(Wind.Async.sleep(1000), function () {
/*     console.log(1); */                            console.log(1);
/*     var a = 0, current = 1; */                    var a = 0, current = 1;
                                                     return _builder_$0.While(function () {
/*     while (true) { */                                 return true;
                                                     },
                                                         _builder_$0.Delay(function () {
/*         var b = a; */                                     var b = a;
/*         a = current; */                                   a = current;
/*         current = a + b; */                               current = a + b;
/*         $await(Wind.Async.sleep(1000)); */                return _builder_$0.Bind(Wind.Async.sleep(1000), function () {
/*         console.log(current); */                              console.log(current);
                                                                 return _builder_$0.Normal();
                                                             });
                                                         })
/*     } */                                          );
                                                 });
                                             });
                                         })
                                     );
/* } */                          })
</code></pre>

<h3 id="toc_4">eval性能方面会有问题</h3>

<p>有童鞋提出这方面的问题，但不知道提供什么样子的测试才能令人信服，从而消除疑虑，放心大胆的使用Wind.js。<br/>
这个问题还在收集整理中...</p>

<h3 id="toc_5">写在最后</h3>

<p>在ADC被老赵的执着打动了，支持老赵从文档开始吧。<br/>
如果你还有对Wind.js的任何疑虑都可以留言，这个文档的目的就是消除你对Wind.js的疑虑。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-08-12-test-v8-delete.html">v8 can not handle delete yet</a></h1>
			<p class="meta"><time datetime="2012-08-12T00:27:15+08:00" 
			pubdate data-updated="true">2012/8/12</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>v8 delete操作存在的这个问题</p>

<p><img src="/resource/image/2012-08-12-test-v8-delete/v8delete.jpeg" alt="有帮助的截图"/></p>

<p>测试地址在这里， <a href="http://jsperf.com/test-v8-delete%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9C%A8node%E4%B8%AD%E6%B5%8B%E8%AF%95">http://jsperf.com/test-v8-delete，也可以用下面的代码在node中测试</a></p>

<pre><code>var begin = new Date();
function Foo() {}
Foo.prototype.x = 1;
Foo.prototype.y = 2;

//delete Foo.prototype.y;

var foo = new Foo();

var result = 0;
for (var i = 0; i &lt; 100000; i++) {
    result = result + foo.x;
}

var end = new Date();
console.log(end - begin);
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-07-22-what-is-solo.html">solo(独唱团)这是一个由Node构建的静态博客</a></h1>
			<p class="meta"><time datetime="2012-07-22T00:26:24+08:00" 
			pubdate data-updated="true">2012/7/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>这个静态博客是用markdown来写文章，通过皮肤模板可以build出html页面。</li>
<li>你可以将他提交至GithubPages或者云端（七牛）或者一个Node服务器。</li>
<li>这里有示例:<a href="http://jinyang.mynah.org/">Pages</a>  <a href="http://qiniu.mynah.org/">七牛</a></li>
</ul>

<h3 id="toc_0">为什么会有这样一个静态博客</h3>

<ul>
<li>以前的博客不方便添加自己的demo例子页面(前端开发的童鞋应该会有强烈的认同感)</li>
<li>markdown语法简洁易用，所见即所得的html编辑器不好用也太重</li>
<li>不依赖于数据库，所有的内容都是文本，方便管理和迁移</li>
<li>不需要一个什么复杂的服务器，也不需要担心什么配额，可以托管html页面就可以</li>
<li>不用为图片文件等外链来发愁，直接放到相应的目录下，一起上传即可</li>
</ul>

<h3 id="toc_1">如何部署</h3>

<ul>
<li>你可以在<a href="https://github.com/lambgao/solo">这里</a>找到他。</li>
<li>如果你熟悉<a href="http://pages.github.com/">Github Pages</a>,可以直接Push到你的Pages仓库即可。</li>
<li>如果有一个Node服务器，那么你可以部署至你的服务器,启动app.js即可。</li>
<li>如果你有一个云端（七牛）服务，那么你可以上传至你的云端(运行lib/publish.js)。</li>
</ul>

<h3 id="toc_2">如何使用</h3>

<ul>
<li>你会发现根目录下md文件夹，这个里面存放的都是博客内容(markdown格式)。</li>
<li>md下有article和page两个文件夹，从字面上就很容易理解，分别是文章和页面。</li>
<li>md/article下面的文章在build之后会在article目录下生成同文件名的html页面</li>
<li>md/page下面的页面在build之后会在根目录下生成同文件名的html页面</li>
<li>运行lib/build.js来build页面(请先安装<a href="http://www.nodejs.org/">Node</a>,并安装依赖npm install)</li>
</ul>

<h3 id="toc_3">皮肤模板修改</h3>

<ul>
<li>你会发现根目录下skin文件夹,这个文件夹里面存放的都是皮肤模板(html文件)。</li>
<li>上面提到了article和page两种页面，那么皮肤模板也提供了article.html和page.html两个模板文件。</li>
<li>如果两个页面用到了共同的内容那么你可以把共同的内容提取出来放到skin/slot文件夹下。</li>
<li>在模板文件中${slot}就可以将这个文件引入到当前模板文件中。</li>
<li>${article}这个变量用于引入文章或者页面的内容，即md文件夹下生成的内容。</li>
<li>根目录下你还会发现css、image、javascript文件夹，这些是存放模板使用到的静态文件</li>
</ul>

<h3 id="toc_4">有疑问或者...</h3>

<ul>
<li>如果你有疑问、建议、bug提交都可以找我。</li>
<li>找我请这里新浪微博<a href="http://weibo.com/lambsand">@金氧</a>,或这里Github<a href="https://github.com/lamb">@lambgao</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-06-16-java-atomic-conncurrent.html">Java 原子操作与并发</a></h1>
			<p class="meta"><time datetime="2012-06-16T17:54:28+08:00" 
			pubdate data-updated="true">2012/6/16</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>由一个简单的例子引出并发处理时容易被忽视的陷阱，用来作为面试问题应该很适合。</p>

<p>某日，工作了 4 年多的 Java 程序员小 K 跳槽，面试时碰到这样一个题目....</p>

<pre><code>public class P1 {
 
    private long b = 0;
 
    public void set1() {
        b = 0;
    }
 
    public void set2() {
        b = -1;
    }
 
    public void check() {
        System.out.println(b);
 
        if (0 != b &amp;&amp; -1 != b) {
            System.err.println(&quot;Error&quot;);
        }
    }
}
</code></pre>

<h4 id="toc_0">问题</h4>

<p>调用 set1()、set2()、check()，会打印出 Error 么？</p>

<h4 id="toc_1">小K 的推理</h4>

<p>“无论如何调用 set1()、set2() -&gt; b 的值只可能是 0 或 -1 -&gt; 在 check() 里面的判断条件（b 既不为 0 也不为 -1）永远不成立 -&gt; 不打印 Error”</p>

<p>小 K 觉得有坑：这题目应该不会这么简单，再考虑一下多线程环境。</p>

<p>思前想后，小 K 得出结论：“在多线程环境下也不会打印 Error。这题目很简单，就是考察一下推理吧。”，K 暗自窃喜。</p>

<p>后来小 K 陆续又被问了几个多线程和 JVM 的问题。</p>

<p>后来，就没有后来了....</p>

<h4 id="toc_2">后来</h4>

<p>后来还是有的。到家后，不甘心的小 K 验证了这道秒杀他的面试题。</p>

<pre><code>public static void main(final String[] args) {
    final P1 v = new P1();
 
    // 线程 1：设置 b = 0
    final Thread t1 = new Thread() {
        public void run() {
            while (true) {
                v.set1();
            }
        };
    };
    t1.start();
 
    // 线程 2：设置 b = -1
    final Thread t2 = new Thread() {
        public void run() {
            while (true) {
                v.set2();
            }
        };
    };
    t2.start();
 
    // 线程 3：检查 0 != b &amp;&amp; -1 != b
    final Thread t3 = new Thread() {
        public void run() {
            while (true) {
                v.check();
            }
        };
    };
    t3.start();
}
</code></pre>

<p>使用 3 个线程分别重复执行 set1()、set2()、check()。执行输出结果部分如下：</p>

<pre><code>....
0
0
1
1
1
Error
Error
-4294967296
0
0
4294967295
....
</code></pre>

<p>执行环境：</p>

<pre><code>*Java(TM) SE Runtime Environment (build 1.6.0_31-b05)

Java HotSpot(TM) Client VM (build 20.6-b01, mixed mode, sharing), 32bit*
</code></pre>

<p>“确实打印了 Error，并且打印了 4294967295、-4294967296。我勒个去，只是啥情况？”</p>

<p>小 K 决定搞懂其中奥秘，重新审视了题目。以一个专业程序员的严谨，并经过无数次 Google 后....他似乎发现了问题所在。 </p>

<p>“这确实是一个并发问题！”</p>

<h4 id="toc_3">分析</h4>

<p>这道题目有两个陷阱，分别考察了对并发执行的理解，以及对 JVM 基础（赋值操作）的掌握。</p>

<h4 id="toc_4">陷阱一：并发执行</h4>

<p>并发执行就是多个操作一起执行，CPU 执行不同上下文（可理解为不同线程）发过来的指令。操作系统上层看上去就像是并行处理一样。</p>

<p>也就是说，在编程语言层面，一个简单的操作同样需要考虑并发问题。</p>

<p>小 K 首先是栽在了 check() 中的 if 判断上和设值是存在并发的，不能保证 0 != b 这个判断真（此时 b 为 -1）后恰好 b 被赋值为 0 时判断 1 != b。</p>

<p>除此外，无论 JVM、操作系统、CPU 层面对指令如何优化、重排，最终都是逐一执行单一指令，唯一不同的就是不同层面可能会对执行加以限制，</p>

<p>比如加入原子操作，最终保证 CPU 能够完整执行一组指令。</p>

<h4 id="toc_5">陷阱二：JVM 赋值操作</h4>

<p>一些赋值操作不是原子性的。“纳尼？”</p>

<p>Java 基础类型中，long 和 double 是 64 位长的。32 位架构 CPU 的算术逻辑单元（ALU）宽度是 32 位的，在处理大于 32 位操作时需要处理两次。</p>

<p>“这不是&lt;计算机组成原理与汇编&gt;么”，小 K 顿时感到大学白上了，不懂学以致用 T_T~</p>

<p>题目执行打印 4294967295、-4294967296 就是因为读时高 32 位或低 32 位被其他写覆盖了（看一下这两个数字的二进制就知道了）。</p>

<p>Java 已经是封装底层细节很好的语言了，但依然需要注意这些陷阱，可以使用并发处理包 java.util.concurrent.atomic 中包含了一系列无锁原子操作类型，</p>

<p>也可以使用 volatile 关键字保证线程间变量的可见性。</p>

<p>其实这道题目只要解决了并发问题，也就保证了每个执行单元（set1()、set2()、check()）中赋值、比较的正确性。可以把同步方法执行看作序列化的事务，各中操作不会相互影响。</p>

<h4 id="toc_6">再后来</h4>

<p>虽然小 K 面试挂了，不过他挂得心服口服。</p>

<p>通过这个期间的不断翻阅文档以及实验，小 K 下次的面试应该不会被类似的题目秒杀了吧....</p>

<p>“按照这个简单面试题的标准，以前写过的程序简直就是通篇 bugs 啊！有木有，有木有啊！！！！”</p>

<h4 id="toc_7">骚年，继续充电吧！</h4>

<p>内外兼修才是好程序员 :-)</p>

<ul>
<li><a href="http://www.iteye.com/topic/109150">多核线程笔记-volatile原理与技巧</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">Java 理论与实践: 正确使用 Volatile 变量</a></li>
<li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile">深入分析Volatile的实现原理</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-jtp11234/">Java 理论与实践: 流行的原子</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-05-20-reset-weblogic-password.html">Weblogic 10.3.3 重置管理密码</a></h1>
			<p class="meta"><time datetime="2012-05-20T17:51:13+08:00" 
			pubdate data-updated="true">2012/5/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ol>
<li><p>cd到你的域目录下的security，如C:\bea\wls103\user_projects\domains\my_domain\security</p></li>
<li><p>rm DefaultAuthenticatorInit.ldift</p></li>
<li><p>运行java -cp &lt;weblogic_home\wlserver_10.3\server\lib\weblogic.jar weblogic.security.utils.AdminAccount adminuser adminpassword .</p>

<p>这步会创建一个新的DefaultAuthenticatorInit.ldift文件</p></li>
<li><p>cd到<domain_home>/servers/<AdminServer>/data/ldap</p></li>
<li><p>rm DefaultAuthenticatormyrealmInit.initialized</p></li>
<li><p>重启 Server，用新帐号登录 Admin Console，然后你就可以重置原帐号的密码了。</p></li>
</ol>

<p>参考：<a href="http://pridesnow.iteye.com/blog/1453653">http://pridesnow.iteye.com/blog/1453653</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-05-12-server-push-based-on-pushlets.html">基于 Pushlets 的消息推送设计</a></h1>
			<p class="meta"><time datetime="2012-05-16T17:40:38+08:00" 
			pubdate data-updated="true">2012/5/16</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Pushlets 是通过长连接方式实现“推”消息的。推送模式分为：Poll（轮询）、Pull（拉）。本文围绕 Pull 模式进行设计。</p>

<h3 id="toc_0">原理</h3>

<p>客户端发起请求，服务端接收到请求后根据 Pushlets 协议进行处理。推数据通过 HTTP 响应返回。</p>

<p>客户端在接收到响应后根据 Pushlets 协议进行处理，重新发起请求。Pull 模式时序：</p>

<p><img src="https://public.sn2.livefilestore.com/y1ptpxVei6mgGxLAv79zOuIx46cVw3jQx5EgPX1MirgoMA5wt7KFkIyA20YE2GuLTBXy_IQi1CjBSkYs4GnJU5JKA/pushlets_pull.png?psid=1" alt="Pushlets Pull"/></p>

<ol>
<li>join：join 请求，服务器端建立 Pushlet 会话</li>
<li>join-ack：join 应答，返回会话 id</li>
<li>listen：订阅并监听主题</li>
<li>listen-ack：监听应答，返回会话 id，订阅 id</li>
<li>subscribe（可选）：订阅主题</li>
<li>subscribe-ack（可选）：订阅主题应答，返回会话 id，订阅</li>
<li>refresh：长连接请求，实参会话 id</li>
<li>refresh-ack：长连接响应，包括下一次 refresh 请求间隔</li>
<li>hb：心跳响应</li>
<li>data：推数据</li>
<li>leave：清空订阅</li>
<li>leave-ack：清空订阅应答</li>
</ol>

<h3 id="toc_1">服务器端</h3>

<p>服务器端主要负责维护会话，根据请求处理应答。使用内存队列维护每个会话的主题事件。</p>

<p>事件产生后通过分发器（Dispatcher）将事件发布到指定订阅者的事件队列里。Pull 模式使用阻塞队列，读超时（没有事件）后返回 hb 与 refresh 指令的应答。</p>

<h4 id="toc_2">事件发布</h4>

<ul>
<li>广播：将事件发布给所有订阅者</li>
<li>多播：将事件发布给匹配的订阅者</li>
<li>单播：将事件发给某个订阅者</li>
</ul>

<h4 id="toc_3">关键参数</h4>

<p>订阅者的事件队列配置：</p>

<ul>
<li>queue.size=24队列大小为 24。如果队列满了新发布到该队列的事件将被丢弃。</li>
<li>queue.read.timeout.millis=20000 队列读超时 20 秒。读超时后返回 hb 与 refresh 指令的应答。该项配置即请求线程最长 hold 时间。</li>
<li>queue.write.timeout.millis=20 队列写超时 20 毫秒。如果队列是满的，等待 20 毫秒后如果还满，则销毁该订阅者。</li>
</ul>

<p>刷新时长配置：</p>

<ul>
<li>pull.refresh.timeout.millis=45000
服务器端刷新超时 45 秒。如果服务器端某订阅者超过 45 秒没有收到客户端的 listen 或 refresh 请求，则销毁该订阅者。该超时判断发生在发布事件时。</li>
<li>pull.refresh.wait.min.millis=2000
pull.refresh.wait.max.millis=6000
refresh 指令中指定客户端下次请求的等待时间区间，值取该区间内的随机值。</li>
</ul>

<h3 id="toc_4">客户端</h3>

<p>Pushlets 支持多种客户端，例如浏览器客户端、Java 客户端。浏览器客户端又分为 iframe 和 AJAX 两种。</p>

<p>初始化客户端后，客户端发起监听、订阅请求，并根据服务器返回指令发送 refresh 请求。当有 data 应答时，回调客户端 onData(event) 函数实现消息处理。</p>

<h3 id="toc_5">技术设计</h3>

<p>对 Pushlets 做接口封装以屏蔽其特性细节，也便于以后兼容其他服务器消息推送技术（例如 WebSocket）做好铺垫。</p>

<p>封装的服务器推机制定义为 Channel 服务，提供服务器到浏览器客户端的消息推送。</p>

<h4 id="toc_6">服务器端</h4>

<p>通过 Channel API 在 JS 客户端与服务器端建立长连接，使服务器端可以实时地发送消息给客户端。</p>

<p><img src="https://public.sn2.livefilestore.com/y1pZFZKlLqBHhM8SWRJGY6-1KDloobUVsp6EexI5XRDH-gXpPK4JiWHJHfOgyiHbbnQwiy2nBNg2DAPt-EgZqZUvg/channel_class.png?psid=1" alt="Channel 类图"/></p>

<h4 id="toc_7">JS 客户端</h4>

<p>oaweb.Channel() 类：</p>

<ul>
<li>init()
初始化服务器调用 URL、客户端状态。</li>
<li>open()
发送 join 请求，服务端创建会话。</li>
<li>subscribe(listeners : {topic, onmessage, onerror})
发送 subscribe 请求，服务端创建订阅者，添加订阅主题。</li>
<li>unsubscribe(topic)
发送 unsubscribe 请求，服务端移除订阅。</li>
<li>close()
发送 leave 请求，服务端销毁会话。</li>
</ul>

<h4 id="toc_8">时序</h4>

<p><img src="https://public.sn2.livefilestore.com/y1p5e65HlecGSpWAaqLF01v27kXVa5l_mk8E38aZszmxjzn2hs5OvpVtK_SNgW82eZJVwjjmrcAbtHkrjZYMaCTjw/channel_seq.png?psid=1" alt="Channel 时序图"/></p>

<h4 id="toc_9">集群</h4>

<p>均衡器通过源地址保持策略保证同一 IP 的请求均会分发到固定服务节点。</p>

<p>当服务节点进行业务逻辑处理后，发送消息到消息服务系统；</p>

<p>服务节点订阅消息主题，当监听到新消息时调用 Channel 服务发布消息到具体的推送实现组件（Pushlets）。</p>

<p><img src="https://public.sn2.livefilestore.com/y1pFcfOSzdHxwV99UxthxH2wTXgwS8-GkQttbtzHJS1PO7cD-FCoRMvrkjnwzz9QAzAFy0apLGuGJaMRzFq7_1ZXQ/channel_cluster.png?psid=1" alt="Channel 集群"/></p>

<p>参考</p>

<ul>
<li><a href="https://developers.google.com/appengine/docs/java/channel/">Google App Engine Channel API</a></li>
<li><a href="http://www.w3.org/TR/websockets/">HTML5 WebSocket API</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-05-07-web-message-push.html">消息推送技术</a></h1>
			<p class="meta"><time datetime="2012-05-07T17:26:55+08:00" 
			pubdate data-updated="true">2012/5/7</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">消息推送</h3>

<p>消息推送是针对 Web 应用开发领域的技术，指服务端以主动方式将信息送达客户端。主要用于提升用户体验，避免用户刷新页面从服务端拉取数据。例如 Web 邮件中自动出现刚收到的邮件项，Web 即时通讯自动提示新到消息等应用场景。</p>

<p>要实现消息推送机制，涉及两方面的内容：<br/>
* Web 层消息推送<br/>
* 服务层消息服务</p>

<h3 id="toc_1">Web 层消息推送</h3>

<h4 id="toc_2">套接字</h4>

<p>可以使用套接字接口进行全双工通讯。可以通过 Flash XMLSocket、Java Applet 技术实现。<br/>
但由于实现方案与厂商技术绑定过紧，不属于 Web 标准化范畴，并且存在一些限制（通讯端口开启安全、客户端插件），这里不进行描述。</p>

<h4 id="toc_3">HTTP 请求轮询</h4>

<p>目前的 Web 应用是基于 HTTP 协议的，其规定了请求-响应的处理模型，位于应用层的单工通讯模式使得纯粹意义上的服务端推送方式变得难以实现。</p>

<p>为了基于 HTTP 协议进行“推送”实现，可由客户端发起 HTTP 请求轮询，服务端在请求后返回响应。</p>

<p>根据轮询时间、请求处理方式，分为以下三种推。</p>

<h4 id="toc_4">简单轮询</h4>

<p>客户端一般以定时方式发起请求，服务端处理后返回响应。</p>

<p><img src="https://public.sn2.livefilestore.com/y1pKG8qSIKx4nniHeaUQwfGkn7_AOS8GwVUrn63-xV6m5W6slIEvRMWLM8c13e6gqWmfcoNq-KPHaE_cSzsWYiPSg/simple-poll.png?psid=1" alt="简单轮询"/></p>

<ul>
<li>原理、客户端/服务端实现简单</li>
<li>可根据应用场景调整轮询时间间隔</li>
<li>服务端需要处理大量请求</li>
</ul>

<h4 id="toc_5">长轮询</h4>

<p>客户端发起请求后服务端将该请求挂起（不返回响应），直到超时、异常或需要处理响应（推内容）才返回。客户端收到响应后再次请求（即轮询）服务端，并处理响应。</p>

<p><img src="https://public.sn2.livefilestore.com/y1pg8zn2O3wRB9FvU9eVTCSJTko6y9nBiqZDzKVBAR6PA5ZEeQWUo-g9-BIDGUcnzgp-o2jfNqeKa9iMtg-8oP80w/long-poll.png?psid=1" alt="长轮询"/></p>

<ul>
<li>实时性高</li>
<li>服务端需要管理挂起请求</li>
</ul>

<h4 id="toc_6">HTTP 流</h4>

<p>客户端发起请求后服务器端处理请求，并通过 HTTP 流一直向客户端写入数据，直到超时或异常才返回响应。连接断开后客户端再次请求服务端，属于长轮询的一种。</p>

<p><img src="https://public.sn2.livefilestore.com/y1pg8zn2O3wRB_dSNHMdTAGrE3L-qzp-3wRJGRGg3vep25W61bdfXvlMSZZn7xezEgptcNNk3MPEAEZ1W-7BEOuzw/stream.png?psid=1" alt="HTTP 流"/></p>

<h4 id="toc_7">HTML 5 WebSocket</h4>

<p>这是标准化的客户端全<a href="http://dev.w3.org/html5/websockets/">双工通讯规范</a>，但由于目前<a href="http://jcp.org/en/jsr/summary?id=356">服务端规范</a>尚未成型，且考虑到现有客户端对 HTML 5 的支持有限，这里不进行描述。</p>

<h4 id="toc_8">多客户端支持</h4>

<p>上述介绍是针对浏览器客户端的，在实际应用场景中，还需要考虑其他客户端支持，例如 iOS、Android 等。</p>

<p>在移动客户端方面，需要考虑如下几点。</p>

<h5 id="toc_9">APIs 多样</h5>

<p>不同客户端本地 APIs 接口存在差异，但都支持基本的 HTTP 协议。直接基于 HTTP 协议进行开发可将差异最小化。</p>

<h5 id="toc_10">网络连接不稳定</h5>

<p>通讯信道打开后不一定能长时间维护，客户端与服务端的状态管理复杂。</p>

<h5 id="toc_11">最小化流量</h5>

<p>需要尽量最小化网络流量，提升移动客户端可用性。</p>

<h3 id="toc_12">服务层消息服务</h3>

<p>消息是系统或组件间通讯的一种低耦合方式，是系统级异步架构的基础。</p>

<p>在 Web 消息推送中，服务端管理应用状态，当状态发生变迁时需要通知客户端，完成消息推送。</p>

<h4 id="toc_13">Java Message Service</h4>

<p>需要重点关注如下技术点：</p>

<h5 id="toc_14">消息域</h5>

<ul>
<li><p>点对点只有一个客户端可以接收到消息。<br/>
<img src="https://public.sn2.livefilestore.com/y1pn-rGJlFftKx8JlI0OEosOio1o4ukP3Xlq1Fb-gzO4T6rXa4vrjXP8MUUFgk6R5_c9lltWVrQtnO3aeZi5AjD7Q/jms-pointToPoint.gif?psid=1" alt="JMS p2p"/></p></li>
<li><p>发布/订阅<br/>
广播给订阅的客户端。可配置持久化订阅。<br/>
<img src="https://public.sn2.livefilestore.com/y1pn-rGJlFftKxAtr19116nVAs_T-MJCBnyLPgpCZA8UyOT6A9Komub9StYUSNXykqk8WFB3IKt6DPC3KU4FtVHow/jms-publishSubscribe.gif?psid=1" alt="JMS Pub/Sub"/></p></li>
</ul>

<h5 id="toc_15">消息确认</h5>

<p>会话本地事务提交时会对收到的消息进行确认，回滚时将重传所有消息<br/>
非本地事务确认：Session.AUTO_ACKNOWLEDGE、Session.CLIENT_ACKNOWLEDGE、Session.DUPS_OK_ACKNOWLEDGE</p>

<h3 id="toc_16">技术设计</h3>

<h4 id="toc_17">目标</h4>

<ul>
<li>支持浏览器客户端的推送</li>
<li>高性能、高可靠</li>
<li>模块化，不与应用耦合</li>
<li>未来可支持多种移动客户端</li>
</ul>

<h4 id="toc_18">Web 层设计</h4>

<p>Web 层考虑采用开源组件 <a href="http://www.pushlets.com/">Pushlets</a> 进行实现。</p>

<h5 id="toc_19">Pushlets 组件</h5>

<p>Pushlets 基于 HTTP 协议的发布/订阅模型，提供了 Poll（轮询）、Pull（拉）两种推方式实现。其中 Pull 即长轮询方式，当有消息时就返回。</p>

<ul>
<li>发布：GET/POST 或方法调用ethod call（Dispatcher 接口）</li>
<li>订阅：GET 流，拉/轮询模式</li>
<li>树形主题：可层次化订阅</li>
<li>协议格式：JS，XML（JSON 尚未支持）</li>
<li>对使用 HTTP 协议的客户端都可用</li>
<li>易扩展：例如事件源实现</li>
<li>方便整合：可独立为 Web 应用，也可为 Web 应用组件</li>
<li>多种实现：J2EE/servlets，JavaScript (AJAX)
<img src="https://public.sn2.livefilestore.com/y1pTsZtjVvNgmTlwZ7_PaqcNsOFttmKJ49e0S4_L482d0X0nfuF5xG0pWYpaCmSIj46i7iq0EzCuKuDZTW_mBfz8w/pushlets.png?psid=1" alt="Pushlets"/></li>
</ul>

<h5 id="toc_20">JS 客户端</h5>

<ul>
<li>js-pushlet-client.js

<ul>
<li>使用 “隐藏 iframe 技巧”</li>
<li>格式：JavaScript 函数事件</li>
</ul></li>
<li>ajax-pushlet-client.js

<ul>
<li>使用 XMLHttpRequest</li>
<li>格式：XML</li>
<li>不支持 HTTP 流
使用 AJAX 客户端，较为灵活，便于封装。</li>
</ul></li>
</ul>

<h4 id="toc_21">服务层设计</h4>

<p>服务层消息服务采用应用服务器 JMS 中间件。通过发布/订阅模型实现状态同步。</p>

<h5 id="toc_22">处理步骤</h5>

<ol>
<li>配置主题订阅</li>
<li>应用状态变迁时发布 JMS 消息</li>
<li>JMS 消息监听器将监听到的消息发布到 Pushlets</li>
<li>将该消息写入 Web 层消息表</li>
</ol>

<h5 id="toc_23">消息表</h5>

<p>保存推送多的消息记录，用于客户端刷新时/多客户端查找消息。</p>

<p>消息体使用 JSON 字符串存放于 msg 字段中。其余字段可根据通用性进行抽取，比如用户名等。</p>

<p>消息监听器接收到消息时推 Pushlets，并进行记录写入（记录 lastGetTime 为写入时间，表示这条消息已经推送过）。</p>

<p>设置定时任务对超时记录进行删除。</p>

<h4 id="toc_24">逻辑架构</h4>

<p>JMS 消息系统为单独的通讯总线服务独立于应用系统，Pushlets 为应用系统中的一个组件。</p>

<p>消息表管理组件提供消息新增，以及对推送过的消息记录的查询、删除。<br/>
<img src="https://public.sn2.livefilestore.com/y1pJ_acuYt_CkkiHarLltUaKNjDom3zMbwe4EIjC5Uaj_Z-dS8TjrLofeSWl8BCH1e6xApcxf200RDtKTNiWNq4nQ/components.png?psid=1" alt="组件图"/></p>

<h5 id="toc_25">推时序</h5>

<p><img src="https://public.sn2.livefilestore.com/y1pg8zn2O3wRB-AzkrrJdr8rJyXVHgO0CgLBYHOKqFk15LmxOJMRsmKkOnqQBG4TEOGvpF_-gPnW9v0NEL2FXa_0Q/sequences.png?psid=1" alt="时序图"/></p>

<h4 id="toc_26">关键点</h4>

<p>服务层消息监听<br/>
消息表管理<br/>
Pushlets 配置，License 问题：Pushlets 是以 LGPL 开源的，对于商业项目使用时必须进行封装<br/>
前端容错开关</p>

<h3 id="toc_27">参考</h3>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/web/wa-lo-comet/">Comet：基于 HTTP 长连接的“服务器推”技术</a></li>
<li><a href="http://www.pushlets.com/">Pushlets 官网</a></li>
<li><a href="http://docs.oracle.com/javaee/6/tutorial/doc/bncdq.html">The JavaEE 6 Tutorial - Java Message Service</a></li>
<li><a href="https://docs.google.com/open?id=0B9vEkLPApAcqMGZWNFFrczBOckU">《JMS 规范教程》</a></li>
</ul>

<p>原文：<a href="https://docs.google.com/document/d/1qHVKlGz1raVemA2eHMSrPQppVKAiIrnFmfkpoyYE-U4/edit">《消息推送技术》via Google Docs</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2012-04-25-tapestry-defects.html">吐槽 Tapestry</a></h1>
			<p class="meta"><time datetime="2012-04-25T17:23:46+08:00" 
			pubdate data-updated="true">2012/4/25</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h4 id="toc_0">组件化</h4>

<p>组件是 Tapestry 中的核心概念，将页面模版与 Java 类做对应。在运行时框架管理组件生命周期与行为，最后输出 HTML 到客户端。</p>

<p>Tapestry 组件化所要达到的目标是使 Java 程序员更容易理解页面构成，使应用开发周期缩短。</p>

<p>但这样的组件化思想有个根本性的问题：不同编程模型在做映射的时候存在不匹配问题，与 ORM 的<a href="http://www.hudong.com/wiki/%E9%98%BB%E6%8A%97%E4%B8%8D%E5%8C%B9%E9%85%8D">“阻抗不匹配”</a>类似。</p>

<h4 id="toc_1">模版</h4>

<p>从输出展现上看，前端与后端的分离是必须的。前端程序员主要使用 HTML/CSS/JS 进行开发，不关注后端的组件构成。在页面布局设计上面是以展现结构进行模块化，比如分为页头、侧边栏、页脚、主体等。各部分的展现在运行时通过模版引擎即可完成组合，后端也只需要往不同模版组装填充对应数据，后端对应页面的组件化方式就显得多余了，并且处理过程繁琐，性能低下。</p>

<h4 id="toc_2">IoC</h4>

<p>对象状态管理是面向对象设计中比较复杂的一个问题。IoC 主要是为了帮助应用开发者管理对象，降低实现难度。但从实践出发，应用在设计的时候一般不会考虑使用 IoC 管理域对象，而只是使用 IoC 管理服务。这样的话其实使用 IoC 意义也不是很大了，工厂方法已经足够。</p>

<p>现在，随着分布式技术的普遍使用，JVM 内存领域对象必须做到最小化，以规避状态同步带来的复杂度和性能问题，目前的 IoC 容器并不能做到这一点。</p>

<h4 id="toc_3">总结</h4>

<ul>
<li>组件化模型存在问题</li>
<li>模版功能单一，只是为了辅助组件化</li>
<li>IoC 实践意义不大</li>
<li>多客户端视图渲染不宜扩展</li>
<li>过于依赖 HTTP 会话</li>
<li>版本不向后兼容</li>
</ul>

<p>框架是程序的半成品，其目的是为了降低开发难度，缩短开发周期。从某些方面上看，也是为了限制开发者，做到全局上的实现统一。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_9.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_7.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2017-06-24-ios-arm.html">iOS开发 - 制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-10-wechat-redenvelop-tweak-for-non-jailbroken-iphone.html">不越狱iOS自动抢红包</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2017-01-01-continuous-deployment-at-instagram.html">Instagram 是如何做持续部署的</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-30-life-2016.html">2016 总结 - 工作十小时，休息五分钟</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>