<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[金氧]]></title>
  <link href="http://lambgao.com/atom.xml" rel="self"/>
  <link href="http://lambgao.com/"/>
  <updated>2017-02-16T16:18:14+08:00</updated>
  <id>http://lambgao.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS开发 - 制作同时支持armv7,armv7s,arm64,i386,x86_64的静态库.a]]></title>
    <link href="http://lambgao.com/2017-06-24-ios-arm.html"/>
    <updated>2017-06-24T13:03:13+08:00</updated>
    <id>http://lambgao.com/2017-06-24-ios-arm.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">一、概要</h3>

<p>平时项目开发中，可能使用第三方提供的静态库.a，如果.a提供方技术不成熟，使用的时候就会出现问题，例如：</p>

<p>在真机上编译报错：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=x86_64, VALID_ARCHS=i386).</p>

<p>在模拟器上编译报错：No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6).</p>

<p>要解决以上问题，就要了解一下Apple移动设备处理器指令集相关的一些细节知识。</p>

<h3 id="toc_1">二、几个重要概念</h3>

<h4 id="toc_2">1、ARM</h4>

<p>ARM处理器，特点是体积小、低功耗、低成本、高性能，所以几乎所有手机处理器都基于ARM，在嵌入式系统中应用广泛。</p>

<h4 id="toc_3">2、ARM处理器指令集</h4>

<p>armv6｜armv7｜armv7s｜arm64都是ARM处理器的指令集，这些指令集都是向下兼容的，例如armv7指令集兼容armv6，只是使用armv6的时候无法发挥出其性能，无法使用armv7的新特性，从而会导致程序执行效率没那么高。</p>

<p>还有两个我们也很熟悉的指令集：i386｜x86_64 是Mac处理器的指令集，i386是针对intel通用微处理器32架构的。x86_64是针对x86架构的64位处理器。所以当使用iOS模拟器的时候会遇到i386｜x86_64，ios模拟器没有arm指令集。</p>

<h4 id="toc_4">3、目前iOS移动设备指令集</h4>

<p>arm64：iPhone5S｜ iPad Air｜ iPad mini2(iPad mini with Retina Display)</p>

<p>armv7s：iPhone5｜iPhone5C｜iPad4(iPad with Retina Display)</p>

<p>armv7：iPhone3GS｜iPhone4｜iPhone4S｜iPad｜iPad2｜iPad3(The New iPad)｜iPad mini｜iPod Touch 3G｜iPod Touch4</p>

<p>armv6 设备： iPhone, iPhone2, iPhone3G, 第一代、第二代 iPod Touch（一般不需要去支持）</p>

<h4 id="toc_5">4、Xcode中指令集相关选项（Build Setting中）</h4>

<h5 id="toc_6">（1）Architectures</h5>

<p>Space-separated list of identifiers. Specifies the architectures (ABIs, processor models) to which the binary is targeted. When this build setting specifies more than one architecture, the generated binary may contain object code for each of the specified architectures. </p>

<p>指定工程被编译成可支持哪些指令集类型，而支持的指令集越多，就会编译出包含多个指令集代码的数据包，对应生成二进制包就越大，也就是ipa包会变大。</p>

<h5 id="toc_7">（2）Valid Architectures</h5>

<p>Space-separated list of identifiers. Specifies the architectures for which the binary may be built. During the build, this list is intersected with the value of ARCHS build setting; the resulting list specifies the architectures the binary can run on. If the resulting architecture list is empty, the target generates no binary. </p>

<p>限制可能被支持的指令集的范围，也就是Xcode编译出来的二进制包类型最终从这些类型产生，而编译出哪种指令集的包，将由Architectures与Valid Architectures（因此这个不能为空）的交集来确定，例如：</p>

<p>比如，你的Valid Architectures设置的支持arm指令集版本有：armv7/armv7s/arm64，对应的Architectures设置的支持arm指令集版本有：armv7s，这时Xcode只会生成一个armv7s指令集的二进制包。</p>

<p>再比如：将Architectures支持arm指令集设置为：armv7,armv7s，对应的Valid Architectures的支持的指令集设置为：armv7s,arm64，那么此时，XCode生成二进制包所支持的指令集只有armv7s</p>

<p>在Xcode6.1.1里的 Valid Architectures  设置里， 默认为 Standard architectures(armv7,arm64),如果你想改的话，自己在other中更改。</p>

<p>原因解释如下： </p>

<p>使用 standard architectures (including 64-bit)(armv7,arm64) 参数，则打的包里面有32位、64位两份代码，在iPhone5s（ iPhone5s的cpu是64位的 ）下，会首选运行64位代码包， 其余的iPhone（ 其余iPhone都是32位的,iPhone5c也是32位 ），只能运行32位包，但是包含两种架构的代码包，只有运行在ios6，ios7系统上。 </p>

<p>这也就是说，这种打包方式，对手机几乎没要求，但是对系统有要求，即ios6以上。 </p>

<p>而使用 standard architectures (armv7,armv7s) 参数， 则打的包里只有32位代码， iPhone5s的cpu是64位，但是可以兼容32位代码，即可以运行32位代码。但是这会降低iPhone5s的性能。 其余的iPhone对32位代码包更没问题， 而32位代码包，对系统也几乎也没什么限制。 </p>

<p>所以总结如下：  </p>

<p>要发挥iPhone5s的64位性能，就要包含64位包，那么系统最低要求为ios6。 如果要兼容ios5以及更低的系统，只能打32位的包，系统都能通用，但是会丧失iPhone5s的性能。</p>

<h5 id="toc_8">（3）Build Active Architecture Only</h5>

<p>指定是否只对当前连接设备所支持的指令集编译</p>

<p>当其值设置为YES，这个属性设置为yes，是为了debug的时候编译速度更快，它只编译当前的architecture版本，而设置为no时，会编译所有的版本。 编译出的版本是向下兼容的，连接的设备的指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。比如你设置此值为yes，用iphone4编译出来的是armv7版本的，iphone5也可以运行，但是armv6的设备就不能运行。  所以，一般debug的时候可以选择设置为yes，release的时候要改为no，以适应不同设备。 </p>

<h6 id="toc_9">1）</h6>

<p>Architectures:  armv7, armv7s, arm64</p>

<p>ValidArchitectures:  armv6, armv7s, arm64</p>

<p>生成二进制包支持的指令集： arm64</p>

<h6 id="toc_10">2）</h6>

<p>Architectures: armv6, armv7, armv7s</p>

<p>Valid Architectures:  armv6, armv7s, arm64</p>

<p>生成二进制包支持的指令集： armv7s </p>

<h6 id="toc_11">3）</h6>

<p>Architectures: armv7, armv7s, arm64</p>

<p>Valid Architectures: armv7，armv7s</p>

<p>这种情况是报错的，因为允许使用指令集中没有arm64。</p>

<p>注：如果你对ipa安装包大小有要求，可以减少安装包的指令集的数量，这样就可以尽可能的减少包的大小。当然这样做会使部分设备出现性能损失，当然在普通应用中这点体现几乎感觉不到，至少不会威胁到用户体检。</p>

<h3 id="toc_12">三、制作静态库.a是指令集选择</h3>

<p>现在回归到正题，如何制作一个“没有问题”的.a静态库，通过以上信息了解到，当我们做App的时候，为了追求高效率，并且减小包的大小，Build Active Architecture Only设置成YES，Architectures按Xcode默认配置就可以，因为arm64向前兼容。但制作.a静态库就不同了，因为要保证兼容性，包括不同iOS设备以及模拟器运行不出错，所以结合当前行业情况，要做到最大的兼容性。</p>

<p>ValidArchitectures设置为：armv7｜armv7s｜arm64｜i386｜x86_64 </p>

<p>Architectures设置不变（或根据你需要）:  armv7｜arm64</p>

<p>然后分别选择iOS设备和模拟器进行编译，最后找到相关的.a进行合包，使用lipo -create 真机库.a的路径 模拟器库.a的的路径 －output 合成库的名字.a（详情可以参考<a href="http://blog.csdn.NET/lizhongfu2013/article/details/12648633%EF%BC%89">http://blog.csdn.NET/lizhongfu2013/article/details/12648633）</a></p>

<p>这样就制作了一个通用的静态库.a</p>

<p>.a 与 FrameWork 合并技巧</p>

<p>查看.a 和 FrameWork 的适配机型  </p>

<pre><code>lipo -create Debug-iphoneos/libMJRefresh.a Debug-iphonesimulator/libMJRefresh.a -output libMJRefresh.a

lipo -create /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-ctegiztcjikewoeprxxtmryzetfa/Build/Products/Release-iphoneos/libFMDB.a /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-ctegiztcjikewoeprxxtmryzetfa/Build/Products/Release-iphonesimulator/libFMDB.a -output /Users/harvey/Desktop/libFMDB.a

lipo -create /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-clvayfrjgytqrbdkyqrtcjkxfeuz/Build/Products/Release-iphonesimulator/FMDB.framework/FMDB /Users/harvey/Library/Developer/Xcode/DerivedData/FMDB-clvayfrjgytqrbdkyqrtcjkxfeuz/Build/Products/Release-iphoneos/Release-iphoneos.framework/FMDB -output /Users/harvey/Desktop/FMDB

Architectures in the fat file: /Users/kunkkaqi/Desktop/TestFrameWork.framework/TestFrameWork.lipo are: i386 armv7 armv7s x86_64 arm64 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不越狱iOS自动抢红包]]></title>
    <link href="http://lambgao.com/2017-01-10-wechat-redenvelop-tweak-for-non-jailbroken-iphone.html"/>
    <updated>2017-01-10T19:43:25+08:00</updated>
    <id>http://lambgao.com/2017-01-10-wechat-redenvelop-tweak-for-non-jailbroken-iphone.html</id>
    <content type="html"><![CDATA[
<p>春节临近，能用红包解决的，咱尽量不用语言表达。但是只恨手速太慢啊！那么问题来了，如果可以自动抢就完美了。辣么这肯定难不倒程序猿。如果你的手机已经越狱了，那么直接在Cydia市场搜索Tweak就可以了。如果没有越狱，又非常不想越狱或者根本就不会越狱该肿么办？办法也是有的，下面记录一下过程，虽然复杂了一些，但是亲测好用！</p>

<p><em>注意：本篇文章只是记录过程，并不深入原理，iOS 逆向比较复杂，这里只是初探，大家可以一起讨论。</em></p>

<span id="more"></span><!-- more --> 

<h3 id="toc_0">获取砸壳版本的微信 ipa</h3>

<p>因为在 AppStore 上面下载得到的应用都是经过加密的，可以执行文件上已经被加过一层壳，所以我们需要先拿到砸过壳版本的微信应用。</p>

<p>有两种方法：</p>

<ol>
<li>直接在 PP 助手下载</li>
<li>使用 Clutch 对越狱手机上应用进行砸壳</li>
</ol>

<p>第一种方法没什么好说的，这里主要讲讲第二种方法。</p>

<p>首先，将 Cluth 仓库 clone 到本地：</p>

<pre><code>$ git clone https://github.com/KJCracks/Clutch
$ cd Clutch
</code></pre>

<p>接着，使用 Xcode 进行构建，得到可执行文件：</p>

<pre><code>$ xcodebuild -project Clutch.xcodeproj -configuration Release ARCHS=&quot;armv7 armv7s arm64&quot; build
</code></pre>

<p>生成出来的可执行文件就在 Clutch 目录下，将其拷贝到手机上：</p>

<pre><code>scp Clutch/clutch root@&lt;your.device.ip&gt;:/usr/bin/
</code></pre>

<p>之后，就可以使用这个工具来进行砸壳了。</p>

<p>先 ssh 到越狱手机上，然后列出当前安装的应用：</p>

<pre><code>$ ssh root@&lt;your.device.ip&gt;
$ clutch -i
# Installed apps:
# 1:   WeChat &lt;com.tencent.xin&gt;
# 2:   DingTalk &lt;com.laiwang.DingTalk&gt;
# 3:   喜马拉雅FM（听书社区）电台有声小说相声英语 &lt;com.gemd.iting&gt;
</code></pre>

<p>可以得到 clutch 把相应的包名也显示出来了，这时我们就可以进行砸壳了：</p>

<pre><code>$ clutch -d com.tencent.xin
# com.tencent.xin contains watchOS 2 compatible application. It&#39;s not possible to dump watchOS 2 apps with Clutch 2.0.4 at this moment.
# Zipping WeChat.app
# Swapping architectures..
# ASLR slide: 0xb3000
# ...
# writing new checksum
# DONE: /private/var/mobile/Documents/Dumped/com.tencent.xin-iOS7.0-(Clutch-2.0.4).ipa
# Finished dumping com.tencent.xin in 76.9 seconds
</code></pre>

<p>可以看到，clutch 将砸过后的 ipa 文件放到了 /private/var/mobile/Documents/Dumped/ 目录下。</p>

<p>我们将它改成一个比较简单的名字，然后拷回电脑上：</p>

<pre><code>$ mv /private/var/mobile/Documents/Dumped/com.tencent.xin-iOS7.0-\(Clutch-2.0.4\).ipa /private/var/mobile/Documents/Dumped/wechat.ipa
$ scp root@&lt;your.device.ip&gt;:/private/var/mobile/Documents/Dumped/wechat.ipa ~/Desktop
</code></pre>

<p>这里，我把它拷到了电脑桌面上。之后就可以进行下一步操作了。</p>

<p>注意：我尝试了第一种办法，但是从 PP 助手下载下来的文件执行后续操作不成功，所以应该是第二种方法最可靠，然而我手头又没有越狱设备，不用着急，原作者有共享一个版本，可以从这里下载。链接: <a href="https://pan.baidu.com/s/1gf9hM1d">https://pan.baidu.com/s/1gf9hM1d</a> 密码: tbub</p>

<h3 id="toc_1">准备 dylib 动态链接库</h3>

<p>这步就很简单了，直接到我的 WeChatRedEnvelop 上把源码 clone 下来，然后执行 make 命令，就能拿到 dylib 文件了。</p>

<pre><code>$ git clone https://github.com/buginux/WeChatRedEnvelop.git
$ cd WeChatRedEnvelop
$ make 
# &gt; Making all for tweak WeChatRedEnvelop…
# ==&gt; Preprocessing Tweak.xm…
# ==&gt; Compiling Tweak.xm (armv7)…
# ==&gt; Compiling XGPayingViewController.m (armv7)…
# ...
# ==&gt; Signing WeChatRedEnvelop…
$ cp .theos/obj/debug/WeChatRedEnvelop.dylib ~/Desktop # 注意是 .theos 目录，这是个隐藏目录
</code></pre>

<p>将生成的 dylib 文件拷贝到桌面，跟刚刚砸过壳的微信应用放到一个目录层级。</p>

<h3 id="toc_2">检查依赖项</h3>

<p>因为这个代码是我自己写的，所以我知道这个 dylib 除了 mobilesustrate 外没有依赖其它的库。但是如果我们拿到的是别人的 dylib，就需要先进行一下依赖项检查，以确保之后我们将所有的依赖库都打包进 ipa 当中。</p>

<p>使用 macOS 自带的 otool 工具就可以进行依赖项检查：</p>

<pre><code>$ otool -L WeChatRedEnvelop.dylib
WeChatRedEnvelop.dylib (architecture armv7):
    /Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)
    /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)
    /usr/lib/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
WeChatRedEnvelop.dylib (architecture arm64):
    /Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)
    /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)
    /usr/lib/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
</code></pre>

<p>可以看到除了 substrate 库，其它依赖的都是系统自带的库。我们将 libsubstrate.dylib 拷出，使用 install_name_tool 命令修改动态库的路径，指向 app 二进制文件的同级目录。</p>

<p>如果你的系统中不是 /usr/lib/libsubstrate.dylib 而是 /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 的话，解决方法可以参考 <a href="https://github.com/buginux/WeChatRedEnvelop/issues/35">Github 上的 issue</a>。</p>

<pre><code class="language-$">$ install_name_tool -change /usr/lib/libsubstrate.dylib @loader_path/libsubstrate.dylib WeChatRedEnvelop.dylib
$ otool -L WeChatRedEnvelop.dylib
WeChatRedEnvelop.dylib (architecture armv7):
    /Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)
    /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)
    @loader_path/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
WeChatRedEnvelop.dylib (architecture arm64):
    /Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
    /System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.1.0)
    /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.0.0)
    /System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.5.2)
    @loader_path/libsubstrate.dylib (compatibility version 0.0.0, current version 0.0.0)
    /usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)
    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
</code></pre>

<p>可以看到 libsubstrate.dylib 的路径已经变更了。</p>

<p>注意：libsubstrate.dylib这个文件是从越狱手机中提取的，但是没有越狱手机，辣么从这里下载吧。链接: <a href="https://pan.baidu.com/s/1qXBqHSo">https://pan.baidu.com/s/1qXBqHSo</a> 密码: efvy</p>

<h3 id="toc_3">将动态链接库注入二进制文件中</h3>

<p>接下来，就需要将我们的库注入到微信的二进制文件中，可以使用开源的 <a href="https://github.com/alexzielenski/optool">optool 工具</a>。</p>

<p>编译安装 optool 工具：</p>

<pre><code># 因为 optool 添加了 submodule，因为需要使用 --recuresive 选项，将子模块全部 clone 下来
$ git clone --recursive https://github.com/alexzielenski/optool.git
$ cd optool
$ xcodebuild -project optool.xcodeproj -configuration Release ARCHS=&quot;i386 x86_64&quot; build
</code></pre>

<p>将砸壳过的 ipa 文件解压，然后将 libsubstrate.dylib 与 WeChatRedEnvelop.dylib 拷贝到解压后的 WeChat.app 目录下。</p>

<pre><code>$ cd ~/Desktop
$ unzip wechat.ipa -d wechat
$ cp libsubstrate.dylib WeChatRedEnvelop.dylib wechat/Payload/WeChat.app
</code></pre>

<p>使用 optool 把 WeChatRedEnvelop.dylib 注入到二进制文件中：</p>

<pre><code>$ /path/to/optool install -c load -p &quot;@executable_path/WeChatRedEnvelop.dylib&quot; -t wechat/Payload/WeChat.app/WeChat
</code></pre>

<p>注意：如果你的系统版本非常新，那么再编译的步骤肯定会报错。你可以尝试用Xcode打开项目，选中Target - Build Settings - Base SDK - Latest macOS 然后点击Build按钮进行编译。</p>

<h3 id="toc_4">打包并重签名</h3>

<p>打包 ipa 与重签名可以直接使用图形化工具 <a href="https://github.com/DanTheMan827/ios-app-signer.git">ios-app-signer</a> 来完成。</p>

<p>这个工具可以自动加载出本机的证书以及 Provisioning Profile 文件，使用起来十分方便，当然也可以手动选择证书文件。</p>

<p>如果是使用个人开发者证书，需要先将设备的 UUID 加到 Provisioning Profile 中。</p>

<p>我这里是直接从一个 archive 过的应用中提取 embedded.mobileprovision 文件，并在 Provisioning Profile 一栏中选择 Choose Custom File 使用这个文件。</p>

<p>点击 start 后，指定保存路径，iOS App Signer 就会帮你搞定所有事情。</p>

<p>注意：这一步之前要把 WeChat.app 里面的 Watch 目录删除，要不后续用Xcode安装的时候出现这个错误A WatchKit app within this app is not a valid bundle.</p>

<h3 id="toc_5">安装</h3>

<p>在 iOS App Signer 完成打包与重签名后，我们就可以进行安装了。</p>

<p>安装有两种方法，一种是使用 iTool 工具安装 ipa 文件。</p>

<p>另外一种是针对有 XCode 的同学，在菜单 - Window - Devices 中打开设置窗口。点击 Installed Apps 栏下面的 + 号就可以选择 ipa 文件进行安装了。</p>

<h3 id="toc_6">参考文章</h3>

<ul>
<li><a href="http://www.swiftyper.com/2016/12/26/wechat-redenvelop-tweak-for-non-jailbroken-iphone/">免越狱版 iOS 抢红包插件</a></li>
<li><a href="http://www.swiftyper.com/2016/01/25/ios-tweak-install-guide/">iOS微信抢红包Tweak安装教程</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577384&amp;idx=1&amp;sn=b44a9c9651bf09c5bea7e0337031c53c&amp;scene=0#wechat_redirect">移动App入侵与逆向破解技术－iOS篇</a></li>
<li><a href="https://github.com/yohunl/DingTalkNoJailTweak">DingTalkNoJailTweak</a></li>
<li><a href="https://github.com/buginux/WeChatRedEnvelop.git">微信抢红包 Tweak 的 Github 地址</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Instagram 是如何做持续部署的]]></title>
    <link href="http://lambgao.com/2017-01-01-continuous-deployment-at-instagram.html"/>
    <updated>2017-01-01T20:24:02+08:00</updated>
    <id>http://lambgao.com/2017-01-01-continuous-deployment-at-instagram.html</id>
    <content type="html"><![CDATA[
<p>他们一天部署后台代码30到50次，大部分情况不用人为干预。直接部署master branch的代码。文章描述了他们从非常手动的快糙猛的部署代码的流程，进化到几乎是全自动的持续部署的过程。</p>

<p>如果哪个工程师成为了老鼠屎，commit了有bug的代码，导致CI的测试挂掉挂掉、或者canary机器上有太多错误，他们oncall的工程师还是得手动地revert这个commit并把这件事及时通知团队其他成员。软件工程真是团体运动，每个人都要力争成为一个好队友。</p>

<p>有效的、全面的、快速的测试，是实践持续部署的基础。</p>

<span id="more"></span><!-- more -->

<p>在Instagram，我们每天要将后端代码部署30-50次（每当工程师将改动提交到主分支以后，就要重新部署）。其中的大部分部署是不需要人为干预的。尽管这种做法看起来很疯狂，尤其是在Instagram目前的规模情况下，它却工作的很好。<a href="http://engineering.instagram.com/posts/1125308487520335/continuous-deployment-at-instagram/">本文</a>就介绍了我们是如何实现该系统并使得它能够很好的工作的。</p>

<h3 id="toc_0">我们为什么要实现这样的系统</h3>

<p>对于我们而言，持续部署有很多好处：</p>

<ol>
<li>它使得我们的工程人员可以快速开发。他们可以不受限于每天只能在固定的时间进行固定次数的部署；相反，他们可以在任何有需要的时候部署代码。这就意味着，他们不需要浪费太多时间，而且能够快速的针对变化进行迭代。</li>
<li>它使得识别错误提交变得更加容易。持续部署使得工程人员不再需要深入分析上千次的提交才能找到一个新错误的根源。相反的，他们只需要分析一次或者最多2-3次的提交即可找到错误的原因。当你以后发现一个错误需要去调试时，该方法也会非常有用。指明该问题的量度或数据可被用于识别一个精确的开始时间。而从中，我们就可以找到该时间有哪些提交被部署。</li>
<li>错误提交可以很快被检测到并进行处理。这就意味着我们不会导致主分支一团混乱，从而导致其他不相关变化的部署时间的巨大延迟。我们总是处于一种可以迅速解决问题的状态。</li>
</ol>

<h3 id="toc_1">实现</h3>

<p>该实现的成功主要归功于构造的迭代方法。相比于额外的独立构造该系统然后再直接将旧系统全部转换过来的方法，我们采用了迭代策略——针对当前机制进行不断修改，直到他们变成持续部署。</p>

<h3 id="toc_2">之前的工作机制</h3>

<p>在持续部署实现之前，工程师们是依据各自的需要来部署变化的。在代码改动后，如果他们想将其尽快部署，工程师们会运行一次rollout。否则，他们会等待其他的工程师来运行rollout。这时候，工程师们需要知道如何进行小规模的测试：他们首先会针对一台机器进行rollout，登录该机器并检查日志；然后，他们再运行针对整个系统的第二轮rollout。这个过程被实现为了一个Fabric脚本，而且我们拥有一个简单的数据库和UI——Sauron来存储rollout的日志。</p>

<h3 id="toc_3">金丝雀版本和测试</h3>

<p>第一步就是添加金丝雀——脚本化需要工程师完成的工作。不再针对单个机器运行单独的rollout，将脚本部署到金丝雀机器，跟踪用户日志，然后决定是否继续进行全面部署。接下来，针对金丝雀机器进行一些基本分析：一个脚本分析每个请求的HTTP状态代码，将其分类并使用硬编码的百分比阈值（例如，少于0.5%的5xx，至少90%的2xx）。然后，它只会在超过阈值时向用户发出警告。</p>

<p>我们已经有了一个测试套件，但工程师只在他们的部署机器上运行该套件。代码审查人员不得不相信编码人员的话，认为测试已经通过。而且，我们并不知道提交到主分支后的测试状态。因此，我们安装了Jenkins来测试主分支上新的提交，并将结果报告给Sauron。Sauron会追踪最近通过测试的提交，并建议在rollout时使用该提交（而非最近的提交）。</p>

<p>Facebook使用<a href="http://phabricator.org/">Phabricator</a>进行代码审查，并使用了能够和Phabricator很好集成的持续集成系统——Sandcastle。每当一个diff被创建或更新时，我们利用Sandcastle来运行测试，并将结果报告给diff。</p>

<h3 id="toc_4">自动化</h3>

<p>为了能够自动化，我们首先需要完成一些准备工作。我们对rollout添加了一些状态（运行中、结束、错误）。如果之前的rollout不在“结束”状态的话，脚本会发出警告。我们还在UI中添加了一个可以将状态修改为“放弃”的放弃按钮，并使得脚本偶尔去检查状态、做出响应。我们还添加了全部提交跟踪；Sauron不再仅仅保存最近通过测试的提交，它记录了主分支的每一次提交，并知道每个提交的测试状态。</p>

<p><img src="https://cdn-images-1.medium.com/max/800/0*NqSru6Ta--_RHC_X.png" alt="(图片)"/></p>

<p>然后，我们将剩余的、需要由人类来定夺的决定自动化。第一个就是究竟选择哪个提交进行rollout。初始算法是总是选择一个通过测试的提交并尽可能的少选——绝对不超过3个。如果每个提交都通过了测试，它每次只选择一个新的提交，而且没有通过测试的连续提交至多只有两个。第二个决定是rollout是否成功。如果超过1%的主机无法部署，该rollout就被认为失败了。</p>

<p>这里，当若干个“yes”出现的时候（接受建议的提交、开始金丝雀版本以及全部署），进行一次rollout。因此，我们允许这些问题可以自动回答，并使得Jenkins运行rollout脚本。刚开始，工程师会在其桌面电脑中监控Jenkins的运行。后来，他们发现自动化完全可以正常进行，便不再监控。</p>

<h3 id="toc_5">问题</h3>

<p>当我们在这个阶段进行持续部署时，过程并不顺利。我们需要解决一些问题。</p>

<h4 id="toc_6">测试失败</h4>

<p>工程师们总会遇到无法通过测试的diff——它们会引起后续的主分支提交无法通过测试，从而使得它们无法部署。相关工程师就需要注意这种情况、撤销引发问题的提交、等待回卷后提交的代码通过测试，并在自动化流程继续之前手动rollout所有积压的提交。这极大的损害了持续部署的主要好处之一——每次rollout部署极少的提交。其问题在于测试非常慢，而且不可靠。为了解决该问题，我们进行了各种优化，将测试时间从12-15分钟缩减到了5分钟，并修复了引起测试框架不可靠的一些问题。</p>

<h4 id="toc_7">积压</h4>

<p>尽管进行了很多改进，我们仍然会遇到很多需要被部署的变化积压在一起的情况。最常见的原因就是金丝雀测试失败（有的是误报，有的是真有问题），当然也有一些其他的原因。当这些问题都被解决以后，自动化的过程就可以继续，每次也只部署一个提交。因此，将积压清除肯定要花费一定的时间，而且会引起新的diff的巨大延迟。这时候，工程师会介入，一次部署所有的积压——这大大损害了持续部署的主要好处之一。</p>

<p>为了改善这种局面，我们在提交选择逻辑中实现了积压处理——当积压出现时，系统自动部署多个提交。其算法的基本想法是为每次提交设定一个时间线（30分钟）。对于队列中的每个提交，它会计算满足时间要求的剩余时间、在剩余时间内能够完成的rollout数目以及每个rollout需要部署的提交数。它会选择最大的提交/rollout值，但上限为3。这使得我们可以在保证提交的rollout时间上限的情况下，完成尽可能多的rollout。</p>

<p>积压的一个特殊原因是随着框架规模的扩大，rollout变得越来越慢。我们已经到了一个尴尬的境地——ssh-agent钳住了整个认证SSH连接的核心，而fab主进程钳住了管理所有任务的核心。其解决方案是切换到Facebook的分布式SSH系统。</p>

<h3 id="toc_8">指导原则</h3>

<p>那么，为了实现我们已经完成的系统，我们需要哪些东西呢？以下就是我们能够使得系统很好工作的一些关键原则，供大家参考：</p>

<ol>
<li>测试：测试套件需要运行速度快。它需要有合适的覆盖率，但并不需要非常完美。测试需要经常运行：代码审查阶段、landing前后。</li>
<li>金丝雀：你需要一个自动化的金丝雀，来防止错误提交部署到整个系统。它不需要十分完美，但即使一个简单的统计和阈值集合也就足够了。</li>
<li>自动化正常的情况：你不需要自动化每一种情况；只需要自动化已知的、正常的情况。如果出现非正常的情况，将自动化过程停下来加入人工参与。</li>
<li>使得人们感觉良好：我认为，这类自动化的一个巨大障碍就是人们觉得失去连接和控制的时候。为了解决该问题，系统需要提供它已经完成、正在进行以及将要进行的工作的内容。它还需要好的停止机制。</li>
<li>预见到错误部署：错误的改变总会出现，但没关系。你只需要迅速发现这种情况，并能够迅速回卷。</li>
</ol>

<p>以上就是很多其他公司都可以实现的内容。持续部署系统不需要复杂。从专注以上原则的简单东西入手，然后慢慢改善。</p>

<h3 id="toc_9">未来</h3>

<p>现在系统运行正常，但我们仍然需要解决一些挑战以及进行一些改善：</p>

<ul>
<li>保持系统快速：Instagram正在快速发展，而提交的速度也会持续增加。我们需要保持rollout的快速，以使得每个rollout的提交数目可以保持在3个以内。一个可能就是将rollout划分成多个阶段，并用流水线来实现。</li>
<li>添加金丝雀：随着提交速度的增加，金丝雀失效和积压会越来越影响开发人员。我们希望能够阻止错误提交影响到主分支，从而影响部署。因此，我们正在将金丝雀实现为Landcastle的一部分。在测试通过以后，Landcastle会利用生产环境流量来测试改动。如果改动未通过金丝雀阈值，Landcastle会放弃金丝雀部署。</li>
<li>更多的数据：未来，我们希望改进金丝雀的检测能力。因此，我们正在规划收集和检查更多的统计数据，比如每个视图的函数响应代码。我们也正在尝试从一堆控制机器中收集统计数据，并将其与金丝雀统计数据进行比对（而非现在的所采用的，与静态阈值进行比对）。</li>
<li>改进探测：如果能够减少没有被金丝雀发现的错误提交的影响，那就最好了。之前，我们总是先在一台机器上进行测试，然后再将其部署到整个系统。未来，我么可以添加更多的中间阶段（一个集群或一个区域），然后在这些阶段检查相关的量度。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016 总结 - 工作十小时，休息五分钟]]></title>
    <link href="http://lambgao.com/2016-12-30-life-2016.html"/>
    <updated>2016-12-30T16:38:53+08:00</updated>
    <id>http://lambgao.com/2016-12-30-life-2016.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">工作与项目</h3>

<p>今年的工作内容主要是负责移动端，iOS、Android、H5等，甚至微信服务号方面的工作，会实际参与iOS的打码（项目实际使用的objective-c）。</p>

<p>今年的项目主要是数字4S店一期，一期项目主要做D端的APP应用（iOS和Android），主要功能是方便处理来自4S店微信服务号的业务。下面来段专业的介绍：是一款装载于智能手机上的移动化应用产品，将基于互联网思维，在互联网、大数据、云计 算等科技不断发展的背景下，为经销商售前售后人员，整合日常工作中所使用到SGM业务系统的主要功能。该产品的诞生，将解决业务人员依赖台式电脑的低效工作方式，取而代之是在App上随时获取客户信息、便捷与客 户进行联系、快速记录保存有效内容;并改变客户信息 收集的模式(经销商输入 -&gt; 客户输入/自动采集)。</p>

<p>这是公司接触通用汽车的第一个项目，项目组对于客户的沟通和工作方式前期不是很适应，也有一方面是人员配置和其他因素的问题，所以前期非常吃力。这也是我参与的第一个移动端的项目，所以我非常不希望这个项目失败，在前期看到项目进度不容乐观的情况下，主动参与了不是我负责的内容，比如原型制作、需求确认的工作。总之，根本不管是啥方面的活，只要有力就出力，冲着问题，抓紧解决，继续前行。项目期间有时会很心急，估计也得罪了一些人，但是自己其实只是对事不对人。也没办法奢望得到原谅，只能在以后尽量改掉，少说。功夫不负有心人，终于项目在几个通宵后，顺利上线。这个项目整整持续了大半年，由于前期浪费了很多时间，所以工期很紧，基本是天天加班，简直是工作十小时，休息五分钟。经历完这个项目后，对我正面的成长基本没有，但是有很多反面的收获，下面会分成类一一记录下来。</p>

<span id="more"></span><!-- more -->

<ul>
<li>[技术] 技术选型不能主观评定，不要带个人感情来进行讨论</li>
<li>[技术] 架构要迎合技术趋势，不能太保守，当然也不能太超前；不能说因为我不会所以那东西就不好，不建议使用</li>
<li>[技术] 后端架构不要反来影响前端，后端是服务前端的，前端需要良好的用户体验</li>
<li>[技术] 前后端的代码规范都很重要，代码写出来是给别人看的，不能仅仅是为了交差，图一时之快，也要考虑一下项目的可维护性，尽量少给别人挖坑</li>
<li>[技术] 后端与前端是紧密配合的，推卸任务定出的方案肯定不是最优方案，需要细细梳理、冷静思考</li>
<li>[技术] 前端少逻辑才能少代码才能少bug，由于架构或者数据的问题仍给前端处理是非常荒唐的,前端也需要平等地位</li>
<li>[技术] 不写代码，不落地的架构师还不如没有</li>
<li>[产品] 业务需求需要细细梳理，不是只画画流程图</li>
<li>[产品] 界面与交互需要研讨后再画会更高效</li>
<li>[产品] 画UI的时候就应该让前端考虑如何布局，不要让美工出像素图来布局</li>
<li>[产品] 美工的审美很重要，最好要强迫症，完美主义者</li>
<li>[产品] 需求和测试在项目末尾阶段还都不完全清楚需求是这么可怕，内容要形成图或者文字，口头传达的没用，没约束力</li>
<li>[产品] 对于细节点是产品需要花时间去思考的，不能前期不思考放任开发自有发挥，等后续客户提出自己的想法再让开发去修改，产品反而说当时又没办法思考的这么细</li>
<li>[管理] 资源需要充分利用，多开小会多研讨</li>
<li>[管理] 前端、后端、业务是紧密结合的，全分开是没办法融合配合做出想要的内容的</li>
<li>[管理] 对APP的工作量估算太低，其实工作量巨大</li>
<li>[管理] 不能临时换帅，而且是换来换去，走走去去</li>
<li>[管理] PM需要控制团队的情绪，掌控节奏，激励团队，解决难题，稳步向前</li>
<li>[管理] 团队大需要及时进行切分，一个人最多管理7个人</li>
<li>[管理] 项目不能疲劳作战，要可持续性发展</li>
<li>[管理] 资源与架构的问题是PM和架构师需要协调解决的，不要团队其他人互相推诿</li>
<li>[管理] 浑水摸鱼的人不要，该杀就杀，不要手软</li>
<li>[管理] 对于分工要明确，对于不属于自己的内容应该先明确不是，然后再从项目角度出发，自己可以为团队做什么，否则直接做了不属于自己的内容，别人以为是理所当然，自己觉得很委屈</li>
<li>[管理] 团队成员不能拿“我不会”做为挡箭牌，不管是技术还是需求还是测试</li>
<li>[测试] 测试不要依赖于前后端，应该独立思考</li>
<li>[测试] 测试是项目中很重要的一环，不能混，敷衍，准出的关要把好</li>
<li>[招聘] 宁缺毋滥，招聘不能着急，不用过于考虑其他的杂项</li>
</ul>

<h3 id="toc_1">开人与压榨</h3>

<p>你开过人吗？我开过。这是第一次开一个人（我们暂且叫他Z吧），也就是试用期没有续签合同。这方面问题以前从来没有出现过，我面试还是属于比较谨慎的，后来想了一下，还是因为当时太着急了。当时处于项目需求已经确认完毕，已经开始进行开发工作，但是还差一个iOS开发。天天看着项目计划上面的进度甘特图红色的条越来越多，真的是很着急。由于项目时间紧，我也在一直在忙于其他的方面的工作，没有时间专心去进行面试招聘工作。当时面试Z的时候，对着简历问了一遍，看了他以前做的APP，也有可能是前面几个面试的太差了，考虑到已经有任务开始过期了，在纠结一会儿后决定录用。但是入职后，不管是代码质量和进度都不是很满意。突然有一天，人事给我打电话问，你觉得Z怎么样。我如实说了情况，就没放在心上，然后继续去工作十小时休息五分钟了。但是过一会儿人事又打电话过来说，公司决定不和Z继续签合同，他有工作经验等方面的造假，他暂时也提供不了有效证件无法给他缴纳社保公积金等。我当时有点懵，然后听的有点凌乱，大概意思就是公司会处理善后，你无需参与。当天晚上我就在想，如果我的评语稍微好一点，是不是这个人就不会被开了。这件事情纠结了好长时间，唉...</p>

<p>你压榨过人吗？我压榨过。这是我第一次盯一个人（我们暂且叫他Q吧）盯这么紧。我个人属于效率较高，喜欢时间比较松散的，所以对于下面的人员管理还是比较松散的，不是属于强压类型的。一般工作内容和工作计划都是团队共同制定的，大家全都认可的，然后大家按照计划执行。我不会故意收紧时间。原本需要一周的时间，一定强压三天完成，大家都是一直紧张的加班的状态下。我一直认为加班只是短期有效，长期无效的。长时间的加班会越来越效率低下，质量会越来越差。Q其实是Z的接替者，也是Z走后招聘进来的，工作内容方面的表现会稍优于Z，工作经验也不是特别丰富。但是Q的态度还是非常认真的，有时工作都到凌晨一点钟，然后第二天九点钟继续。Q对自己的时间管理不是很好，有些拖拉，代码质量方面也不是特别好，bug特别多。在后期的有一段时间里，他基本上是和我”结对“编程的。我要求他对自己的工作内容切分成2个小时的小任务，然后一一执行，快速的解决问题。那段时间Q的压力应该是最大的，幸好他坚持了下来。后来想想，以后真的再也不会这么干了，唉...</p>

<p>前面说了，加班到凌晨然后第二天九点继续，这根本保证不了休息，因为还要回家，在路上还一段时间。这方面我早就想到了，在办公地的附近给所有的开发人员安排了宿舍或者酒店，大概5分钟就可以到休息的地方，洗澡睡觉。在这个项目，我也承担了保姆的角色，点餐、订座、住宿、打球订场只要是对项目有益的活动都可以安排。这个项目的伙食等生活方面，还是得到了项目组童鞋的一致好评，这我很欣慰。其实真正压榨的人是BOSS，我也只是一个干活的，我也是被压榨的，唉...</p>

<h3 id="toc_2">关于招聘与团队文化建设</h3>

<p><em>今天集中面试，人事共预约了40人，实际来31人，面试28人，有3个不知道什么原因做笔试题半路走了，还有一个奇葩连笔试题都带跑了😓。最后，心态有点小爆炸💥</em></p>

<p>这是6月的一条朋友圈内容。这应该也是面试的极限了，当时下午连一口水都没有喝，平均15分钟一个好像。</p>

<p>为什么会需要面试这么多人？因为真的iOS的应聘者鱼龙混杂，很多人是看着高薪资去的，但是并没有实际的能力，甚至有些人去了无良的培训机构，简历和经历都是造假的。有一个面试者，项目和基础问题都答得挺好，然后让他写一个iOS开发中最常用到的UITableView竟然无从下手，无奈只能如实说简历方面有些地方不是真实的。</p>

<p>为什么会有这么多应聘者？因为很多公司倒闭了。面试中，当问题为什么离职时，很多人都说公司倒闭了，公司业务调整了，公司融资的钱花完了。所以一方面可以看出国家的经济是多少的萧条，另一个方面也可以看出今年是移动互联网萧条的一年。前几天看到一个帖子，<a href="http://www.cocoachina.com/programmer/20161226/18437.html">哈哈哈哈哈哈哈哈哈哈哈《iOS界裁员：从入门到精通》</a>，哈哈哈仅供娱乐。</p>

<p>公司的移动团队是去年底才刚开始组建的。当时公司根本没有一个这方面经验的人，但是我业余学习的内容比较广泛，所以我接受了这个组建移动端团队的任务。但是今年在移动方面的招聘做的还是不够，也是因为项目特别紧特别忙的原因没有时间嘛。但是移动团队的人员收获还是挺大的，小团队已经初步完成。目前移动团队中已经有3个iOS开发（包括我），3个Android开发，2个Web前端开发，1个美工。希望移动团队可以越来越壮大，团队氛围越来越好。</p>

<p>我一直提倡团队成员要有分享精神，在公司也组织了非常多的内部分享活动，想带动一下公司的技术氛围。但是参与的人目前还是主要是我下属的童鞋比较多，其他项目组参与的真的很少。期间由于项目紧张停止过一段时间，后续空闲后，技术分享会继续。但是期望会改变，先带动移动小团队的技术氛围吧，毕竟全公司的话人员太多。对于团队文化建设看到过<a href="https://www.zhihu.com/question/19662593">知乎的一个回答</a>感觉说的还是挺好的：对于任何一个团队和公司，决定团队文化的是领导者本人。而小公司靠感情、中等公司靠制度，大公司靠文化。初创团队重要的不是文化，而是感情维系。和你的团队成员成为朋友吧，有共同的兴趣和爱好，一起腐败、一起K歌、一起郊游，你们共同的价值观将会在了解中塑造，在熟悉中成长。</p>

<h3 id="toc_3">技术</h3>

<p>这一年其实技术方面的成长不是很多，主要是因为项目忙。</p>

<h4 id="toc_4">Java</h4>

<p>今年基本没有写过Java方面的代码，对于Java 8的一些新特性了解甚少，明年Java 9就发布了，希望明年可以有时间多看看Java方面的内容。</p>

<h4 id="toc_5">Node.js</h4>

<p>基本没看，工作中也毫无用处。自己发起的项目<a href="http://www.nodeclipse.org/">Nodeclipse</a>已经发展的异常庞大，有好多老外贡献代码和维护，现在我已经基本插不上手了。</p>

<h4 id="toc_6">objective-c</h4>

<p>今年的主力语言，因为今年的大部分工作都是移动端的，会实际参与iOS的打码。后续会参照objective-c的知识结构图整体回顾一下，加深一下对objective-c的理解。</p>

<h4 id="toc_7">Swift</h4>

<p>项目一开始想使用Swift来开发的，但是阻力太多，最终还是选择了保守的objective-c。Swift已经来到了3的版本，已经趋于稳定，真希望后续的项目尽快可以使用Swift来进行开发。</p>

<h4 id="toc_8">iOS</h4>

<p>对于一些设计模式和Runtime的内容理解还是很不够，以后要多多了解，多看看别人实际经验的分享。</p>

<h4 id="toc_9">前端</h4>

<p>现在的大前端的技术真实日新月异，发展非常快，需要了解的内容非常多。稍后会参照这篇文章 <a href="http://www.infoq.com/cn/articles/2016-review-frontend">2016前端开发技术巡礼</a> 尽可能多的学习了解一下。</p>

<h4 id="toc_10">架构</h4>

<p>项目主要对微服务和领域模型使用较多，但是使用的效果并不理想。对于架构感觉需要了解的内容还是非常多的，已经准备了相关书籍，后续会充电起来。</p>

<h4 id="toc_11">Sketch</h4>

<p><a href="https://www.sketchapp.com/">Sketch</a>是一个非常出色的原型设计工具。当初买的时候花了328软妹币（49刀好像，现在已经涨价到99刀），但是后来用了之后发现确实非常的赞。在今年的项目中我参与了三个岗位角色原型图的制作，可以通过下面的三个链接感受一下，销售顾问： <a href="https://marvelapp.com/ce3234">https://marvelapp.com/ce3234</a> 销售经理：<a href="https://marvelapp.com/j14ehd">https://marvelapp.com/j14ehd</a> 总 经 理：<a href="https://marvelapp.com/2047g7a">https://marvelapp.com/2047g7a</a></p>

<h3 id="toc_12">电影、剧与书</h3>

<p>以下排名不分先后。</p>

<h4 id="toc_13">电影 你的名字</h4>

<p>能够遇见不容易，要珍惜。</p>

<h4 id="toc_14">电影 湄公河行动</h4>

<p>哮天犬死了，真的很桑心。缉毒警察真的很辛苦。对于吸毒、贩毒没有重新悔改的机会，除非哮天犬和牺牲的缉毒警可以复生。</p>

<h4 id="toc_15">电影 大鱼海棠</h4>

<p>国产动画还需努力。美术和音乐真的很好，很喜欢。买了大鱼海棠的两幅画，送了一幅给好童鞋，自己还暂留一幅。</p>

<h4 id="toc_16">电影 驴得水</h4>

<p>不能当喜剧片看的喜剧片。过去的怎能让它过去？</p>

<h4 id="toc_17">电影 血战钢锯岭</h4>

<p>在上战场的路上，看到一车刚从战场上运回的尸体，是怎样的一个心境？</p>

<h4 id="toc_18">电影 魔兽</h4>

<p>暴雪粑粑终于开窍了，终于成立了自己的动画电影公司。你本来就是一家专业的电影公司，副业是游戏，何必要请别人来拍自家的剧本，拍的自己都没脸参与宣传。</p>

<h4 id="toc_19">剧 权利的游戏</h4>

<p>三傻到底傻不傻，二丫不会杀了三傻吧？</p>

<h4 id="toc_20">剧 西部世界</h4>

<p>正在看，脑洞很大。</p>

<h4 id="toc_21">剧 青云志</h4>

<p>剧一般，后面快进坚持看完的。只能说萧鼎的书以后再也不会看了。还有另外一本书《藏地密码》也拍成了电视剧，看了十分钟真的看不下去放弃了。</p>

<h4 id="toc_22">书 <a href="https://www.amazon.cn/%E6%88%91%E4%B8%8D%E6%98%AF%E6%BD%98%E9%87%91%E8%8E%B2-%E5%88%98%E9%9C%87%E4%BA%91/dp/B00R65ZPF2/ref=sr_1_1?ie=UTF8&amp;qid=1483119618&amp;sr=8-1&amp;keywords=%E6%88%91%E4%B8%8D%E6%98%AF%E6%BD%98%E9%87%91%E8%8E%B2">我不是潘金莲</a></h4>

<p>我看的书，看完书觉得根本不用去电影院看了。不管是刁民还是官员，想进人民大会堂都挺难的。</p>

<h4 id="toc_23">书 <a href="https://www.amazon.cn/%E6%9C%80%E5%90%8E%E7%9A%84%E8%80%8D%E7%8C%B4%E4%BA%BA-%E9%A9%AC%E5%AE%8F%E6%9D%B0/dp/B00SR215IY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119632&amp;sr=1-1&amp;keywords=%E6%9C%80%E5%90%8E%E7%9A%84%E8%80%8D%E7%8C%B4%E4%BA%BA">最后的耍猴人</a></h4>

<p>今年正好是猴年，在年初看的这本书。猴子和人同吃一锅饭，同睡一张床，结一辈子的伴，行走江湖，赚钱养家，猴子和人养育各自的儿女，他们一起生活，一起老去，一起消逝于这个时代。</p>

<h4 id="toc_24">书 <a href="https://www.amazon.cn/%E7%A8%80%E7%BC%BA-%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E9%99%B7%E5%85%A5%E8%B4%AB%E7%A9%B7%E4%B8%8E%E5%BF%99%E7%A2%8C%E7%9A%84-%E5%A1%9E%E5%BE%B7%E5%B8%8C%E5%B0%94%C2%B7%E7%A9%86%E6%9D%A5%E7%BA%B3%E6%A3%AE/dp/B016ZRR4UK/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119650&amp;sr=1-1&amp;keywords=%E7%A8%80%E7%BC%BA-%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E9%99%B7%E5%85%A5%E8%B4%AB%E7%A9%B7%E4%B8%8E%E5%BF%99%E7%A2%8C%E7%9A%84">稀缺-我们是如何陷入贫穷与忙碌的</a></h4>

<p>如果你还在一直加班，这本书的第九章，或许是你的良方。</p>

<p>除了上面的书还看了一些其他的书籍</p>

<ul>
<li><a href="http://www.ituring.com.cn/book/1761">远程入侵原装乘用车</a></li>
<li><a href="https://www.amazon.cn/%E5%88%9B%E4%B8%9A%E7%BB%B4%E8%89%B0-%E6%9C%AC%C2%B7%E9%9C%8D%E6%B4%9B%E7%BB%B4%E8%8C%A8/dp/B00WQX0YY6/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119677&amp;sr=1-1&amp;keywords=%E5%88%9B%E4%B8%9A%E7%BB%B4%E8%89%B0">创业维艰</a></li>
<li><a href="https://www.amazon.cn/%E7%81%AB%E6%98%9F%E6%95%91%E6%8F%B4-%EF%BC%BB%E7%BE%8E%E5%9B%BD%EF%BC%BD%E5%AE%89%E8%BF%AA%C2%B7%E5%A8%81%E5%B0%94/dp/B0154K86WY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119691&amp;sr=1-1&amp;keywords=%E7%81%AB%E6%98%9F%E6%95%91%E6%8F%B4">火星救援</a></li>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E8%A7%A3HTTP-%E6%97%A5-%E4%B8%8A%E9%87%8E/dp/B0153170B2/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119705&amp;sr=1-1&amp;keywords=%E5%9B%BE%E8%A7%A3HTTP">图解HTTP</a></li>
<li><a href="https://www.amazon.cn/%E5%B2%9B%E4%B8%8A%E4%B9%A6%E5%BA%97-%E5%8A%A0%C2%B7%E6%B3%BD%E6%96%87/dp/B00WM1P75S/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119719&amp;sr=1-1&amp;keywords=%E5%B2%9B%E4%B8%8A%E4%B9%A6%E5%BA%97">岛上书店</a></li>
<li><a href="https://www.amazon.cn/%E4%BC%98%E7%A7%80%E7%9A%84%E5%8F%9B%E9%80%86%E8%80%85-%E5%BC%95%E9%A2%86%E7%BB%84%E7%BB%87%E5%8F%98%E9%9D%A9%E7%9A%84%E5%8A%9B%E9%87%8F-%E7%BE%8E-%E5%87%AF%E8%8E%89-%E6%A2%85%E8%BF%AA%E7%BA%B3/dp/B01F7IEMBM/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119734&amp;sr=1-1&amp;keywords=%E4%BC%98%E7%A7%80%E7%9A%84%E5%8F%9B%E9%80%86%E8%80%85">优秀的叛逆者</a></li>
<li><a href="https://www.amazon.cn/%E7%B2%BE%E9%80%9AiOS%E5%BC%80%E5%8F%91-%E9%A9%AC%E5%85%8B/dp/B015WPM992/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119748&amp;sr=1-1&amp;keywords=%E7%B2%BE%E9%80%9AiOS%E5%BC%80%E5%8F%91">精通iOS开发(第7版)</a></li>
<li><a href="https://www.amazon.cn/%E4%B8%BA%E4%BD%95%E5%AE%B6%E4%BC%9A%E4%BC%A4%E4%BA%BA-%E6%AD%A6%E5%BF%97%E7%BA%A2/dp/B00MXQGSR8/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119789&amp;sr=1-1&amp;keywords=%E4%B8%BA%E4%BD%95%E5%AE%B6%E4%BC%9A%E4%BC%A4%E4%BA%BA">为何家会伤人</a></li>
<li><a href="https://www.amazon.cn/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BB-%E5%AD%94%E6%99%AE-%E8%91%97/dp/B00YG79LWQ/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119802&amp;sr=1-1&amp;keywords=%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BB">如何高效阅读</a></li>
<li><a href="https://www.amazon.cn/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E9%9C%8D%E5%A4%9A%E7%BD%97%E5%A4%AB/dp/B00JVLEYYW/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119814&amp;sr=1-1&amp;keywords=MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97">MongoDB权威指南(第2版)</a></li>
<li><a href="https://www.amazon.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%91%A8%E5%BF%97%E5%8D%8E/dp/B01ARKEV1G/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119845&amp;sr=1-1&amp;keywords=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">机器学习</a></li>
<li><a href="https://www.amazon.cn/%E5%BD%93%E4%BD%A0%E7%9A%84%E6%89%8D%E5%8D%8E%E8%BF%98%E6%92%91%E4%B8%8D%E8%B5%B7%E4%BD%A0%E7%9A%84%E6%A2%A6%E6%83%B3%E6%97%B6-%E7%89%B9%E7%AB%8B%E7%8B%AC%E8%A1%8C%E7%9A%84%E7%8C%AB/dp/B01MXIRVRD/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119857&amp;sr=1-1&amp;keywords=%E5%BD%93%E4%BD%A0%E7%9A%84%E6%89%8D%E5%8D%8E%E8%BF%98%E6%92%91%E4%B8%8D%E8%B5%B7%E4%BD%A0%E7%9A%84%E6%A2%A6%E6%83%B3%E6%97%B6">当你的才华还撑不起你的梦想时</a></li>
<li><a href="https://www.amazon.cn/%E4%BD%A0%E5%8F%AA%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E5%8A%AA%E5%8A%9B-%E6%9D%8E%E5%B0%9A%E9%BE%99/dp/B017IZ45E6/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119881&amp;sr=1-1&amp;keywords=%E4%BD%A0%E5%8F%AA%E6%98%AF%E7%9C%8B%E8%B5%B7%E6%9D%A5%E5%BE%88%E5%8A%AA%E5%8A%9B">你只是看起来很努力</a></li>
<li><a href="https://www.amazon.cn/%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C%E5%A4%96%E4%BC%A0-%E4%B8%83%E7%8E%8B%E5%9B%BD%E7%9A%84%E9%AA%91%E5%A3%AB-%E4%B9%94%E6%B2%BB%C2%B7R-R-%E9%A9%AC%E4%B8%81/dp/B00HF317DY/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119894&amp;sr=1-1&amp;keywords=%E4%B8%83%E7%8E%8B%E5%9B%BD%E7%9A%84%E9%AA%91%E5%A3%AB">冰与火之歌外传:七王国的骑士</a></li>
<li><a href="https://www.amazon.cn/%E5%A5%87%E8%BF%B9-%E4%BD%9C%E8%80%85-%E6%97%A5-%E6%98%AF%E6%9E%9D%E8%A3%95%E5%92%8C-%E4%B8%AD%E6%9D%91%E8%88%AA/dp/B01M4OLNEI/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119918&amp;sr=1-1&amp;keywords=%E5%A5%87%E8%BF%B9">奇迹</a></li>
<li><a href="https://www.amazon.cn/%E6%96%B0%E5%AA%92%E4%BD%93%E8%90%A5%E9%94%80%E5%9C%A3%E7%BB%8F-%E5%BC%95%E8%AF%B1-%E5%BC%95%E8%AF%B1-%E5%BC%95%E8%AF%B1-%E5%87%BA%E5%87%BB-%E5%8A%A0%E9%87%8C%E2%80%A2%E7%BB%B4%E7%BA%B3%E6%9F%A5%E5%85%8B/dp/B01GLCZ1HW/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1483119930&amp;sr=1-1&amp;keywords=%E6%96%B0%E5%AA%92%E4%BD%93%E8%90%A5%E9%94%80%E5%9C%A3%E7%BB%8F%EF%BC%9A%E5%BC%95%E8%AF%B1%EF%BC%8C%E5%BC%95%E8%AF%B1%EF%BC%8C%E5%BC%95%E8%AF%B1%EF%BC%8C%E5%87%BA%E5%87%BB%EF%BC%81">新媒体营销圣经：引诱，引诱，引诱，出击！</a></li>
</ul>

<h3 id="toc_25">运动</h3>

<p>自行车基本没骑，网球打的次数很少。项目比较紧，有段时间每天晚上跑步2.5公里，和Keep无器械健身一组。不过最近没运动，运动还是需要坚持啊。</p>

<h3 id="toc_26">酒店与饭店</h3>

<p>酒店，今年住莫泰整整住了大半年。因为客户要求在客户提供的地址办公，每天单趟在路上的时间就2个半小时左右，所以为了节省时间就再办公地附近租了一间三室一厅的房子。但是房子还是太小了，根本住不下，所以有些童鞋就只能临时住莫泰酒店了。谁知道这临时的一小住竟然住了大半年。住了大半年的房价才现在这个太消耗成本了，稍微计算了一下，今年花在酒店住宿上面的金额大概是10W+，这钱花在什么地方上面不好呀。最近这一年多快两年的时间，接触到这种开公司的额外花销越来越多，才知道原来创业即使不是像滴滴那些纯烧钱的公司一样也还是非常烧钱的，到处都需要花钱。一年的酒店没有白住，住酒店也是有收获。如果是短住，酒店价格应该是网络上面的最便宜；如果是长住，可以和酒店经理协商价格。协商的价格也是浮动的，随时关注价格，因为酒店也分闲时和忙时。比如我住的这里夏天的时候一般都是忙时，冬天的时候一般都是闲时。我这里就吃了亏，我是忙时入住的，协商的价格较高，住了很长时间，住到了闲时，这个价格一直不变就非常不划算了。酒店价格可浮动的空间还是蛮大的，还是要精打细算才能节省。</p>

<p>饭店，项目组基本每周我都会安排一次聚餐，大家一起喝点酒，放松一下，畅快聊天。有家饭店我们一直经常去，因为这家店实在是太便宜了。这家店应该算是我在上海呆这么长时间吃过的最便宜的店，没有之一。魏记小厨，是这家店的名字。店面装修一般，但也不是特别差，有三层。这家店既便宜，菜量又大，非常的实惠。来一个数字大家感受一下，两桌十人餐，算酒水也就一千块左右，这个价格在上海真的是不敢想象，去别的店估计只能来一桌吧。为什么这家店这么便宜呢？这一年也不是白吃，也吃出了点收获。价格便宜，肯定要降低陈本，这家店的房子是老板自己的，所以老板少了在上海开店非常大的一个成本房租。另外这家店的老板菜市场都送他外号叫“鬼子”，因为他都是在傍晚来进货的，不是早上来进货，他基本都是扫尾的，所以他拿到的菜的价格都是最低的。虽然他是扫尾的，有可能菜的质量可能有些欠佳，但是目前来看老板应该还是注重品质的，特别差的应该也不要，只是让菜贩子预先给他预留一些他想要的菜，并不是去菜市场捡破烂的那种。现在大城市的餐饮业应该是最火的，吃相关的盈利应该都是百分之五十赚一半。其实开个餐饮类的店面也是非常赚钱的，即使不是这种三层的大饭店。听一个卖菜饭的老板说，他有个同学也卖菜饭，他周末都不上班，他只周一到周五去收钱，周六周天就让店里的人收。他现在五个店，一年赚大几十万。这种成功的例子有，但是失败的例子也见了很多。以前在中山公园附近上班的时候，公司楼下的门面基本一两个月就要换一次老板，基本也是餐饮类为主。其实店面的位置还不错，附近公司挺多的，吃饭的人挺多的，但是就是经营不下去了，关门的非常多。</p>

<h3 id="toc_27">目标与计划</h3>

<ul>
<li>🦄 ”<a href="http://jianfengchazhen.com/">见缝插针</a>“，暂时保密这是什么内容</li>
<li>📚 坚持看书，一月至少2本，一本技术类，一本其他任何方面</li>
<li>🎾 多运动，周末打网球</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome插件：网易云音乐一键全赞]]></title>
    <link href="http://lambgao.com/2016-12-29-chrome-plugin.html"/>
    <updated>2016-12-29T14:44:17+08:00</updated>
    <id>http://lambgao.com/2016-12-29-chrome-plugin.html</id>
    <content type="html"><![CDATA[
<p>最近帮朋友做了一个Chrome插件，方便做一些批量的动作。对于Chrome插件有兴趣的同学可以看一下。</p>

<h3 id="toc_0">需求</h3>

<p>网易云音乐音乐详情页底部的评论区，一键自动全赞，然后翻页继续全赞直至最后一页。</p>

<h3 id="toc_1">分析</h3>

<p>那么我们以薛之谦的“<a href="http://music.163.com/#/song?id=32507038">演员</a>”这首歌页面为例仔细分析一下。首先看页面的URL <a href="http://music.163.com/#/song?id=32507038">http://music.163.com/#/song?id=32507038</a>，页面用的锚点，主url music.163.com/ 一直没变过。那么再看页面底部的评论区域，评论区域分为两部分，第一部分是精彩评论，第二部分是最新评论。最新评论下面有翻页按钮，点击第二页后，可以翻页，第二页以后的页面上部没有精彩评论。</p>

<h3 id="toc_2">实现</h3>

<p>由于代码中有注释而且非常短，就不一一解释了，直接上代码吧。<br/>
关于Chrome插件的制作可以看着里：<a href="https://www.zhihu.com/question/20179805">如何从零开始写一个 Chrome 扩展？</a></p>

<h4 id="toc_3">manifest.json</h4>

<pre><code>{
  &quot;name&quot;: &quot;云音乐&quot;,
  &quot;description&quot;: &quot;云音乐&quot;,
  &quot;version&quot;: &quot;1.0&quot;,
  &quot;permissions&quot;: [
    &quot;tabs&quot;, &quot;http://music.163.com/*&quot;
  ],
  &quot;content_scripts&quot;: [
    {
      &quot;matches&quot;: [&quot;http://music.163.com/*&quot;],
      &quot;js&quot;: [&quot;jquery.min.js&quot;, &quot;myscript.js&quot;]
    }
  ],
  &quot;manifest_version&quot;: 2
}
</code></pre>

<h4 id="toc_4">myscript.js</h4>

<pre><code>window.onhashchange = handleHashchange;
window.onerror = handleError;

var time = new Date().getTime();
var array = new Array();

$(window.frames[&quot;contentFrame&quot;].document).ready(function(){
  addButton();
});

function handleHashchange() {
  //console.log(&quot;onhashchange&quot;);
  location.reload();
}

function handleError() {
  console.log(&quot;onerror&quot;);
}

function addButton() {
  array = new Array();
  var iptarea = $(window.frames[&quot;contentFrame&quot;].document).find(&quot;.iptarea&quot;);
  //var button = $(&#39;&lt;input id=&quot;like&quot; class=&quot;btn u-btn u-btn-1&quot; type=&quot;button&quot; value=&quot;全部点赞&quot; /&gt;&#39;);
  var button = $(&#39;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;btn u-btn u-btn-1 j-flag&quot; &gt;全赞&lt;/a&gt;&#39;);

  button.click( function () {
    //绑定事件监听评论区域的数据改变
    var cmmts = $(window.frames[&quot;contentFrame&quot;].document).find(&quot;.cmmts&quot;);
    cmmts.bind(&#39;DOMNodeInserted&#39;, function(e) {
      //console.log(&#39;element now contains: &#39; + $(e.target).html());
      //console.log(&#39;element now length:%d contains:%s &#39;, $(e.target).parent().children().length, $(e.target).html());
      //console.log(&#39;element now length: &#39; + $(e.target).parent().children().length);
      //判断是否满一页，然后全部点一页
      //if ($(e.target).parent().children().length == 20) {
      //  like();
      //}
      item($(e.target));
    });

    //当前页一键全赞
    like();
  });
  var input = $(&#39;&lt;div&gt;频率&lt;input id=&quot;interval&quot; class=&quot;&quot; type=&quot;text&quot; value=&quot;0&quot; /&gt;s&lt;/div&gt;&#39;);
  iptarea.after(input);
  iptarea.after(button);
}

function like() {
  var cmmts = $(window.frames[&quot;contentFrame&quot;].document).find(&quot;.cmmts&quot;).children(&quot;.itm&quot;);
  //console.log(&quot;cmmts.length : %d&quot;, cmmts.length);
  //console.log(&quot;cmmts.html : %s&quot;, cmmts.html());
  for (var i=0;i&lt;cmmts.length;i++){
    var itm = cmmts.eq(i);
    item(itm);
  }
  next();
}

function item(itm) {
    time = new Date().getTime();
    var rp = itm.find(&quot;.cntwrap .rp a&quot;);
    //console.log(rp.html());
    //console.log(rp.attr(&quot;data-type&quot;));
    if(rp.attr(&quot;data-type&quot;) == &quot;like&quot;){
      //console.log(rp.html());
      var zan = rp.children();
      //console.log(zan.html());
      zan.click();
    }
}

function next() {
  var upage = $(window.frames[&quot;contentFrame&quot;].document).find(&quot;.u-page&quot;).children();
  //console.log(&quot;upage.length : %d&quot;, upage.length);
  if (upage.length &gt; 0) {
    var znxt = upage.eq(upage.length - 1);
    if(!znxt.hasClass(&#39;js-disabled&#39;)){
      znxt.html(&quot;&lt;span&gt;下一页&lt;/span&gt;&quot;);
      //console.log(&quot;znxt.html : %s&quot;, znxt.html());
      znxt.children().click();
    }
  }
  var interval = $(window.frames[&quot;contentFrame&quot;].document).find(&quot;#interval&quot;);
  interval = interval.val() - 0;
  //console.log(&#39;interval: %d&#39;, interval);
  setTimeout(&quot;next()&quot;, interval*1000);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[张小龙首次公开解读小程序：1月9号上线]]></title>
    <link href="http://lambgao.com/2016-12-28-wechat-small-app.html"/>
    <updated>2016-12-29T02:01:18+08:00</updated>
    <id>http://lambgao.com/2016-12-28-wechat-small-app.html</id>
    <content type="html"><![CDATA[
<p>只能说偏执的张小龙真的很厉害。</p>

<p>小程序定义：</p>

<ol>
<li>无需下载，用完即走</li>
<li>没有入口，没有排序，没有推荐</li>
<li>不能订阅</li>
<li>不能通知</li>
<li>不能分享到朋友圈，可以分享到聊天。协作式任务，小程序页，活的页面</li>
<li>不能做游戏</li>
<li>能被搜索到，但是是有限的搜索能力</li>
<li>小程序和公众号没有关系，相互独立，但有个关联，就是可以互相跳转</li>
<li>有周边推荐和提示，有哪些小程序可以用。</li>
</ol>

<p>精简一点的定义：这也不行，那也不行 =。=|</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[微服务的好处和陷阱]]></title>
    <link href="http://lambgao.com/2016-12-27-benefits-and-pitfalls-of-micro-service.html"/>
    <updated>2016-12-29T01:05:36+08:00</updated>
    <id>http://lambgao.com/2016-12-27-benefits-and-pitfalls-of-micro-service.html</id>
    <content type="html"><![CDATA[
<p>微服务架构设计代表了一种架构设计思想，配合现在的容器技术（如 Docker），可在软件开发流程、部署、服务维护等各方面产生效率提升。</p>

<p>但不一定所有的业务场景都适合微服务，有时候非常简单的业务场景下，微服务反而会降低效率。什么是微服务，其特性，好处及陷阱，是本文要讨论的内容。</p>

<h3 id="toc_0">一、什么是微服务</h3>

<p>微服务是一种软件架构风格，它是以专注于单一责任与功能的小型功能区块为基础，利用模组化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关的 API（例如 REST）集相互通讯，且每个服务可以被单独部署，它具备以下三个核心特点：</p>

<ol>
<li>微服务为大型系统而生。随着业务的快速增长，会带来系统流量压力和复杂度的上升，系统的可维护性和可扩展性成为架构设计的主要考虑因素，微服务架构设计理念通过小而美的业务拆分，通过分而自治来实现复杂系统的优雅设计实现。</li>
<li>微服务架构是面向结果的。 微服务架构设计风格的产生并非是出于学术或为标准而标准的设计，而是在软件架构设计领域不断演进过程中，面对实际工业界所遇到问题，而出现的面向解决实际问题的架构设计风格。</li>
<li>专注于服务的可替代性来设计。 微服务架构设计风格核心要解决的问题之一便是如何便利地在大型系统中进行系统组件的维护和替换，且不影响整体系统稳定性。</li>
</ol>

<span id="more"></span><!-- more -->

<h3 id="toc_1">二、微服务的特征</h3>

<ol>
<li>每个微服务仅对单个业务负责，且为该业务的容量负责；</li>
<li>每个微服务可以进行独立部署，即不需要依赖其它微服务及其相关资源，如数据库、内存缓存系统等；</li>
<li>轻量级的通信协议，例如REST、STOMP、AMQP等；</li>
<li>服务的可替代性，代表着每个微服务原则上都可以使用不同的语言、框架进行技术实现，且更换实现后的微服务对于整个业务系统不会造成影响；</li>
<li>每个微服务拥有单独的数据存储；</li>
<li>每个微服务由小团队维护，服务以业务来进行拆分后，每个微服务的维护工作将有人数不多的小团队进行维护；</li>
</ol>

<h3 id="toc_2">三、微服务带来的好处</h3>

<ol>
<li>独立的可扩展性，每个微服务都可以独立进行横向或纵向扩展，根据业务实际增长情况来进行快速扩展；</li>
<li>独立的可升级性，每个微服务都可以独立进行服务升级、更新，不用依赖于其它服务，结合持续集成工具可以进行持续发布，开发人员就可以独立快速完成服务升级发布流程；</li>
<li>易维护性，每个微服务的代码均只专注于完成该单个业务范畴的事情，因此微服务项目代码数量将减少至IDE可以快速加载的大小，这样可以提高了代码的可读性，进而可以提高研发人员的生产效率；</li>
<li>语言无关性，研发人员可以选用自己最为熟悉的语言和框架来完成他们的微服务项目（当然，一般根据每个公司的实际技术栈需要来了），这样在面对新技术或新框架的选用时，微服务能够更好地进行快速响应；</li>
<li>故障和资源的隔离性，在系统中出现不好的资源操作行为时，例如内存泄露、数据库连接未关闭等情况，将仅仅只会影响单个微服务；</li>
<li>优化跨团队沟通，如果要完全实践微服务架构设计风格，研发团队势必会按照新的原则来进行划分，由之前的按照技能、职能划分的方式变为按照业务（单个微服务）来进行划分，如此这般团队里将有各个方向技能的研发人员，沟通效率上来说要优于之前按照技能进行划分的组织架构；</li>
<li>原生基于“云”的系统架构设计，基于微服务架构设计风格，我们能构建出来原生对于“云”具备超高友好度的系统，与常用容器工具如Docker能够很方便地结合，构建持续发布系统与IaaS、PaaS平台对接，使其能够方便的部署于各类“云”上，如公用云、私有云以及混合云。</li>
</ol>

<h3 id="toc_3">四、避免微服务的陷阱</h3>

<ol>
<li>不要以微服务作为开始，在项目刚开始时，一般都还很小，不需要进行非常完整的业务拆分，如果采用“微服务”作为开始会有点杀鸡用牛刀的感觉，当然，你的项目非常之庞大的话，以“微服务”为始是个不错的选择；</li>
<li>不要自己进行基础设施的管理，微服务意味着一堆的数据库、消息系统、数据缓存系统等，会带来相应的运维管理成本（这里的前提是，没有良好的自动化运维平台和工具），建议多使用IaaS、PaaS平台，部署发布与其对接；</li>
<li>无DevOps、不微服务，如果研发团队不具备DevOps的理念并贯彻执行，仅想单独来实施微服务的话，在实施过程中会发现比之前的架构维护要困难些，主要原因是微服务需要持续集成、持续部署及监控等工具或系统的配合才能降低其带来的维护成本；</li>
<li>不要创建过多的微服务，微服务的业务颗粒度一定要根据实际业务系统的现状及日后规划来制定，切记不要制定过细的拆分颗粒度；</li>
<li>可能带来的延迟问题，由于服务拆分开来，部署到不同的平台或网络，可能会引起微服务间的调用延迟问题，服务间的调用延迟可能带来整体系统的响应缓慢问题；</li>
<li>微服务不是银弹。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rexxar：豆瓣对混合开发的思考]]></title>
    <link href="http://lambgao.com/2016-12-02-douban-rexxar.html"/>
    <updated>2016-12-29T01:13:18+08:00</updated>
    <id>http://lambgao.com/2016-12-02-douban-rexxar.html</id>
    <content type="html"><![CDATA[
<p>前段时间，豆瓣将自己的混合开发框架Rexxar开源了。豆瓣可以说是在国内对HTML5实践最早的一批公司，早在2013年的时候他们就应用了当时还显得超前的Web Component概念开发了CardKit移动UI框架。在移动开发上，豆瓣也采用了混合开发的模式，Rexxar就是他们实践和思考的结晶。我采访了Rexxar的主要开发者之一郭麟，看看他们对混合开发的思考。</p>

<p>豆瓣使用混合开发的原因，是因为他们需要同时提供iOS、Android、移动Web版本的页面，相对于同时开发三个版本，使用混合开发显然可以在代码重用、开发成本和效率方面有很大的优势，在权衡性能体验的前提下，使用混合开发是非常现实的选择。</p>

<h3 id="toc_0">Rexxar是什么</h3>

<p>Rexxar是一个针对移动端的混合开发框架。支持Android、iOS和移动Web。</p>

<p>Rexxar主要由三部分组成：</p>

<p>Rexxar-web：前端代码库。包括一套打包、调试、发布工具，以及公共前端组件，和对Rexxar Container实现的Widget的调用。</p>

<p>Rexxar-Router：路由表，将每个页面分配一个服务器端链接，以及一个本地URI，通过路由表来访问页面。</p>

<p>Rexxar-container：增强版WebView，封装了一些Native API支持，包括OAuth授权、图片缓存等。</p>

<p>Rexxar目前已经开源，并且分为3个项目，你可以只使用其中某个项目来开发对应平台的代码：</p>

<p><a href="https://github.com/douban/rexxar-web">https://github.com/douban/rexxar-web</a> <br/>
<a href="https://github.com/douban/rexxar-android">https://github.com/douban/rexxar-android</a> <br/>
<a href="https://github.com/douban/rexxar-ios">https://github.com/douban/rexxar-ios</a></p>

<span id="more"></span><!-- more -->

<h3 id="toc_1">混合开发的注意点</h3>

<p>对于混合开发，很多团队都有过实践，从大家分享的内容来看，重点无非以下几类：</p>

<ul>
<li><p>增强WebView：原生WebView基本是PC平台浏览器内核的移植，但对于移动场景并不完全适合，各种硬件API得不到HTML5原生支持。因此对于WebView的种种Hack、增强应运而生，甚至出现了基于增强WebView提供第三方服务的。</p></li>
<li><p>路由：应用内跳转由于加入了WebView而变得复杂起来，同时由于组件化、模块化带来的问题，路由也成为人们讨论的重点。</p></li>
<li><p>缓存：移动网络条件差，为了用户体验，必须要做资源缓存和预加载。</p></li>
<li><p>通信：即HTML5和Native之间的通信。利用系统提供的桥接API可以实现，不过在应用上还有着一些坑点和安全问题。</p></li>
</ul>

<p>这些问题大部分已经有了最佳实践，Rexxar就是其中一个解决方案。在混合开发中一般有两种方案：纯浏览器方案、前端模板渲染容器方案，Rexxar则处于两者之间。</p>

<p>Rexxar的设计者对于Rexxar使用场景有明确的定义：页面是重度展示，并轻度交互的。所以，除了比较简单的应用之外，如果对使用体验有追求，大概很难仅仅用Rexxar，或者其他某种混合开发完成。</p>

<p>对于扩展功能，Rexxar留出了清晰易用的接口。项目中也提供了几个扩展Rexxar功能的实例，文档也较为完整。郭麟他们在豆瓣App中其实也使用相同的接口做了一些扩展，只是由于这些扩展和豆瓣App的业务绑定较深，就没有放入Rexxar项目。</p>

<p>Rexxar在客户端的实现其实就是一个定制了更多功能的WebView。而且，Rexxar使用的是系统的WebView。所以，它对App的体积没有影响。但是，同时使用很多个WebView带来的内存问题，Rexxar同样也有，这是需要注意的。</p>

<p>Rexxar的Crash有两种：</p>

<ul>
<li><p>一种是JavaScript的错误，也就是应用逻辑的问题。这类错误他们在WebView中做了捕获，然后通过App的日志系统发回服务器。</p></li>
<li><p>一种是WebView的Crash，这种错误WebView自己无法捕获，现在是通过fabric，Umeng这种原生的Crash收集系统收集。</p></li>
</ul>

<p>从上线了Rexxar之后，JavaScript，WebView相关错误日志和Crash报告是有增长的。所占的比例和Rexxar的页面数量相关，一直在变化，但都未超过10%。但由于豆瓣App中主要还是原生页面占大多数。所以，Rexxar带来的Crash所占的比例并不大。</p>

<p>他们也正在研究，在移动环境下如何定位Rexxar页面的错误，如何调试，如何修正这些错误，并将其加入基础设施里面。</p>

<h3 id="toc_2">为什么不用PhonGap/Cordova</h3>

<p>在混合开发中早已有了很成熟的方案，就是PhoneGap和它的后继者Cordoba. 为什么豆瓣还要造自己的轮子呢？</p>

<p>郭麟说，如果Hybrid方案定义为前端和原生技术的混合使用，那他们认为PhoneGap/Cordova严格来说不算是Hybrid方案，因为它的目标是全面使用前端技术开发移动应用，而不是前端和原生技术混合使用。但是，包括Cordova，还可以加上React Native，以及Rexxar的目标是一致的：使用前端技术来开发移动应用，提高工程效率。</p>

<p>豆瓣实际上使用PhoneGap开发过一款移动App，并在AppStore上架了，这个应用叫豆瓣音乐人，因此，其实豆瓣对PhoneGap/Cordova已经有一定了解和使用经验。为何在开发豆瓣App时又造了一个叫Rexxar的“轮子”呢？这是因为，他们对PhoneGap/Cordova这个项目的理念并不完全赞同，Rexxar的出发点和PhoneGap/Cordova并不一样。</p>

<p>PhoneGap/Cordova这个项目极具野心。它希望完全使用前端技术完成移动开发。所以，可以看到它尽力让前端技术完成尽量多的开发工作，只在前端无法直接调用的原生系统功能方面提供了前端可用的接口。主流的PhoneGap/Cordova项目将业务逻辑都实现在一个WebView中，目标是，让开发者只使用前端技术就可以完成一个移动应用的所有开发工作。这种做法需要有一个前提：前端技术可以解决移动开发的所有需求。他们认为PhoneGap/Cordova这个理念在现阶段有些过于理想化了，或者说过于激进了。</p>

<p>Rexxar则相对实际，或者说保守一些。郭麟表示，他们仍然认为，<strong>现阶段，甚至在相当遥远的未来，移动开发中前端技术都不太可能完全代替原生技术</strong>。但同时也承认，移动开发中总是存在部分功能是适合使用前端技术完成的。在他们的认识中，前端技术和原生技术应该是共存的。移动开发中，前端技术不会完全代替原生技术；而有了前端技术的加入，移动开发的效率会提高。基于这种认识，豆瓣开发了Rexxar。</p>

<p>可以看到，<strong>Rexxar立足于在一个原生项目使用前端技术，而不是整个项目都使用前端技术实现</strong>。他们甚至提供一个页面部分使用Rexxar完成，部分使用原生技术实现的方案。豆瓣希望借助前端技术优秀的排版能力、开发速度、通用性，来弥补原生开发在这方面的不足。在微信作为主要内容分享渠道的今天，这样做还带来了一个额外的好处，Rexxar页面可以平滑的使用在微信中。</p>

<p>总结而言，如果Rexxar和PhoneGap/Cordova比较的话，大目标是一致的：使用前端技术开发移动应用。实现技术栈差不多：使用WebView，提供调用原生功能的接口。但是，出发点不一样。PhoneGap/Cordova致力于完全使用前端技术进行移动开发；Rexxar致力于在移动项目中部分使用前端技术。</p>

<h3 id="toc_3">移动开发者要学习前端技术</h3>

<p>目前，豆瓣移动团队大约有十多位客户端工程师，其中 iOS 和 Android 各一半。另有一位优秀的前端工程师专门支持豆瓣App中的混合开发，他负责Rexxar Web的开发，提供基础设施。同时如果有一些较复杂的业务要用Rexxar实现，他也会参与和指导业务开发。</p>

<p>使用Rexxar这类混合开发技术，使得团队开发的技术栈向前端技术偏斜了。所以，较理想的配置是团队中加入较优秀的前端工程师，由他来处理基础设施的开发，和疑难问题的解决。同时，整个团队需要理解混合开发所带来的优势，认可这个开发方式的转变，并且愿意学习和调整自己的技术栈。</p>

<p>在项目中，在合适的场景中，豆瓣会优先使用Rexxar。在团队中，他们鼓励非前端工程师学习和使用前端技术。为此，他们专门组织了关于前端技术内部培训，让有意愿的非前端工程师具有了可以使用前端技术进行日常开发的基本能力。在豆瓣App的日常开发中，大部分Rexxar页面都由客户端工程师完成，前端工程师会帮忙做Code Review和解决疑难问题。</p>

<h3 id="toc_4">Rexxar与React Native</h3>

<p>豆瓣在实际使用Rexxar的时候，使用React作为前端框架。对此郭麟解释道，Rexxar本身对前端框架的选择没有要求，只是他们选择了React来实现业务层，而当时React Native并未发布，经过对RN的了解后，他们并未否定使用RN的可能性。</p>

<p>在他们看来，React Native同样是一种使用前端技术开发移动应用的技术方案，这和他们开发Rexxar的目的是一致的。只是，Rexxar仍然在停留在浏览器引擎中，而Facebook激进地脱离了沉重的浏览器引擎，架设了他们自己的Web通向Native的桥梁，这是一个很大胆的方案。</p>

<p>在React Native发布后，他们马上就组织研究，并做了小范围的实践，也与同行做了交流。结论是，现阶段，React Native还稍显稚嫩。对于一些技术栈比较特别的团队，比如Web经验特别丰富，前端工程师特别优秀，但又缺乏客户端工程师的情况，React Native是一个快速切入移动应用市场的技术选择。但就豆瓣App的情况和React Native的现状而言，使用前端技术进行移动应用开发方面，他们还坚持留在WebView中，不会使用React Native。</p>

<p>当然，React Native一直在发展和进步。如果，有一天React Native和React可以在代码级别移植，他们也许会尝试从WebView迁移到React Native。毕竟WebView的性能仍然弱于原生。</p>

<h3 id="toc_5">总结与展望</h3>

<p>豆瓣App和研发团队都经历了从小到大的发展过程。Rexxar是这个发展过程中，解决工程效率的一个方案。在豆瓣移动开发中使用Rexxar，确实在一定程度上提高了他们的开发效率。以前一个页面需要 iOS 和 Android 两位工程师各开发一遍，现在只需要一位工程师写一次前端代码，甚至还可以应用到移动 Web 站上去。前端技术开发界面方面开发方面也有效率上的优势。热部署能力，使他们规避了发布移动应用的审核过程，也让bug修复过程更便利。</p>

<p>豆瓣将Rexxar这个项目开源，一方面，是因为提高移动开发的工程效率是一个普遍问题，而他们的实践结果也证明Rexxar确实帮助改善了工程效率。所以，他们认为Rexxar应该能给大家提供一些借鉴的方向。另一方面，是为了提高项目本身的质量，没有方案是完美的，Rexxar也还存在不少问题。开源这个项目，促使他们提高了整个项目的代码质量。同时，也更容易听到大家的意见和建议。</p>

<p>虽然Rexxar仍然存在一些问题和使用上的限制。但是在有限的使用中，豆瓣App团队仍然收获不少。在未来他们会持续推动Rexxar在豆瓣移动开发中的使用。郭麟表示，对于Rexxar未来的发展，他们主要关注两个方面：</p>

<ul>
<li><p>一方面是基础设施，比如，如何在产品中，更好地监控Rexxar页面出现的问题，如何调试和解决Rexxar页面出现的bug。如果希望在大型项目中使用Rexxar，这些基础设施是应该配备的；</p></li>
<li><p>另一方面是性能，Rexxar仍然跑在浏览器引擎中。浏览器引擎这个中间层提高了工程效率，但也因为性能问题局限了其使用范围。所以，他们会花一些精力提高Rexxar的运行效率。比如，Rexxar的iOS版一直在关注从UIWebView迁移到WKWebView的可能性。</p></li>
</ul>

<p>参考文章：</p>

<ul>
<li><a href="http://lincode.github.io/Hybrid-Rexxar">豆瓣混合开发实践</a></li>
<li><a href="Rexxar%20http://lincode.github.io/Rexxar-OpenSource">豆瓣的混合开发框架</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112821&amp;idx=1&amp;sn=2987ba2c9d68e3982e795d9eeb15f82b">豆瓣App的模块化实践</a> </li>
<li><a href="https://www.douban.com/note/347692465/">《CardKit &amp; DOMO UI - 移动时代技术与设计的十字路口》技术篇</a> </li>
<li><a href="http://www.infoq.com/cn/news/2013/10/douban-artist-PhoneGap-practice">豆瓣音乐人app的PhoneGap实践</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CLOSE_WAIT 问题分析]]></title>
    <link href="http://lambgao.com/2016-10-31-close-wait-problem.html"/>
    <updated>2016-12-28T00:25:48+08:00</updated>
    <id>http://lambgao.com/2016-10-31-close-wait-problem.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">问题场景</h3>

<p>服务器出现大量 TCP 连接状态为 CLOSE_WAIT，将系统资源耗尽，导致业务处理失败。</p>

<h3 id="toc_1">处理方式</h3>

<p>重启导致问题的进程，释放 TCP 连接后服务恢复正常。</p>

<p>调整服务器网络参数：</p>

<ul>
<li>net.ipv4.tcp_keepalive_time=600，tcp 连接空闲 10 分钟后发送探测包，默认是 7200 秒（两小时）</li>
<li>net.ipv4.tcp_keepalive_intvl=15，每次探测包间隔 15 秒，默认是 75 秒</li>
<li>net.ipv4.tcp_keepalive_probes=5，一共发送 5 次探测包，默认是 9 次</li>
</ul>

<p>让内核尽快检测出空闲连接并释放。</p>

<h3 id="toc_2">分析</h3>

<p>服务器环境是 Java、Tomcat。服务端在收到客户端 FIN 包后进入 CLOSE_WAIT，但服务端没有发送 FIN 包，具体原因没有查明。猜测的原因是</p>

<ul>
<li>服务端的业务处理阻塞，导致发送不了 FIN 包</li>
<li>网络问题导致依赖的基础库 bug</li>
</ul>

<p>附：TCP 连接状态图</p>

<p><img src="/resource/image/2016-10-31-close-wait-problem/8b538e707e964084a2161844efb023ea-tcp.jpg" alt="8b538e707e964084a2161844efb023ea-tcp.jpg"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 3：sizeof移进MemoryLayout]]></title>
    <link href="http://lambgao.com/2016-10-08-swift-sizeof-into-memorylayout.html"/>
    <updated>2016-12-29T00:42:41+08:00</updated>
    <id>http://lambgao.com/2016-10-08-swift-sizeof-into-memorylayout.html</id>
    <content type="html"><![CDATA[
<p>sizeof这个方法名直接取自C语言，但是实际上LLVM中并没有一个函数叫sizeof。而且sizeof的使用范围很窄，不像map，filter这种经常会全局用到。所以重新定义了一个结构体 MemoryLayout来实现原来sizeof的功能，使用上也有变化。</p>

<p>主要有两种方式，一种是直接通过泛型参数从静态变量获取：</p>

<pre><code>let stringSize = MemoryLayout&lt;String&gt;.size
</code></pre>

<p>也可以通过调用静态方法获取</p>

<pre><code>let stringValue = &quot;A&quot;
let varSize = MemoryLayout.size(ofValue: stringValue)
</code></pre>

<p>两者都会得到正确的结果。</p>

<p>除了sizeof, MemoryLayout还可以获取stride， alignment。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 8:在Active Compilation Conditions中自定义环境变量]]></title>
    <link href="http://lambgao.com/2016-09-21-xcode-eight-custom-environment-variables.html"/>
    <updated>2016-12-29T00:35:48+08:00</updated>
    <id>http://lambgao.com/2016-09-21-xcode-eight-custom-environment-variables.html</id>
    <content type="html"><![CDATA[
<p>在Xcode 7我们在 OTHER_SWIFT_FLAGS中配置环境变量。但是有一个不爽的地方就是需要在自定义的变量前增加“-D”后才能使用。</p>

<pre><code>#if MYFLAG
// 逻辑判断
#endif
</code></pre>

<p>现在在Xcode 8中新增了一个SWIFT_ACTIVE_COMPILATION_CONDITIONS选项，现在直接在里面添加就可以啦！在代码中的使用逻辑和之前一样。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[兼容iOS 10：配置获取隐私数据权限声明]]></title>
    <link href="http://lambgao.com/2016-09-12-ios-ten-declare-intended.html"/>
    <updated>2016-12-29T00:32:14+08:00</updated>
    <id>http://lambgao.com/2016-09-12-ios-ten-declare-intended.html</id>
    <content type="html"><![CDATA[
<p>iOS 10的一大变化是更强的隐私数据保护。在文档中是这么描述的：</p>

<p>You must statically declare your app’s intended use of protected data classes by including the appropriate purpose string keys in your Info.plist file.</p>

<p>简单的说访问用户数据都需要现在Info.plist中声明，否则会crash。<br/>
这些用户数据包括：</p>

<p>Contacts, Calendar, Reminders, Photos, Bluetooth Sharing, Microphone, Camera, Location, Health, HomeKit, Media Library, Motion, CallKit, Speech Recognition, SiriKit, TV Provider.</p>

<p>10之前只需要获取位置时配置，现在更严格了，比如需要调用相册访问权限，也需要在Info.plist中配置privacy。<br/>
好在这些key的名字在Xcode 8中已经有了自动补全。添加一个属性，输入Privacy后就会出现自动提示，后面填的string会在弹出用户允许时展示在描述里。描述一定要填写，如果描述空着提交AppStore时会拒绝。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的可选类型(Optional Type)]]></title>
    <link href="http://lambgao.com/2016-08-10-swift-optional-type.html"/>
    <updated>2016-12-29T00:47:34+08:00</updated>
    <id>http://lambgao.com/2016-08-10-swift-optional-type.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Optional Type总览</h3>

<p>什么是optional? Swift中声明的一个变量时, 默认情况下它是non-optional的, 即必须赋予这个变量一个非空的值. 如果给non-optional类型的变量赋值nil, 编译器就会报错。</p>

<pre><code>var string1: String = &quot;This is string1&quot; // OK
string1 = nil  // Nil cannot be assigned to type &#39;String&#39;
- Swift中, 当声明一个类的属性时, 属性默认也是non-optional的
swift
class MyClass {
    var name: String = &quot;Lv&quot;
    var age: String  // Class &#39;MyClass&#39; has no initializers
}
</code></pre>

<p>对于之前使用Objective-C的同学来说, 这样的错误可能会让你们有些惊讶, 因为在Objective-C中, 当把nil赋值给一个变量或者声明一个没有初始值的属性时, 编译器都不会报错.</p>

<pre><code>NSString *string1 = @&quot;This is string1&quot;;
string1 = nil;
class MyClass {
    NSString *name = @&quot;Lv&quot;
    NSString *age;
}
</code></pre>

<p>然而并不意味着在Swift中不能声明一个没有初始值的属性. Swift中引入了可选类型(optional type)来解决这一问题. 它的定义是通过在类型生命后加加一个<code>?</code>操作符完成的.</p>

<pre><code>class MyClass {
    var name: String?  // OK
    var age: String?  // OK
}
</code></pre>

<span id="more"></span><!-- more -->

<h3 id="toc_1">为什么引入可选类型?</h3>

<p>Swift是一门安全的编程语言. 正如苹果所言, 可选类型就是证明Swift是一门安全的编程语言的一个小例子. 如上面的例子所示, Swift的可选类型提供了在编译阶段就检查一些可能在运行时才会出现的常见错误的机制. 下面通过下面的例子更好的诠释一下可选类型的威力.</p>

<p>考虑下面一个Objective-C中的方法</p>

<pre><code>- (NSString *)findStockCode:(NSString *)company {
    if ([company isEqualToString:@&quot;Apple&quot;]) {
        return @&quot;AAPL&quot;;
    } else if ([company isEqualToString:@&quot;Google&quot;]) {
        return @&quot;GOOG&quot;;
    }
    return nil;
}
</code></pre>

<p>通过<code>findStockCode:</code>方法可以传入公司的名字,然后得到对应公司的股票代码. 为了方便演示, 这里只返回Apple和Google的代码, 对于其他的传入参数, 统统返回nil.<br/>
假设在同一个类中调用<code>findStockCode:</code>方法:</p>

<pre><code>NSString *stockCode = [self findStockCode:@&quot;Facebook&quot;]; // nil is returned
NSString *text = @&quot;Stock Code - &quot;;
NSString *message = [text stringByAppendingString:stockCode]; // runtime error
NSLog(@&quot;%@&quot;, message);
</code></pre>

<p>上面的代码是可以编译通过的, 但是因为传入了&quot;Facebook&quot;导致返回值是nil, 当代码开始运行后, 程序就会报错了.<br/>
当使用Swift中的可选类型时, 上面在运行时才会出现的错误在编译阶段就会报错. 如果使用Swift的代码重写上面的例子,代码如下:</p>

<pre><code>func findStockCode(company: String) -&gt; String? {
   if (company == &quot;Apple&quot;) {
      return &quot;AAPL&quot;
   } else if (company == &quot;Google&quot;) {
      return &quot;GOOG&quot;
   }
   return nil
}
var stockCode:String? = findStockCode(&quot;Facebook&quot;)
let text = &quot;Stock Code - &quot;
let message = text + stockCode  // compile-time error
print(message)
</code></pre>

<p>stockCode被定义成可选类型. 这就意味着它要么是一个String, 要么就是nil. 因为编译器在编译阶段就检测到了潜在的错误(可选类型的值没有被解包: value of optional type String? is not unwrapped)并且提示你去改正, 这段代码就不能够被执行.<br/>
从这个例子中可以看到, Swift的可选类型加强了对空值的检查, 并且在编译阶段就给开发者提供了可能的错误信息. 很明显, 可选类型的引入可以让代码的质量变得更好.</p>

<h3 id="toc_2">解包可选类型(Unwrapping Optionals)</h3>

<p>如何让上面的代码正常运行? 很明显, 这里需要判断stockCode是否为空. 代码如下:</p>

<pre><code>var stockCode:String? = findStockCode(&quot;Facebook&quot;)
let text = &quot;Stock Code - &quot;
if stockCode {
    let message = text + stockCode!
    print(message)
}
</code></pre>

<p>像在Objective-C中一样, 还是使用if来判断stockCode中是否有值. 一旦确定stockCode中肯定有值时, 将一个感叹号(!)加在可选类型变量名后面来解包这个可选类型的变量. 在Swift中, 这叫做硬解包. 即直接在可选类型后面加一个感叹号来表示它肯定有值.<br/>
上面的例子中, 我们只是自己知道stockCode肯定有值, 所以才直接硬解包了stockCode变量. 但是万一有时候我们的感觉是错的, 那程序在运行时可能会出现严重的错误. 所以Swift中是推荐先检查可选类型是否有值, 然后再进行解包的!</p>

<pre><code>var stockCode:String? = findStockCode(&quot;Facebook&quot;)
let text = &quot;Stock Code - &quot;
let message = text + stockCode!  // runtime error
</code></pre>

<p>以上代码在编译阶段不会报错.因为使用了硬解包, 编译器认为可选类型是有值的, 所以编译是通过的. 当代码运行起来时, 知名的错误将会出现: <code>fatal error: Can’t unwrap Optional.None</code></p>

<h3 id="toc_3">可选绑定(Optional Binding)</h3>

<p>与硬解包不同, 可选绑定(Optional Binding)是一种更简单更推荐的方法来解包一个可选类型. 使用可选绑定来检查可选类型的变量有值还是没值. 如果有值, 解包它并且将值传递给一个常量或者变量.<br/>
再多的言语描述也不如直接上代码来的实际! 将上面的代码改成可选绑定的代码如下:</p>

<pre><code>var stockCode:String? = findStockCode(&quot;Facebook&quot;)
let text = &quot;Stock Code - &quot;
if let tempStockCode = stockCode {
    let message = text + tempStockCode
    print(message)
}
</code></pre>

<p>if let<code>或者</code>if var`是可选绑定的两个关键字. 使用自然语言来描述上面这段代码的话, 意思就是如果stockCode有值,解包它,并且将它的值赋值给tempStockCode, 然后执行下面的条件语句; 如果stockCode为空, 直接跳过条件语句块.</p>

<p>上面的代码可以简化如下:</p>

<pre><code>let text = &quot;Stock Code - &quot;
if var stockCode = findStockCode(&quot;Apple&quot;) {
    let message = text + stockCode
    print(message)
}
</code></pre>

<p>这里stockCode不再是可选类型, 所以不需要使用<code>!</code>来解包. 如果findStockCode:方法返回值是nil, 那么程序并不会执行条件语句块中的代码.</p>

<h3 id="toc_4">可选链式调用(Optional Chaining)</h3>

<p>在解释optional chaining之前, 先来修改一下上面的例子. 这里重新创建一个名为Stock的类, 包含两个可选类型的属性code和price. <code>findStockCode:</code>方法直接返回Stock类的对象, 而不再是String.</p>

<pre><code>class Stock {
    var code: String?
    var price: Double?
}
func findStockCode(company: String) -&gt; Stock? {
    if (company == &quot;Apple&quot;) {
        let aapl: Stock = Stock()
        aapl.code = &quot;AAPL&quot;
        aapl.price = 90.32
        return aapl
    } else if (company == &quot;Google&quot;) {
        let goog: Stock = Stock()
        goog.code = &quot;GOOG&quot;
        goog.price = 556.36
        return goog
    }
    return nil
}
</code></pre>

<p>改写了创建类的代码, 相应的调用代码也需要修改. 这里调用findStockCode:方法得到一个Stock对象, 然后计算买100股股票所需的价格.</p>

<pre><code>if let stock = findStockCode(&quot;Apple&quot;) {
    if let sharePrice = stock.price {
        let totalCost = sharePrice * 100
        print(totalCost)
    }
}
</code></pre>

<p>这里因为findStockCode:方法的返回值类型是可选类型, 所以使用if let进行可选绑定, 又因为price属性也是可选类型, 所以再使用一个if let来判断是否有值.</p>

<p>上面的代码是一段正确的代码. 但是可以通过使用可选链式调用(Optional Chaining)来简化上面的代码, 毕竟上面是使用了两个if let的. 可选链式调用使我们能够通过<code>?.</code>链接多个可选类型. 示例代码如下:</p>

<pre><code>if let sharePrice = findStockCode(&quot;Apple&quot;)?.price {
    let totalCost = sharePrice * 100
    print(totalCost)
}
</code></pre>

<p>可选链式调用提供了另外一种方法获得price的值. 现在的代码看起来更加简洁. 这里只是对可选链式调用(Optional Chaining)做了简要介绍, 详细的介绍请阅读<a href="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/OptionalChaining.html#//apple_ref/doc/uid/TP40014097-CH21-XID_312">苹果官方文档</a>。</p>

<h3 id="toc_5">Swift和Objective-C的互通性</h3>

<p>Swift的可选类型是非常强大的. 尽管可能需要花一段时间熟悉它的语法.</p>

<p>Swift的设计是本着可以和Objective-C的API交互的原则. 当你想和UIKit或者其他框架的API交互时, 你肯定得需要可选类型. 下面是一些在实现table view时遇见的可选类型.</p>

<pre><code>func numberOfSectionsInTableView(tableView: UITableView?) -&gt; Int {
   // Return the number of sections.
   return 1
}
func tableView(tableView: UITableView?, numberOfRowsInSection section: Int) -&gt; Int {
   // Return the number of rows in the section.
   return recipes.count
}
func tableView(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!) -&gt; UITableViewCell! {
   let cell = tableView.dequeueReusableCellWithIdentifier(&quot;Cell&quot;, forIndexPath: indexPath) as UITableViewCell
   cell.textLabel.text = recipes[indexPath.row]
   return cell
}
</code></pre>

<h3 id="toc_6">总结</h3>

<p>理解可选类型的工作原理是非常重要的，在Swift中可选类型允许开发者能够在代码的编译阶段就发现一些潜在的问题, 从而确保在代码真正运行时能更安全. 一旦等你习惯了它的语法, 你必将会爱上可选类型这个新引入的概念。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode真机调试报错：The Application Could Not Be Verified.]]></title>
    <link href="http://lambgao.com/2016-07-26-xcode-could-not-be-verified.html"/>
    <updated>2016-12-29T01:47:59+08:00</updated>
    <id>http://lambgao.com/2016-07-26-xcode-could-not-be-verified.html</id>
    <content type="html"><![CDATA[
<p>今天真机调试的时候遇到这个错误：</p>

<p>The application could not be verified.</p>

<p>这还是第一次遇到，应该是手机上的app的证书跟现在的证书不一致导致。</p>

<p>解决方法有两个</p>

<h3 id="toc_0">xcode中切换证书：</h3>

<p>你手机上的app用的是哪个证书，你现在还用那个证书运行。</p>

<h3 id="toc_1">删除手机上的app</h3>

<p>直接删除手机上的app，再运行就可以啦！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中被忽略的@noescape]]></title>
    <link href="http://lambgao.com/2016-06-04-swift-noescape.html"/>
    <updated>2016-12-29T00:03:16+08:00</updated>
    <id>http://lambgao.com/2016-06-04-swift-noescape.html</id>
    <content type="html"><![CDATA[
<p>这里需要先介绍一下escape的概念。当一个闭包当做一个参数传进函数里，这个闭包是在这个函数执行完后执行的，这个时候我们就说这个闭包从函数逃出来了（escape）。这种场景很常见，比如我们进行一个异步的请求，请求时会传入一个handler，比如当请求成功后执行达到回调的目的。</p>

<p>众所周知swift的内存管理是引用计数。闭包里用到的数据都需要捕捉到闭包里，保证闭包执行时这些数据不会被释放还在内存里。Xcode为了让我们意识到闭包里用到的对象其实已经被retain了，就要求我们访问当前属性时显示声明self。<br/>
这个时候如果新手就很容易犯引用循环的错误。闭包retain了self，self如果又持有retain了闭包。最后就谁都释放不了，内存就泄露了。</p>

<p>这是swift中默认闭包的使用场景。<br/>
但是这里是有另外一种可能，假设有一个闭包是传入用于sort用的，或者比如作为map参数的闭包。当这行代码执行完成时，这个闭包也就使用完了，之后不会再被执行。这个情况下，闭包就不必再持有里面用到的对象。<br/>
这就是非escape闭包。</p>

<p>swift里针对非escape用@noescape表示。<br/>
比如map函数就使用了：</p>

<pre><code>func map&lt;T&gt;(@noescape transform: (Self.Generator.Element) throws -&gt; T) rethrows -&gt; [T]
</code></pre>

<p>这样标记之后能看到的好处就是这个闭包里如果再使用self的属性不需要加self.了。对于编译器而言，在知道是noescape闭包后可以进行一些内存的优化。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift 3：inout 关键字位置的变化]]></title>
    <link href="http://lambgao.com/2016-05-14-swift-inout.html"/>
    <updated>2016-12-29T01:19:18+08:00</updated>
    <id>http://lambgao.com/2016-05-14-swift-inout.html</id>
    <content type="html"><![CDATA[
<p>inout 关键字可以用于将参数修饰为可修改，并且将修改会回传。这次 Swift 3 中对这个关键字也做了一些修改，咱们一起来kan&#39;k吧。</p>

<p>在 Swift 中，如果我们希望一个函数可以修改它的参数变量的值，我们可以使用 inout 关键词。这个相当于编程语言概念中所谓的传址调用。 具体代码中就是这样的例子：</p>

<pre><code>func foo(inout x:  Int) {

    x = 2

}

var x = 5
foo(&amp;x)
print(x) // 2
</code></pre>

<p>在这个例子中， foo 函数的参数 x, 使用了 inout 修饰，这样我们在后面的调用中，将变量 x 传递给这个函数后，这个变量中的值也会被这个函数内部改变。 这个就是 inout 的基本作用了。</p>

<p>在 Swift 3.0 中，有一个 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md">SE-0031</a> 的提案，就是改变 inout 这个关键词的位置的。</p>

<p>当前的语法中，inout 的位置是在参数标签的位置上，也就是这个例子中的：</p>

<pre><code>func foo(inout x:  Int)
</code></pre>

<p>inout 关键字位于参数标签 x 的前面。 而 Swift 3.0 以后，这个关键词的位置就会在参数类型前面了：</p>

<pre><code>func foo(x: inout Int)
</code></pre>

<p>这个提案中也解释了这样做的好处。首先这样做之后参数标签就不和修饰关键字发生混淆，比如避免了这样的情况：</p>

<pre><code>func foo(inOut x:  Int)
func foo(inout x:  Int)
</code></pre>

<p>第一行的 inout 的大小写错误，所以它不是关键字。但这时编译器不会报错，因为 inOut 这时候作为了外部参数标签(Swift 的参数标签分为外部标签和内部标签，这个例子中外部标签是 inOut，所以我们在外部调用这个函数的时候就是这个语法 foo(inOut:),而函数内部还是用内部标签 x 来引用这个参数)。</p>

<p>除了避免混淆之外，inout 的位置移动后还有一点需要大家注意的。按照提案中的意思，就是以前版本的遗留代码中的 inout，很可能会变成参数标签，也就是这样：</p>

<pre><code>func foo(inout x:  Int)
</code></pre>

<p>比如之前我们的 foo 函数这样定义，但 Swift 3.0 之后， 这里的 inout 并不是关键字，而变成这个参数的外部标签了。所以这一点还是很值得注意的。</p>

<p>最后提案中还说了一句，这样修改后能够更好的和 Rust 语言的模式相匹配。并且说在后续的版本中会更多的引入到 Swift 语言中。</p>

<p>总体来说呢，这个改动不算大，但多多少少会对我们已有的代码造成一些影响。 inout 这个关键字大家应该多少都会用到过。所以在 Swift 3.0 更新后，也需要注意下这个问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[敏感数据处理]]></title>
    <link href="http://lambgao.com/2016-05-11-sensitive-data-processing.html"/>
    <updated>2016-12-28T00:19:41+08:00</updated>
    <id>http://lambgao.com/2016-05-11-sensitive-data-processing.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">背景</h3>

<p>大多数应用或多或少都会涉及到敏感数据处理，比如用户的手机号、身份证号，甚至银行卡账号。作为应用的开发者，如何 安全地 维护这些敏感数据呢？</p>

<p>这里讨论的安全不是指服务器如何保护，而是在数据库层面做敏感数据的分离：</p>

<ul>
<li>业务库中不保存敏感数据，只保存混淆过的数据，比如电话字段保存的是 133****9961，在数据层面就进行脱敏</li>
<li>敏感数据统一保存在另一个库中，有应用调用一个服务来建立原值和混淆值的映射关系</li>
<li>业务库中因为保存的是脱敏过的数据，通过只读复制镜像可以很方便地提供给其他服务使用，比如 OLAP</li>
<li>除了技术开发上方便，运维上也方便了很多，降低了敏感数据被暴露到外部的可能性</li>
</ul>

<h3 id="toc_1">技术设计</h3>

<p>提供服务接口给应用存取敏感数据，本质上是一个 KV 存取服务。</p>

<p><img src="/resource/image/2016-05-11-sensitive-data-processing/4910a7b5389945cc870dcc8f9cbfaf88.png" alt="4910a7b5389945cc870dcc8f9cbfaf88"/></p>

<p>一些细节：</p>

<ul>
<li>表 protyle 的 domain 字段用于标识该记录的作用域，在一个作用域上相同的值要保证唯一</li>
<li>表 protyle 的 hash 字段值是 SHA-512(domain/value) 的结果，用于唯一性校验</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[移动端数据库新王者：realm]]></title>
    <link href="http://lambgao.com/2016-05-11-realm.html"/>
    <updated>2016-12-29T00:18:47+08:00</updated>
    <id>http://lambgao.com/2016-05-11-realm.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">介绍</h3>

<p><a href="https://realm.io/cn/">realm</a>是一个跨平台移动数据库引擎，支持iOS、OS X（Objective‑C和Swift）以及Android。<br/>
2014年7月发布。由YCombinator孵化的创业团队历时几年打造，是第一个专门针对移动平台设计的数据库。目标是取代SQLite。<br/>
为了彻底解决性能问题，核心数据引擎用C++打造，并不是建立在SQLite之上的ORM。如果对数据引擎实现想深入了解可以查看：Realm 核心数据库引擎探秘。因此得到的收益就是比普通的ORM要快很多，甚至比单独无封装的SQLite还要快。<br/>
因为是ORM，本身在设计时也针对移动设备（iOS、Android），所以非常简单易用，学习成本很低。</p>

<p>碾压级性能<br/>
数据引自：introducing-realm<br/>
每秒能在20万条数据中进行查询后count的次数。realm每秒可以进行30.9次查询后count。</p>

<p>在20万条中进行一次遍历查询，数据和前面的count相似：realm一秒可以遍历20万条数据31次，而coredata只能进行两次查询。</p>

<p>一次事务每秒插入数据的对比，realm每秒可以插入9.4万条记录，在这个比较里纯SQLite的性能最好，每秒可以插入17.8万条记录。然而封装了SQLite的FMDB的成绩大概是realm的一半。</p>

<span id="more"></span><!-- more -->

<h3 id="toc_1">简单易用</h3>

<p>实例代码语言是Objective‑C。<br/>
Realm对象和其他对象没有太大区别，只是需要继承RLMObject</p>

<pre><code>@interface Dog : RLMObject
@property NSString *name;
@property NSInteger age;
@end

Dog *mydog = [[Dog alloc] init];
</code></pre>

<p>存储起来也非常简单，获取数据库实例，在一个事务中进行写入。</p>

<pre><code>RLMRealm *realm = [RLMRealm defaultRealm];

[realm transactionWithBlock:^{
    [realm addObject:mydog];
}];
</code></pre>

<p>方便的查询，可以在一个查询结果中再进行查询。查询的条件有着丰富的支持。</p>

<pre><code>RLMResults *r = [Dog objectsWhere:@&quot;age &gt; 8&quot;];

// Queries are chainable
r = [r objectsWhere:@&quot;name contains &#39;Rex&#39; AND  name BEGINSWITH &#39;大&#39;&quot;];
</code></pre>

<h3 id="toc_2">zero-copy和懒加载</h3>

<p>在通常的数据库中，数据大多数时间都静静地呆在硬盘当中。当你访问 NSManagedObject 对象中的某个属性的时候，Core Data 会将这个请求转换为一组 SQL 语句，如果还未连接数据库的话则创建一个数据库连接，然后将这个 SQL 语句发送给硬盘，执行检索，从匹配检索的结果中读取所有的数据，然后将它们放到内存当中（也就是内存分配）。然而，这时候你需要对其格式进行反序列化(deserialize)，因为硬盘上存储的格式不能直接在内存中使用，这意味着你需要调整位，以便 CPU 能够对其进行处理。<br/>
然而Realm跳过了整个拷贝数据到内存的过程，称之为zero-copy。做到这点是因为文件始终是内存映射的，无论文件是或否在内存当中，你都能够访问文件的任何内容。关于核心文件格式的重要一点就是，确保硬盘上的文件格式都是内存可读的，这样就无需执行任何反序列化操作了。<br/>
这样就带来了一个问题，难道数据全加载到内存里了？所以这里懒加载应运而生，比如在查询到一组数据后，只有当你真正访问对象的时候才真正加载进来。</p>

<h3 id="toc_3">VS SQLite</h3>

<p>SQLite第一个版本发布于2000年，至今已16年。以当今的角度来看，它的编程抽象程度非常低。业务上我们其实只想把这些对象存进去，可以查询出来。<br/>
即便已经是封装过的<a href="https://github.com/ccgus/fmdb">FMDB</a>，要写这样的代码心里也依旧难受:</p>

<pre><code>FMDatabase *db = [FMDatabase databaseWithPath:@&quot;/tmp/tmp.db&quot;];
if (![db open]) {
    [db release];
    return;
}

NSString *sql = @&quot;create table bulktest1 (id integer primary key autoincrement, x text);&quot;
                 &quot;create table bulktest2 (id integer primary key autoincrement, y text);&quot;
                 &quot;create table bulktest3 (id integer primary key autoincrement, z text);&quot;
                 &quot;insert into bulktest1 (x) values (&#39;XXX&#39;);&quot;
                 &quot;insert into bulktest2 (y) values (&#39;YYY&#39;);&quot;
                 &quot;insert into bulktest3 (z) values (&#39;ZZZ&#39;);&quot;;

success = [db executeStatements:sql];

sql = @&quot;select count(*) as count from bulktest1;&quot;
       &quot;select count(*) as count from bulktest2;&quot;
       &quot;select count(*) as count from bulktest3;&quot;;

success = [self.db executeStatements:sql withResultBlock:^int(NSDictionary *dictionary) {
    NSInteger count = [dictionary[@&quot;count&quot;] integerValue];
    XCTAssertEqual(count, 1, @&quot;expected one record for dictionary %@&quot;, dictionary);
    return 0;
}];

[db close];
</code></pre>

<p>VS CoreData</p>

<p>详细的比较推荐看这篇：<a href="http://iiiyu.com/2016/01/19/CoreData-VS-Realm/">CoreData VS Realm</a>。<br/>
下面给出一个查询的比较：</p>

<pre><code>// Core Data
let fetchRequest = NSFetchRequest(entityName: &quot;Specimen&quot;)
let predicate = NSPredicate(format: &quot;name BEGINSWITH [c]%@&quot;, searchString)
fetchRequest.predicate = predicate
let sortDescriptor = NSSortDescriptor(key: &quot;name&quot;, ascending: true)
fetchRequest.sortDescriptors = [sortDescriptor]
let error = NSError()
let results = managedObjectContext?.executeFetchRequest(fetchRequest, error:&amp;error)
</code></pre>

<p>Realm则简单的多：</p>

<pre><code>// Realm
let predicate = NSPredicate(format: &quot;name BEGINSWITH [c]%@&quot;, searchString);
let specimens = Specimen.objectsWithPredicate(predicate).arraySortedByProperty(&quot;name&quot;, ascending: true)
</code></pre>

<h3 id="toc_4">总结一下Realm对CoreData</h3>

<h4 id="toc_5">优势：</h4>

<ul>
<li>不需要架构Context那种烦人的东西，CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。</li>
<li>支持 NSPredicate，从 CoreData 转过来并没有太多的不适应。</li>
<li>CoreData多个持久化文件很麻烦，Realm轻松支持这个功能</li>
</ul>

<h4 id="toc_6">劣势：</h4>

<p>是会增加应用大概1MB的体积。CoreData原生支持，不会增加App体积。</p>

<h3 id="toc_7">需要知道的一些问题</h3>

<p>其实我自己觉得这些是可以接受的问题。技术很多时候就是权衡，为了达到一些目的，总是要牺牲掉一些东西。</p>

<h4 id="toc_8">所有的存储对象需要继承RealmObject</h4>

<p>比如我现在的项目的数据从网络请求回来都会继承自己写的一个方便解析的基类，在这里就需要做出一些适应。<br/>
但是该问题在swift中是不存在的。因为swift是天生的面向协议编程范式。</p>

<h4 id="toc_9">不能自定义getter、setter</h4>

<p>realm会自动生成getter、setter，如果自定义getter、setter存储就会有影响。如果要规避这个问题，可以通过设置这个对象的忽略属性。<br/>
比如有个属性id，需要自定义setter。可以在对象属性里把id设置为忽略属性，这样realm就不会为它自动生成getter、setter，但是也不会把id存入数据库。接着自定义一个用于存储的属性比如realm_id。在id的setter中可以把把值也赋给realm_id。<br/>
这个问题在swift中也是不存在的，因为swfit中使用的是willset、didset这种通知机制。</p>

<h4 id="toc_10">查询的结果不是数组</h4>

<p>为了能够支持查询结果的链式查询，realm自定义了一个集合类型。可以枚举，但是不是熟悉的数组了。又因为realm的懒加载机制，所以不建议在数据层把这个枚举转成数组类型。这样的缺点就是上层知道了数据的存储逻辑。严格的说这里不应该让上层知道。但是这样设计也许是为了方便上层进行再次检索，realm有着优越的查询性能。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题]]></title>
    <link href="http://lambgao.com/2016-04-22-load-big-image.html"/>
    <updated>2016-12-29T01:56:38+08:00</updated>
    <id>http://lambgao.com/2016-04-22-load-big-image.html</id>
    <content type="html"><![CDATA[
<p><a href="https://github.com/mwaterfall/MWPhotoBrowser.git">MWPhotoBrowser</a>是一个非常不错的照片浏览器，在github的star接近3000个。</p>

<p>MWPhotoBrowser来加载小图1M以下的都应该不会有内存警告的问题。如果遇到大图，3M、4M、5M的大图，很有可能导致内存警告。最近我就遇到这个问题，很是头疼。来回滑动查看照片内存飙到100M以上。</p>

<p>网上查了很多资料，都没有解决问题。</p>

<p>我们来看一下MWPhotoBrowser，其实MWPhotoBrowser用的是<a href="https://github.com/rs/SDWebImage.git">SDWebImage</a>来下载图片的。</p>

<p>在github看到SDWebImage的介绍，后面说到：</p>

<p>Future Enhancements<br/>
LRU memory cache cleanup instead of reset on memory warning</p>

<p>看到这个真是欲哭无泪啊。</p>

<span id="more"></span><!-- more -->

<p>再去看看SDWebImage的，有个人提问了：</p>

<p>How to disable &quot;memory cache&quot;?  I don&#39;t want memory cache,  it used a lot of memory and got memory waring easily,  disk is enough for me...</p>

<p>有人回答：</p>

<p>There is no way to disable the memory cache. But the cache is designed to flush itself when you get a memory warning, so you shouldn&#39;t need to worry it.</p>

<p>说的是SDWebImage遇到内存警告会自动释放内存，但是这还是解决不了问题，加载大图的时候，内存会突然蹦到100多M，在4s及以下的手机上跑，再就挂了。</p>

<p>还是没有解决内存警告的问题。怎么办呢？</p>

<p>我是这么解决的：</p>

<p>SDWebImage有一个SDWebImageDownloaderOperation类来执行下载操作的。里面有个下载完成的方法：</p>

<pre><code>- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection {
   SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock;
   @synchronized(self) {
       CFRunLoopStop(CFRunLoopGetCurrent());
       self.thread = nil;
       self.connection = nil;
       [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:nil];
   }

   if (![[NSURLCache sharedURLCache] cachedResponseForRequest:_request]) {
       responseFromCached = NO;
   }

   if (completionBlock)
   {
       if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) {
           completionBlock(nil, nil, nil, YES);
       }
       else {
           UIImage *image = [UIImage sd_imageWithData:self.imageData];
           NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];
           image = [self scaledImageForKey:key image:image];

           // Do not force decoding animated GIFs
           if (!image.images) {
               image = [UIImage decodedImageWithImage:image];
           }
           if (CGSizeEqualToSize(image.size, CGSizeZero)) {
               completionBlock(nil, nil, [NSError errorWithDomain:@&quot;SDWebImageErrorDomain&quot; code:0 userInfo:@{NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;}], YES);
           }
           else {
               completionBlock(image, self.imageData, nil, YES);
           }
       }
   }
   self.completionBlock = nil;
   [self done];
}
</code></pre>

<p>其中，UIImage *image = [UIImage sd_imageWithData:self.imageData];就是将data转换成image。</p>

<p>再看看sd_imageWithData:这个方法：</p>

<pre><code>+ (UIImage *)sd_imageWithData:(NSData *)data {
   UIImage *image;
   NSString *imageContentType = [NSData sd_contentTypeForImageData:data];
   if ([imageContentType isEqualToString:@&quot;image/gif&quot;]) {
       image = [UIImage sd_animatedGIFWithData:data];
   }
#ifdef SD_WEBP
   else if ([imageContentType isEqualToString:@&quot;image/webp&quot;])
   {
       image = [UIImage sd_imageWithWebPData:data];
   }
#endif
   else {
       image = [[UIImage alloc] initWithData:data];
       UIImageOrientation orientation = [self sd_imageOrientationFromImageData:data];
       if (orientation != UIImageOrientationUp) {
           image = [UIImage imageWithCGImage:image.CGImage
                                       scale:image.scale
                                 orientation:orientation];
       }
   }


   return image;
}
</code></pre>

<p>这个方法在UIImage+MultiFormat里面，是UIImage的一个类别处理。这句话很重要image = [[UIImage alloc] initWithData:data]; SDWebImage把下载下来的data直接转成image，然后没做等比缩放直接存起来使用。所以，我们只需要在这边做处理即可：</p>

<p>UIImage+MultiFormat添加一个方法：</p>

<pre><code>+(UIImage *)compressImageWith:(UIImage *)image
{
   float imageWidth = image.size.width;
   float imageHeight = image.size.height;
   float width = 640;
   float height = image.size.height/(image.size.width/width);

   float widthScale = imageWidth /width;
   float heightScale = imageHeight /height;

   // 创建一个bitmap的context
   // 并把它设置成为当前正在使用的context
   UIGraphicsBeginImageContext(CGSizeMake(width, height));

   if (widthScale &gt; heightScale) {
       [image drawInRect:CGRectMake(0, 0, imageWidth /heightScale , height)];
   }
   else {
       [image drawInRect:CGRectMake(0, 0, width , imageHeight /widthScale)];
   }

   // 从当前context中创建一个改变大小后的图片
   UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();
   // 使当前的context出堆栈
   UIGraphicsEndImageContext();

   return newImage;

}
</code></pre>

<p>然后在：image = [[UIImage alloc] initWithData:data];下面调用以下：</p>

<pre><code>if (data.length/1024 &gt; 1024) {
    image = [self compressImageWith:image];
}
</code></pre>

<p>当data大于1M的时候做压缩处理。革命尚未成功，还需要一步处理。在SDWebImageDownloaderOperation的connectionDidFinishLoading方法里面的：</p>

<pre><code>  UIImage *image = [UIImage sd_imageWithData:self.imageData];

  //将等比压缩过的image在赋在转成data赋给self.imageData
  NSData *data = UIImageJPEGRepresentation(image, 1);
  self.imageData =  [NSMutableData dataWithData:data];
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[gitconfig配置别名alias]]></title>
    <link href="http://lambgao.com/2016-03-29-gitconfig-alias.html"/>
    <updated>2016-12-29T01:50:52+08:00</updated>
    <id>http://lambgao.com/2016-03-29-gitconfig-alias.html</id>
    <content type="html"><![CDATA[
<p>git有一些命令如：git pull 、 git push等等，这些命令可以设置alias，也就是缩写。如：git pull 是 git pl， git push 是 git ps。可以根据个人习惯进行修改。</p>

<p>修改别名alias步骤如下：</p>

<p>1,进入根目录</p>

<p><code>$ cd</code></p>

<p>2,查看根目录下面的文件</p>

<p><code>$ ls -la</code></p>

<p>查看一下有没有.gitconfig文件。</p>

<p>3，编辑.gitconfig</p>

<p><code>$ vi .gitconfig</code></p>

<p>添加如下：</p>

<pre><code>[alias]
co = checkout
ci = commit
st = status
pl = pull
ps = push
dt = difftool
l = log --stat
cp = cherry-pick
ca = commit -a
b = branch
</code></pre>

<p>具体可以根据个人习惯进行添加修改。</p>

]]></content>
  </entry>
  
</feed>
