
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2016-02-24-secure-salted-password-hashing.html">你保存用户密码的姿势正确吗？</a></h1>
			<p class="meta"><time datetime="2016-02-24T00:15:22+08:00" 
			pubdate data-updated="true">2016/2/24</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">摘要</h3>

<p>这几年陆陆续续有很多大站被脱裤，最终导致了很多用户的密码明文泄露。本文不探讨脱裤技术，主要研究的是如何正确（尽量安全）地保存用户密码。</p>

<h3 id="toc_1">哈希</h3>

<p>“把明文加密后再保存数据库”应该是大家的共识。这个过程应该是不可逆的（不能通过加密后的串再得到原文），所以对于这个“加密”过程更贴切的叫法应该是 - 哈希：</p>

<p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的。就是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。<br/>
这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。<br/>
简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</p>

<p>我们常用的 Hash 算法主要就是 MD5 和 SHA，并且很多时候我们就是使用其中一种来加密用户密码的。<br/>
以上两类哈希算法主要是用于校验文件/数字签名，但并不适合用来保护用户密码，虽然对于我们来说_感觉上_似乎起到了一定安全防护的效果，但其实效果很差，特别是 MD5，秒秒钟就可以找到碰撞值。</p>

<h3 id="toc_2">加盐</h3>

<p>上面我们提到过，将用户明文直接哈希后保存并不是正确的姿势，那加盐后呢？</p>

<p>我们先看下加盐解决的问题：如果两个用户密码一样，那么哈希后的值也是一样，攻击者通过查表法很容易就能破解原文并且一石多鸟。因为攻击者不知道用户的颜值和哈希算法，所以不大可能破解。</p>

<p>加盐的确是正确的思路，前提是：</p>

<ul>
<li>盐长度不能太短，并且必须是随机生成的</li>
<li>用户更新密码的同时也需要更新盐值</li>
</ul>

<p>并且加盐后使用的算法非常非常重要，而恰恰是这一点大家都没怎么弄对。</p>

<h3 id="toc_3">加盐哈希</h3>

<p>我们直接说结论吧：</p>

<ul>
<li>不要使用自己设计的算法（比如 sha1(sha1(password+salt))、sha1(md5(salt) + md5(password)) 等类似的）</li>
<li>要使用 <a href="%5Bhttps://en.wikipedia.org/wiki/Crypt_(Unix)#Library_Function_crypt.283.29%5D(https://en.wikipedia.org/wiki/Crypt_(Unix)#Library_Function_crypt.283.29)">crypt</a> 函数并且使用安全算法的参数（\(2y\), \(5\), \(6\)）。*nix 系统正是使用 crypt 来保护用户口令的，我们应该使用这样久经考验的姿势
使用流程</li>
</ul>

<p>以 golang 代码举例：</p>

<pre><code>package main

import (
    &quot;fmt&quot;

    &quot;github.com/kless/osutil/user/crypt/sha512_crypt&quot;
)

func main() {
    // 1. 生成密码安全处理后 hash 串
    c := sha512_crypt.New()
    hash, _ := c.Generate([]byte(&quot;secret&quot;), nil) // 第二个参数是 salt，设置为 nil 表示自动生成 salt

    fmt.Println(hash)

    // 2. 将该 hash 存库
    // ....

    // 3. 用户登录验证
    userInput := &quot;secret&quot;
    inputHash, _ := c.Generate([]byte(userInput), []byte(hash)) // 第一个参数是用户输入的密码，第二个参数是数据库中取出的 hash 串
    if inputHash == hash {
       fmt.Println(&quot;登录成功&quot;)
    } else {
       fmt.Println(&quot;登录失败&quot;)
    }
}
</code></pre>

<p>输出形如：</p>

<pre><code>$6$P0pVrLOL89I7Y4.Y$IlUd2ABQnUcSecMr2nMgB8lay58RXrQGODwVOQHtfP7IYr.mpGE7dn5.nmxxb9RWkM8o/rNNJCxs3mLKsB5Xl.
登录成功
</code></pre>

<p>要理解第 3 步中的验证原理，需要先知道 salt 的格式。在上面的例子中，我们没有指定 salt，而是使用自动生成的，最终生成的 hash 串中也是带有这个 salt 值的，也就是 \(6\)P0pVrLOL89I7Y4.Y$ 这个部分。</p>

<p>我们指定一下 salt 再调用函数就清晰一些了：</p>

<pre><code>hash, _ := c.Generate([]byte(&quot;secret&quot;), []byte(&quot;$6$rounds=5000$saltstr&quot;))
</code></pre>

<p>输出：</p>

<pre><code>$6$rounds=5000$saltstr$SH73gRYn1O7I/XTiq3AjDklhcqGvJ9vp65/TuFq2vQOoJEaejlTvsXOfy3dBpHju9v0Vi.VOcFh.79yy/kksl1
</code></pre>

<ul>
<li>$6：指定了 crypt 算法为 SHA512</li>
<li>$rounds=5000：指定了迭代 5000 次</li>
<li>$saltstr：盐值</li>
</ul>

<p>也就是说，salt 这个参数实际上是定义了算法、盐值两个部分。</p>

<p>回到登录验证的例子，第 3 步中把用户输入的密码和数据库中取出的 hash 作为 salt 加密就很好理解了，其实数据库中取出的 hash 在该函数中只是使用了 salt 部分，所以如果用户输入的密码正确的话，计算结果会和持久化的 hash 一致。</p>

<h3 id="toc_4">参考</h3>

<ul>
<li>文中提到的大部分内容在<a href="http://drops.wooyun.org/papers/1066">这篇文章</a>中有详述，建议阅读</li>
<li><a href="http://php.net/manual/en/function.crypt.php">PHP: crypt - Manual</a></li>
<li><a href="https://github.com/kless/osutil/tree/master/user/crypt">A golang password hashing library</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2016-01-30-goto-settings.html">iOS开发之如何跳到系统设置里的各种设置界面</a></h1>
			<p class="meta"><time datetime="2016-01-30T01:32:41+08:00" 
			pubdate data-updated="true">2016/1/30</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">需求</h3>

<p>从应用跳到系统设置里的WiFi界面有这个需求存在吗？答案是肯定的。比如以下两个例子：</p>

<p>在没有网的状态下，你可能想提醒用户去设置界面连接WiFi。如果不能跳到WiFi界面，只能在APP里面做出文字提示。这样很多小白用户可能不会看提示，只会觉得APP没有做好。</p>

<p>还有一种情况，做智能家居的APP，智能硬件设备自带WiFi（局域网）。如果用户没有连接设备的WiFi进入APP时，需要提示用户去设置界面连接WiFi。</p>

<p>以上这两种情况只是举个例子，这个小功能的用处还是很多的，大家可以自行探索。</p>

<h3 id="toc_1">实现</h3>

<p>info里面设置</p>

<p>在项目中的info.plist中添加 URL types 并设置一项URL Schemes为prefs，如下图：</p>

<p><img src="http://images.90159.com/12/wifi1.png" alt="wifi1"/></p>

<p>实现代码</p>

<pre><code>NSURL *url = [NSURL URLWithString:@&quot;prefs:root=WIFI&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h3 id="toc_2">跳到更多设置界面</h3>

<p>除了跳到WiFi设置界面，能不能跳到其他的设置界面呢？比如：定位服务、FaceTime、音乐等等。都是可以的，一起来看看如何实现的！</p>

<h4 id="toc_3">定位服务</h4>

<p>定位服务有很多APP都有，如果用户关闭了定位，那么，我们在APP里面可以提示用户打开定位服务。点击到设置界面设置，直接跳到定位服务设置界面。代码如下：</p>

<pre><code>//定位服务设置界面
NSURL *url = [NSURL URLWithString:@&quot;prefs:root=LOCATION_SERVICES&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<p>这样就可以跳到系统设置的定位服务界面啦！我们继续看几个列子。</p>

<h4 id="toc_4">FaceTime</h4>

<pre><code>//FaceTime设置界面
NSURL *url = [NSURL URLWithString:@&quot;prefs:root=FACETIME&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h4 id="toc_5">音乐</h4>

<pre><code>//音乐设置界面
NSURL *url = [NSURL URLWithString:@&quot;prefs:root=MUSIC&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h4 id="toc_6">墙纸设置界面</h4>

<pre><code>//墙纸设置界面
NSURL *url = [NSURL URLWithString:@&quot;prefs:root=Wallpaper&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
    [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h4 id="toc_7">蓝牙设置界面</h4>

<pre><code>//蓝牙设置界面
NSURL *url = [NSURL URLWithString:@&quot;prefs:root=Bluetooth&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url])
{
   [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h4 id="toc_8">iCloud设置界面</h4>

<pre><code>//iCloud设置界面
NSURL *url = [NSURL URLWithString:@&quot;prefs:root=CASTLE&quot;];
if ([[UIApplication sharedApplication] canOpenURL:url]
{
   [[UIApplication sharedApplication] openURL:url];
}
</code></pre>

<h3 id="toc_9">参数配置</h3>

<p>看到这几个例子，大家有没有发现，想跳到哪个设置界面只需要prefs:root=后面的值即可！是的，就是这样的。</p>

<p>我在网上找到一个列表，可以跳到这些界面的参数配置：</p>

<pre><code>About — prefs:root=General&amp;path=About
Accessibility — prefs:root=General&amp;path=ACCESSIBILITY
Airplane Mode On — prefs:root=AIRPLANE_MODE
Auto-Lock — prefs:root=General&amp;path=AUTOLOCK
Brightness — prefs:root=Brightness
Bluetooth — prefs:root=General&amp;path=Bluetooth
Date &amp; Time — prefs:root=General&amp;path=DATE_AND_TIME
FaceTime — prefs:root=FACETIME
General — prefs:root=General
Keyboard — prefs:root=General&amp;path=Keyboard
iCloud — prefs:root=CASTLE
iCloud Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP
International — prefs:root=General&amp;path=INTERNATIONAL
Location Services — prefs:root=LOCATION_SERVICES
Music — prefs:root=MUSIC
Music Equalizer — prefs:root=MUSIC&amp;path=EQ
Music Volume Limit — prefs:root=MUSIC&amp;path=VolumeLimit
Network — prefs:root=General&amp;path=Network
Nike + iPod — prefs:root=NIKE_PLUS_IPOD
Notes — prefs:root=NOTES
Notification — prefs:root=NOTIFICATIONS_ID
Phone — prefs:root=Phone
Photos — prefs:root=Photos
Profile — prefs:root=General&amp;path=ManagedConfigurationList
Reset — prefs:root=General&amp;path=Reset
Safari — prefs:root=Safari
Siri — prefs:root=General&amp;path=Assistant
Sounds — prefs:root=Sounds
Software Update — prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK
Store — prefs:root=STORE
Twitter — prefs:root=TWITTER
Usage — prefs:root=General&amp;path=USAGE
VPN — prefs:root=General&amp;path=Network/VPN
Wallpaper — prefs:root=Wallpaper
Wi-Fi — prefs:root=WIFI
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-12-18-carthage-decentralized-dependency-manager.html">Carthage去中心化的Cocoa依赖管理器</a></h1>
			<p class="meta"><time datetime="2015-12-18T00:36:07+08:00" 
			pubdate data-updated="true">2015/12/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>说到 iOS 的依赖管理工具，大家一定首先想到的是 CocoaPods ，不错，CocoaPods 确实是一个很好依赖管理工具，已然成为了 Cocoa 依赖管理的标准，丰富的支持库、文档等等，CocoaPods 相关的文章有很多，这里就不一一赘述了。</p>

<p>今天要介绍的是一款新的依赖管理工具，名曰 “Carthage”，名字有点难理解，简单方便，完全独立，不修改 XCode 项目文件或配置。我们已经有了CocoaPods，非常好用，那么为什么还要创建这样一个项目呢？本文翻译自Carthage的Github的README.md，带大家来了解一下这个工具有何不同之处。</p>

<p>Carthage的目标是用最简单的方式来管理Cocoa第三方框架。</p>

<p>基本的工作流如下：</p>

<ol>
<li>创建一个Cartfile，包含你希望在项目中使用的框架的列表</li>
<li>运行Carthage，将会获取列出的框架并编译它们</li>
<li>将编译完成的.framework二进制文件拖拽到你的Xcode项目当中</li>
</ol>

<p>Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2015-12-18-carthage-decentralized-dependency-manager.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-12-09-disable-browser-auto-fill-form-field.html">禁止浏览器自动填充表单字段</a></h1>
			<p class="meta"><time datetime="2015-12-09T00:34:09+08:00" 
			pubdate data-updated="true">2015/12/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">场景</h3>

<p>我们的登录表单一般都是 input text + input password：</p>

<pre><code>&lt;form id=&quot;loginForm&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
    &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>登录后如果用户选择了保存登录密码，那后续界面中如果有形如：</p>

<pre><code>&lt;input type=&quot;text&quot; name=&quot;field1&quot;&gt;
&lt;input type=&quot;password&quot; name=&quot;field2&quot;&gt;
</code></pre>

<p>这样的两个 input（text+password）接在一起，那浏览器就会自动填充登录时的输入。</p>

<p>要用程序清空自动填充有两个方案：</p>

<h3 id="toc_1">使用 autocomplete 属性</h3>

<p>在不需要自动填充的 input 上设置 autocomplete 属性：</p>

<pre><code>&lt;input autocomplete=&quot;off&quot;&gt;
</code></pre>

<p>这个方案对于某些版本的浏览器可能不行。</p>

<h3 id="toc_2">使用假的 input 让浏览器去填充</h3>

<p>在页面 <body> 后加入：</p>

<pre><code>&lt;!-- fake fields are a workaround for chrome autofill getting the wrong fields --&gt;
&lt;input style=&quot;display:none&quot; type=&quot;text&quot; name=&quot;fakeusernameremembered&quot;/&gt;
&lt;input style=&quot;display:none&quot; type=&quot;password&quot; name=&quot;fakepasswordremembered&quot;/&gt;
</code></pre>

<p>这个方案原理是让浏览器去填充用户实际上看不到的 input。虽然看上去代码比较 low，但是很实用。</p>

<p>参考：<a href="http://stackoverflow.com/questions/15738259/disabling-chrome-autofill">Disabling Chrome Autofill</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-12-01-tag.html">标签服务实现漫谈</a></h1>
			<p class="meta"><time datetime="2015-12-01T00:30:04+08:00" 
			pubdate data-updated="true">2015/12/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>标签服务是一个较为通用的基础业务服务，比如博客系统对文章加标签、社交网络中为好友添加印象、收藏的歌曲贴标签方便整理等等。</p>

<p>其主要提供两类接口：</p>

<ul>
<li>标签实体的管理/查询：负责标签实体的 CRUD</li>
<li>标签关联的管理/查询：将外部业务实体与标签建立/删除关联，根据外部业务实体 id 查询标签集</li>
</ul>

<h3 id="toc_0">RDB 实现</h3>

<p>基于关系型数据库的实现是最容易的，并且上大多数应用也是这样做的。</p>

<ol>
<li>建立 tag 表，其中包含了 tag 的基础属性，例如 name、description 等</li>
<li>建立 tag_rel 关联表，其中主要包含了 object_id、tag_id</li>
</ol>

<p>管理服务（创建/更新/删除）的实现非常容易；根据 object_id 查询其对应的标签集也很容易实现：</p>

<pre><code>SELECT
  tag_rel.tag_id,
  tag_rel.object_id,
  tag.name
FROM
  tag_rel
LEFT JOIN tag ON tag_rel.tag_id = tag.tag_id
WHERE
  tag_rel.object_id = &#39;2db775c1d2174a8c67fc39b86c3fc168&#39;
  
</code></pre>

<h4 id="toc_1">问题</h4>

<p>RDB 实现标签服务时最主要会面临的是性能问题，随着 tag_rel 数据量的不断增长，上面查询的性能会不断下降。</p>

<h4 id="toc_2">优化</h4>

<h5 id="toc_3">数据库</h5>

<ul>
<li>给列 tag_rel.object_id 加普通索引</li>
<li>升级数据库服务器硬件配置</li>
<li>使用数据库产品的特性，比如表分区/内存表</li>
</ul>

<p>在应用层面，可以缓存查询结果，如果实时性要求不高，缓存机制是比较容易实现的，但大多数业务场景可能并不适用。</p>

<h5 id="toc_4">分表</h5>

<p>前面提到的数据库产品的表分区特性（Oracle）我们也可以在应用层代码通过分表来实现。</p>

<ul>
<li>建立多张标签关联表 tag_rel_0、tag_rel_1、…、tag_rel_31</li>
<li>将查询条件 object_id 通过某种散列算法（比如 UUID 字符串的话可以通过 FNV Hash 后取模 32）得到 [0, 31] 的结果</li>
<li>SQL 落到具体的某张具体的分表上 FROM tag_rel_16</li>
</ul>

<p>大部分应用应该通过分表就能解决性能问题，还解决不了的话可以通过这个思路进行分库、分实例。</p>

<h3 id="toc_5">NoSQL 实现</h3>

<p>基于前文的背景可知，标签服务的定位是一个独立的服务，并不维护业务主体（object），所以将标签嵌套到业务主体中的设计在这里并不适合。</p>

<p>排除了这一条，我们还是只能用 RDB 的思想来进行设计：</p>

<ul>
<li>数据结构沿用 RDB 设计，即同样分为两个“表”：tag、tag_rel</li>
<li>将 SQL 中的 join 分成两步进行：1. 根据 object_id 查询出 tag_id 集合；2. 根据 tag_id 集合查询出 tag 集合</li>
</ul>

<h4 id="toc_6">Redis</h4>

<p>Redis 介绍和“为什么选用 Redis”略过。下面我们介绍一下如何使用 Redis 实现上述思路。</p>

<h5 id="toc_7">数据类型</h5>

<p>我们可以使用 Redis Hash 类型来保存标签，使用 Redis Set 来保存标签关联（这也是 Redis 官方文档的<a href="http://redis.io/topics/data-types-intro#redis-sets">示例</a>）。</p>

<p>给新闻（id: 1000）添加 4 个标签（通过 id 关联）：</p>

<pre><code>&gt; sadd news:1000:tags 1 2 5 77
(integer) 4
</code></pre>

<p>添加反向关联：</p>

<pre><code>&gt; sadd tag:1:news 1000
(integer) 1
&gt; sadd tag:2:news 1000
(integer) 1
&gt; sadd tag:5:news 1000
(integer) 1
&gt; sadd tag:77:news 1000
(integer) 1
</code></pre>

<p>查询该新闻的标签 id 集合：</p>

<pre><code>&gt; smembers news:1000:tags
1. 5
2. 1
3. 77
4. 2
</code></pre>

<p>然后根据返回的标签 id 集合查询标签。虽然分了两步进行查询，但 Redis 的高性能将为我们带来很低的耗时。</p>

<h3 id="toc_8">结论</h3>

<ul>
<li> 数据库分表能够解决标签服务的性能问题

<ul>
<li>实现简单，在现有实现的基础上改造很小</li>
<li>依然是基于关系型数据库，不用调整技术架构，开发模式、运维等保持不变</li>
</ul></li>
<li>使用 Redis 同样可以实现标签服务

<ul>
<li>使用 Hash 保存标签、Set 保存关联关系</li>
<li>分两步进行查询，Redis 自身的实现解决性能问题</li>
</ul></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-11-19-understand-https.html">理解 HTTPS 原理，SSL/TLS 协议</a></h1>
			<p class="meta"><time datetime="2015-11-19T00:17:18+08:00" 
			pubdate data-updated="true">2015/11/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">为什么要使用 HTTPS</h3>

<p>当我们使用 HTTP 协议时，传输的数据是不安全的，因为所有在客户端和服务端往来的数据都是明文：</p>

<ul>
<li>第三方可以获取到真实数据</li>
<li>第三方可以篡改数据</li>
<li>第三方可以冒充服务端或客户端</li>
</ul>

<p>为了解决这些问题，需要在 HTTP 协议中加入一个安全机制，由此并产生了 HTTPS，我们可以认为 HTTPS = HTTP + TLS/SSL。TLS/SSL 的引入解决了安全问题，而上层应用协议还是 HTTP。</p>

<h3 id="toc_1">历史</h3>

<p>SSL（Secure Sockets Layer）中文称作“安全套接层”，TLS（Transport Layer Security），中文称作“传输层安全协议”。</p>

<ol>
<li>1994 年，网景（NetScape）公司设计了 SSL 1.0</li>
<li>1995 年，SSL 2.0，存在严重漏洞</li>
<li>1996 年，SSL 3.0，得到大规模应用</li>
<li>1999 年，IETF 对 SSL 进行标准化，发布了 TLS 1.0</li>
<li>2006 年和 2008 年，TLS 进行了两次升级，分别为 TLS 1.1 和 TLS 1.2</li>
</ol>

<p>在应用层，我们习惯将两者并称 TLS/SSL，因为它们设计大致相同，我们可以认为它们是同一个事物在不同历史阶段的名称。</p>

<p>前面我们介绍过，HTTPS 可以认为是 HTTP + TLS/SSL，所以我们只需要了解 TLS/SSL 原理即可。在进入原理之前，我们需要了解两个基础概念：数字证书、证书授权中心。</p>

<h3 id="toc_2">证书与授权</h3>

<ul>
<li>数字证书（Digital Certificate）是用来证明公钥（非对称密钥算法中用于加密的密钥）所有者身份的。我们人人都可以自己生成一个公钥，但是这个公钥是否能代表是你的，这个认证的过程需要一个权威机构执行，这个机构就是证书授权中心。</li>
<li>证书授权中心（Certificate Authority）负责证书颁发。CA 是行业内信得过的组织机构，它具有权威性，由它颁发的证书大家都相信是可靠的。</li>
</ul>

<h3 id="toc_3">TLS/SSL 协议</h3>

<p><img src="http://7xjwh5.com1.z0.glb.clouddn.com/FlVPZF88pWxAP0-vhY84bxIR61QF" alt="TLS/SSL 协议"/></p>

<ol>
<li>由客户端发起握手，告诉服务器客户端支持的 TLS/SSL 版本、数据加密算法、以及一个随机数
1.1. 服务端确认支持这个版本的 TLS/SSL、加密算法，并生成一个随机数
1.2. 服务端将证书（带公钥）、服务端生成的随机数返回给客户端</li>
<li>客户端检查证书是否可信（和已有的 CA 列表对比，看是否是已有 CA 颁发的证书），并生成第三个随机数 PreMasterSecret</li>
<li>客户端使用证书带的公钥将 PreMasterSecret 进行加密，并通过之前交换的数据生成一个 Hash 值，发送给服务端，请求变更编码

<ul>
<li>3.1. 服务端校验 Hash（确认不是假的客户端），并使用自己证书的私钥解密出 PreMasterSecret</li>
<li>3.2. 服务端根据之前的随机数和约定的加密算法，生成用于加密后续传输数据的会话密钥 SessionSecret</li>
<li>3.3. 服务端根据之前交换的数据生成一个 Hash 值，发送给客户端，确认开始变更编码</li>
</ul></li>
<li>客户端校验 Hash （确认不是假的服务端），并生成会话密钥</li>
<li>客户端使用会话密钥加密数据，并发送给服务端

<ul>
<li>5.1 服务端使用会话密钥解密数据，执行业务逻辑后产生数据</li>
<li>5.2. 服务端使用会话密钥加密数据，返回给客户端</li>
</ul></li>
<li><p>客户端使用会话密钥解密数据，完成一次和服务端的数据交换<br/>
在这个过程中，有几个关键点：</p></li>
</ol>

<ul>
<li>前两次的随机数（客户端随机数、服务端随机数）是明文传输的</li>
<li>非对称密钥算法只被使用了一次，即客户端使用证书公钥加密 PreMasterSecret，服务端使用证书私钥解密出 PreMasterSecret</li>
<li>应用数据的传输使用的是对称密钥算法，客户端/服务端都使用会话密钥进行加/解密</li>
</ul>

<p>在握手阶段，安全与否的关键在于 PreMasterSecret 是否能够被破解，虽然理论上通过 RSA 算法加密是比较安全的，但还是有破解的可能性。最安全的做法是不发送 PreMasterSecret，而是根据一系列参数由客户端和服务端分别计算出 PreMasterSecret，这个算法就是<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2%EF%BC%8D%E8%B5%AB%E5%B0%94%E6%9B%BC%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2">迪菲－赫尔曼密钥交换</a>。</p>

<p>另外，TLS/SSL 不只适用于 HTTP 的安全问题，它也可以和其他应用层协议搭配使用。</p>

<h3 id="toc_4">应用</h3>

<p>通过上述介绍，我们得知使用 SSL/TLS 需要做如下准备：</p>

<ul>
<li>数字证书：可以找权威的证书授权中心颁发证书（有付费的，也有免费的），也可以自己做 CA，然后自己给自己颁发证书</li>
<li>服务端使用证书，比如配置 NGINX 来使用</li>
<li>客户端使用 SSL/TLS 协议和服务端进行通讯，如果是自己的 CA 颁发的证书，还需要在客户端导入 CA 的根证书</li>
</ul>

<p>下面我们针对自建 CA 做一个完整的示例（证书相关使用 Linux 的 openssl 命令，客户端、服务端使用 Golang）。</p>

<h4 id="toc_5">建立 CA</h4>

<ul>
<li>生成 CA 私钥：openssl genrsa -out ca.key 2048</li>
<li>生成 CA 根证书：openssl req -new -x509 -days 3650-key ca.key -out ca.crt</li>
</ul>

<h4 id="toc_6">颁发证书</h4>

<ul>
<li>生成证书私钥：openssl genrsa -out auto.pem 1024</li>
<li>生成证书公钥：openssl rsa -in auto.pem -out auto.key</li>
<li>生成签名请求：openssl req -new -key auto.pem -out auto.csr，其中的 Common Name 一定要填写客户端访问时的域名，并且不能是 IP</li>
<li>CA 签名（颁发）证书：openssl x509 -req -sha256 -in auto.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 3650 -out auto.crt</li>
</ul>

<p>最终我们需要的就是公钥 auto.key 以及证书 auto.crt。</p>

<h4 id="toc_7">服务端使用证书</h4>

<pre><code>http.ListenAndServeTLS(Auto.Server, &quot;auto.crt&quot;, &quot;auto.key&quot;, nil)
</code></pre>

<h4 id="toc_8">客户端发起请求</h4>

<p>这里假设客户端已经获得了服务端的证书。</p>

<pre><code>// getClient 根据传入的 url 实参中协议部分返回适当的 HTTP 客户端.
func getClient(url string) *http.Client {
    if !strings.Contains(url, &quot;https://&quot;) {
       return &amp;http.Client{}
    }

    certName := strings.Split(url, &quot;https://&quot;)[1]
    certName = strings.Split(certName, &quot;:&quot;)[0]

    // Load client cert
    cert, err := tls.LoadX509KeyPair(&quot;certs/&quot;+certName+&quot;.crt&quot;, &quot;certs/&quot;+certName+&quot;.key&quot;)
    if err != nil {
       logger.Error(err)
    }

    // Load CA cert
    caCert, err := ioutil.ReadFile(&quot;certs/ca.crt&quot;)
    if err != nil {
       logger.Error(err)
    }
    caCertPool := x509.NewCertPool()
    ok := caCertPool.AppendCertsFromPEM(caCert)
    if !ok {
       logger.Error(&quot;Load CA cert failed&quot;)
    }

    // Setup HTTPS client
    tlsConfig := &amp;tls.Config{
       Certificates: []tls.Certificate{cert},
       RootCAs:      caCertPool,
    }
    tlsConfig.BuildNameToCertificate()

    transport := &amp;http.Transport{TLSClientConfig: tlsConfig}

    return &amp;http.Client{Transport: transport}
}
</code></pre>

<p>其中载入了 CA 证书，原因就是因为我们自建的 CA 不在系统自带的“受信任的根证书颁发机构”中。</p>

<h3 id="toc_9">参考</h3>

<ul>
<li><a href="http://www.wosign.com/Basic/howsslwork.htm">数字证书基础知识：SSL 工作原理</a></li>
<li><a href="https://program-think.blogspot.com/2014/11/https-ssl-tls-1.html">扫盲 HTTPS 和 SSL/TLS 协议</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-10-19-www-domian-and-cookie-free.html">www 开头的域名和 Cookie-free</a></h1>
			<p class="meta"><time datetime="2015-10-19T00:07:55+08:00" 
			pubdate data-updated="true">2015/10/19</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Cookie-free, Cookie, www, SEO, 性能优化, 域名 2015-10-19<br/>
本文我们会探索两个问题：</p>

<ul>
<li>网站是应该选择 www 开头的域名作为用户入口还是应该使用不带 www 的域名（裸域）？</li>
<li>Cookie-free 是什么？为什么很重要？</li>
</ul>

<h3 id="toc_0">www 开头的域名</h3>

<p>国内外大多数知名站点都是使用带 www 的二级域名作为用户入口，其中有通过 301 将裸域重定向到 www 二级域名的，也有通过 302 的（较少）。</p>

<p>为什么这些大站（流量大/子域名众多）都要使用带 www 的域名呢，主要原因应该有以下几点：</p>

<ul>
<li>对用户来说识别度高，带了 www 后（即使不加 http://）用户就知道这是一个可以用浏览器打开的 URL</li>
<li>避免将 Cookie 设置在裸域上（后面我们会讨论这样做的坏处）</li>
<li>在其他地方引用带 www 的 URL 更容易被识别（比如会自动加上链接）</li>
</ul>

<p>以上主要是对大站来说，我们经常使用的小站（流量小/子域名较少）入口很多是不带 www 的（两者都允许以及类似 Twitter 这样的个例除外），这样做原因应该主要只有一点：</p>

<ul>
<li>域名更短，突出简约的个性，特别是一些个性后缀的域名不带 www 时更有利于用户记忆</li>
</ul>

<h3 id="toc_1">301 or 302</h3>

<p>无论我们选择带 www 的域名作为用户入口还是选择裸域，都需要做跳转。这个时候是选择使用 301 永久跳转还是使用 302 临时跳转呢？</p>

<p>从大多数网站来看，<strong>选择 301 永久跳转的居多</strong>，主要原因是 SEO：</p>

<p><em>302重定向很容易被搜索引擎误认为是利用多个域名指向同一网站，那么你的网站就会被封掉，罪名是“利用重复的内容来干扰Google搜索结果的网站排名”。因为302重定向经常被用于做url劫持，黑帽seo技术中，而且百度在处理302重定向技术还不成熟，经常将它纳入到黑帽seo的范畴中，而google对这方面识别处理就完善了许多。所以302重定向在现阶段的搜索引擎技术中，还是容易导致网站降权的，尽量不用。但从seo、网站优化方面来说是弊大于利。<a href="http://baike.baidu.com/view/2453504.htm">302 重定向 - 百度百科</a></em></p>

<h3 id="toc_2">Cookie 规则</h3>

<p>我们先简单明确一下 Cookie 在浏览器上的规则，以域名 lambgao.com 为例：</p>

<ul>
<li>domain=.lambgao.com 时，Cookie 对裸域 lambgao.com 以及所有子域名 **.lambgao.com 是可用的</li>
<li>domain=lambgao.com 时效果同上</li>
<li>domain=lambgao.com 时对于非 lambgao.com 的其他域名无效</li>
<li>**.lambgao.com 可以将 Cookie 设置在裸域上</li>
<li>**.lambgao.com 不可以在其他子域上设置 Cookie</li>
</ul>

<p>具体细节请参考 <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a>。</p>

<p>遵守了以上规则后，我们来看看“从输入 URL 到页面加载完成的过程中都发生了什么事情？”</p>

<ul>
<li><a href="http://fex.baidu.com/blog/2014/05/what-happen">以计算机组成原理和网络通信的视角</a></li>
<li><a href="http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html">以应用层协议和 Web 开发者的视角</a></li>
</ul>

<p>我们这里的重点是返回 HTML 到浏览器后开始加载静态资源（js/css/images），此时浏览器会根据规则带上 Cookie 发送这些请求。很显然，这样会<strong>占用</strong>___额外的___<strong>网络带宽</strong>，因为每个静态资源的请求都会带上 Cookie 数据，特别是当 Cookie 较大的时候。</p>

<h3 id="toc_3">Cookie-free 域名</h3>

<p>Cookie-free 域名指的是请求时不发送 Cookie 的域名，要解决前面我们提到的静态资源请求时带 Cookie 的方法就是使用 Cookie-free 域名来 serve 静态资源文件。</p>

<p>这个方法是最目前最普遍和有效的做法，大多数站点都是使用了和用户入口所在主域名完全独立的另一个域名来提供静态资源：</p>

<ul>
<li>无论用户入口是 lambgao.com 还是 <a href="http://www.lambgao.com%EF%BC%8C%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A6%82%E6%9E%9C%E6%94%BE%E5%9C%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D%E4%B8%8A%EF%BC%88%E6%AF%94%E5%A6%82">www.lambgao.com，静态资源如果放在另一个域名上（比如</a> static.xxx.com），那么浏览器在请求这些静态资源时都不会带上 Cookie</li>
<li>static.xxx.com 可以非常方便的做 CDN 加速，因为都是静态资源，不需要配置复杂的匹配策略或重写规则</li>
</ul>

<p>另外，Cookie 最好只设置在当前域名下，不要设置在裸域上，避免不必要的“污染”。当然， 有的场景下，“污染”是为了以最简单的方式实现某些特性，比如多个子站通过裸域会话追踪的 Cookie 实现会话共享。</p>

<h3 id="toc_4">结论</h3>

<ul>
<li>尽量以 www 作为站的用户入口，避免将 Cookie 设置在裸域上</li>
<li>尽量考虑 Cookie-free 问题，使用其他域名进行静态资源 Serve 是最好选择</li>
</ul>

<p>如果以上两点在站点初期都没有考虑好，那也不用担心。因为我们自己的站点一般达不到“大站”的量级，但此时我们依然需要：</p>

<ul>
<li>尽量安全地使用 Cookie，避免混乱和漏洞（比如子站 A 漏洞会影响子站 B）</li>
<li>做好 Cache 控制（200 cache），减少不必要请求的发送</li>
</ul>

<h3 id="toc_5">参考</h3>

<ul>
<li><a href="http://www.zhihu.com/question/20414602">为什么越来越多的网站域名不加 ‘www’ 前缀？</a></li>
<li><a href="https://developer.yahoo.com/performance/rules.html#cookie_free">Best Practices for Speeding Up Your Web Site</a></li>
<li><a href="http://stackoverflow.com/questions/1062963/how-do-browser-cookie-domains-work">How do browser cookie domains work?</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-10-09-php-asynchronous-http.html">PHP 异步 HTTP 与 NGINX 499</a></h1>
			<p class="meta"><time datetime="2015-10-09T00:05:18+08:00" 
			pubdate data-updated="true">2015/10/9</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">PHP 异步 HTTP</h3>

<p>在 PHP 代码中提交异步 HTTP 请求比较常用的方式是通过 fsockopen/fwrite/fclose 来实现，请参考如下代码。</p>

<pre><code>function post($host, $path, $port, $data) {
    $post = http_build_query($data);
    $len = strlen($post);

    $fp = fsockopen($host, $port, $errno, $errstr, 30);
    if (!$fp) {
        echo &quot;$errstr ($errno)\n&quot;;

        return;
    }

    $out = &quot;POST $path HTTP/1.1\r\n&quot;;
    $out .= &quot;Host: $host\r\n&quot;;
    $out .= &quot;Content-type: application/x-www-form-urlencoded\r\n&quot;;
    $out .= &quot;Connection: Close\r\n&quot;;
    $out .= &quot;Content-Length: $len\r\n&quot;;
    $out .= &quot;\r\n&quot;;
    $out .= $post . &quot;\r\n&quot;;
    // echo($out);
    fwrite($fp, $out);

    // 注释掉如下代码实现不等待 HTTP 响应，从而实现“异步”
//    $receive = &#39;&#39;;
//    while (!feof($fp)) {
//        $receive .= fgets($fp, 128);
//    }
//    echo &quot;&lt;br /&gt;&quot; . $receive;


    fclose($fp);
}
</code></pre>

<p>这段代码可以如期完成异步 HTTP 效果，但是如果提交的服务端有 NGINX 做 CGI 反代的话，可能会导致上游后端 PHP 接收不到该请求。</p>

<h3 id="toc_1">NGINX 499</h3>

<p>查看 NGINX access log，发现这样的请求会以 499（Client Closed Request）记录。确定问题是因为：客户端主动端口请求连接时，NGINX 不会将该请求代理给上游服务（FastCGI PHP 进程），这个时候 access log 中会以 499 记录这个请求。</p>

<p>要解决这个问题需要将 NGINX FastCGI 忽略客户端中断配置打开：</p>

<pre><code>fastcgi_ignore_client_abort on;
</code></pre>

<p>这样无论客户端是否断开，都会将这个请求代理给上游，并且会记录上游服务处理后的返回状态。</p>

<p>另外，还有一个类似配置 proxy_ignore_client_abort on;，这个配置是针对其他类型的反代，PHP 的场景并不适用。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-09-20-compile-go-cross-platform.html">Go 编译跨平台</a></h1>
			<p class="meta"><time datetime="2015-09-20T00:03:02+08:00" 
			pubdate data-updated="true">2015/9/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>适用于 [Linux] ，拷贝代码后新建文件 cross.bash，并在 ${go 安装路径}/src 目录下执行。</p>

<pre><code>#!/usr/bin/env bash

export CGO_ENABLED=0

export GOOS=darwin
export GOARCH=386
./make.bash

export GOOS=linux
export GOARCH=386
./make.bash

export GOOS=windows
export GOARCH=386
./make.bash


export GOOS=darwin
export GOARCH=amd64
./make.bash

export GOOS=linux
export GOARCH=amd64
./make.bash

export GOOS=windows
export GOARCH=amd64
./make.bash
</code></pre>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-09-17-tvos-initial-impression.html">一个iOS开发者对tvOS SDK的初探</a></h1>
			<p class="meta"><time datetime="2015-09-17T23:46:33+08:00" 
			pubdate data-updated="true">2015/9/17</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Walter Isaacson编写的《Steve Jobs》的最后一章中，Steve说过“我最终实现并让它拥有了你们能想象到的最简单的用户界面”。当时他指的就是Apple TV。</p>

<p>Steve不幸离世已经过去很久了，但是人们一直翘首以盼着这款产品。就在昨天2015年9月9日，超过四个春秋的期盼，我们终于等来了这个礼物，虽然可能与Steve对这款产品的愿景和理想有所差距，但是革命的步伐已经坚实的迈出了第一步。</p>

<p>作为一名iOS开发者，昨天的产品发布会让我心潮澎湃，因为Apple宣布，新的Apple TV集成了App Store，这就意味着我们可以为它开发专有的应用，并且会让我们重新认知已了解的iOS知识，以及会开启更多新的展现想法、创意的机会。</p>

<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力准备一些有价值的tvOS教程（通宵达旦！），在此同时，我想从一个iOS开发者的视角与大家分享我对tvOS的初步印象。</p>

<p>让我们一探究竟吧！</p>

<h3 id="toc_0">基本概念</h3>

<p>老款的Apple TV其实类似一个机顶盒，主要提供的功能是让用户通过及其简单的操作界面导航或浏览视频内容。昨天发布的新Apple TV在此基础上进一步的扩充功能，使一些成熟的应用能在Apple TV中运行，比如购物应用，甚至是游戏。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_02-457x320.jpg" alt="tvOS-1"/></p>

<p>让我们来看看以下这些信息：</p>

<ul>
<li>硬件规格： 值得一说规格是64位 A8处理器，32G或64G的存储空间，2G的内存，1080p的分辨率以及支持HDMI，Siri远程遥控，新的Apple TV遥控器。</li>
<li>价格： 新Apple TV的定价为32G 149美元，64G 199美元。这样的定价出乎大多人的以外，原以为新Apple TV的价格会更高一些。</li>
<li>发售时间： Apple在发布会上给出了一个非常模糊和不确定的发售时间“十月下旬”，但是Apple在发布会之后就立即向开发者们提供了tvOS SDK。现在离正式发售已时日不多，如果大家有针对新Apple TV好的想法，我建议你们要抓紧时间了。</li>
<li>开发硬件： Apple已经宣布了一个开发者计划允许已经注册的开发者们请求Apple TV Developer Kit。该计划可以让开发者们提前对Apple TV进行开发测试。这看起来似乎是一件很美好的事，但是如果你真的要加入该开发者计划，那么仔细看看下面的建议：
-&gt; 注意： 众所周知，iOS、OSX的开发者计划都是收费的，tvOS的开发者计划应该也不例外，不过之前对于该计划的收费信息是非常含糊不清的，但是现在我们通过Apple员工在开发者论坛上发的帖子中确认了该计划只需要话费1美元即可加入。如果大家有意为tvOS贡献一份力量，或者需要编写教程材料的话，强烈建议你们加入该开发计划。</li>
</ul>

<h3 id="toc_1">开发 tvOS 应用</h3>

<p>啰嗦完一堆后，显然最重要的事就是怎样为新Apple TV开发应用，这应该也是大家最感兴趣的事！</p>

<p>为新Apple TV开发应用实际就是在为tvOS开发应用，当然tvOS这个名字是由Apple根据不同设备而创造的。tvOS仍然是基于iOS开发的，所以有很多框架大家都应该非常熟悉了。</p>

<p>如果要为tvOS开发应用，大家必须要从开发者中心下载<a href="https://developer.apple.com/xcode/download/">Xcode7.1</a>进行开发。该版本是Xcode新的beta版，目前只有该版本支持tvOS以及提供tvOS的模拟器。如果你有需要的话，也可同时下载Xcode7 GM版本，他们可以共存于你们的电脑中。</p>

<p>Apple提供了两种在tvOS上开发应用的方法：</p>

<ol>
<li>TVML Apps： 这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。这对我们来说是一个巨大的惊喜，我们会在之后有较详细的介绍。</li>
<li>Custom Apps： 这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架，Storyboard、UIKit、Auto Layout等。</li>
</ol>

<p>当你们在为Apple TV开发应用时，你们会发现Xcode中会出现单独的程序目标（这意味着用户将会单独购买的形式购买tvOS应用）。虽然Apple在发布会上说Apple TV中的应用支持通用购买模式，也就是针对iOS和tvOS都支持的应用，用户只需要购买一次即可同时在iPhone和Apple TV上使用。但是从目前的情况来看，我们还不确定Apple是如何实现的，或许在Itunes Connect中支持连接两个程序目标的功能即将来临？</p>

<h3 id="toc_2">TVML Apps</h3>

<p>先前我提过，为tvOS开发应用有两种方式，第一种就是通过TVML、TVJS和TVMLKit技术。如果这些缩写对于你们来说非常陌生，那么不要着急，这就告诉你们他们都是什么：</p>

<ul>
<li>TVML是一种基于“Television Markup Language”的XML格式。</li>
<li>TVJS是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li>TVMLKit是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>

<p>如果你是一名经常使用原生APIs开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>

<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_03-700x296.jpg" alt="tvOS-2"/></p>

<p>如果我列举的这个例子正好是你们tvOS应用的需求，那么你可能需要考虑如何使用TVMLKit工具包。Apple已经为我们开发者完成了一些主要的工作，比如提供了许多可重用的tvOS界面展示模板，这些模板大都与iOS应用的界面神似，所以用户们并不会感到陌生，这些模板大概有18种之多。大多数模板都可以让你创建出脱凡的、非常适合家中电视展示的界面。大家可以访问Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8">文档</a>查看这些我们强烈推荐使用的模板。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_04-700x296.jpg" alt="tvOS-3"/></p>

<p>我也推荐大家在tvOS模拟器运行<a href="https://developer.apple.com/library/prerelease/tvos/samplecode/TVMLCatalog/Introduction/Intro.html#//apple_ref/doc/uid/TP40016505">TVML Catalog sample app</a>去查看每个模板。同时你需要启动一个本地的web服务器，便于tvOS应用通过模板展示内容时访问，所以你需要仔细查阅README.md文件去了解相关内容。</p>

<p>诚然TVMLKit还有许多知识点，如果你希望基于它开发一款tvOS应用，那么我提到的一些文档是非常值得你们去查阅参考的。这里我着重推荐大家首先看看如何使用菜单导航类的模板，比如menuBarTemplate、mainTemplate、searchTemplate等。然而，如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验，那么你们就需要了解如何开发完整的自定义的tvOS应用。</p>

<h3 id="toc_3">Custom Apps</h3>

<p>你所知道的大多数iOS框架，比如UIKit、Core Graphics、CloudKit等等都可以在tvOS中使用。你可以在Apple提供的这个<a href="https://developer.apple.com/library/prerelease/tvos/releasenotes/General/tvOS90APIDiffs/index.html#//apple_ref/doc/uid/TP40016577">文档</a>中查看哪些框架可以用，哪些不可以使用。如果你现在正是一名iOS开发者，那么会对这个文档中的列表非常熟悉。而且不管使用Swift还是Objective-C或者C都可以开发tvOS应用。</p>

<p>尽管如此，如果想开发自定义的tvOS应用，还是有许多新的知识需要我们学习，作为一名iOS开发者，也应该掌握甚至精通这些新的知识。</p>

<h3 id="toc_4">Focus Engine</h3>

<p>其中一个对于iOS开发者比较陌生的概念是用户输入/选择方法。在使用Apple TV的过程中，用户不会用手指去按压或滑动屏幕，取而代之的是使用Apple提供的遥控器或者是一些游戏控制器。</p>

<p>tvOS采用了一个被称为Focus Engine的引擎系统，它在整个tvOS中有且只有一个。该引擎负责响应当用户使用遥控器上的手势操作或按键操作对菜单或内容进行上下左右的选择。</p>

<p>Focus Engine会自动根据用户的选择决定要聚焦或展示的视图，你不需要在代码中做任何类似选中或导航的处理。比如说，此时展示的界面是你已经在Storyboard中设计好的视图布局，其中有一个视图是当前聚焦状态，那么当用户通过手势往右滑动时，Focus Engine会自动根据当前聚焦的视图找到与之相邻的左边的视图，并将其选中和聚焦。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_05-700x328.jpg" alt="tvOS-4"/></p>

<p>作为一个开发者，你必须要学习与Focus Engine相关的API，比如当聚焦的视图发生变化时如何获取通知、如何通过编码触发聚焦视图的改变扥等。更多关于Focus Engine的API可以参阅App Programming Guide for tvOS文档中的 <a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/WorkingwiththeAppleTVRemote.html#//apple_ref/doc/uid/TP40015241-CH5-SW14">Supporting Focus Within Your App</a> 章节。</p>

<h3 id="toc_5">TVServices</h3>

<p>虽然iOS开发者在tvOS应用的开发过程中，主要使用的是一些已经比较熟悉的iOS框架，但是也有一些tvOS特有的框架需要开发者们去了解掌握，比如像新加入的TVServices框架。</p>

<p>TVServices的主要作用是描述你的应用的内容，以便tvOS在首页的顶部栏位显示。在首页顶部栏位显示的应用都是用户自己设置的，用户可以将他们认为最为常用的或最为重要的应用放在首页顶部栏位，便于快速打开或浏览其中主要信息。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_06-478x320.jpg" alt="tvOS-5"/></p>

<p>你们的应用可以在用户不进入应用的情况下，向用户提供简短的、感兴趣的信息，这就会使你的应用有了额外价值，使用TVServices无疑是提高你的应用下载量的绝佳手段。比如一个游戏应用，通过TVServices显示游戏存档，那么用户就可以直接从首页通过游戏存档进入游戏。如果是一个社交应用，那么就可以在首页显示社交动态信息，如果是一个照片分享应用，那么就可以显示近期朋友和家人分享的照片。</p>

<p>更多关于TVServices的信息可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/TVServices/Reference/TVServices_Ref/index.html#//apple_ref/doc/uid/TP40016412">TVServices Framework Reference文档</a>。使用好它对你的应用非常有益。</p>

<h3 id="toc_6">Parallax Images</h3>

<p>还有一件会让你疑惑的可能就是在发布会的Keynote中，Apple着重强调了图片和应用图标的视差效果。这是一个非常棒的视图效果，但是为什么这个特性会被放在Keynote中提及，它为什么这么重要呢？</p>

<p>如果你使用了tvOS模拟器，你就会明白为什么这个特性如此重要。当移动聚焦视图时，你需要向左或向右滑动，但如果你只滑动了一点，Apple会对当前聚焦的视图做一个轻微的旋转处理，目的是让用户知道现在正在作以操作（但是还需要继续滑动来改变聚焦视图）。这是一个着眼于细节但又非常有用的特性。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_07.jpg" alt="tvOS-6"/></p>

<p>Apple把视差效果看做tvOS设计中的一个关键组成部分，并强烈建议应用图标和电影海报使用该特性。不过感谢Apple在App Programming Guide for tvOS文档中提供了<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/CreatingParallaxArtwork.html#//apple_ref/doc/uid/TP40015241-CH19-SW1">Creating Parallax Artwork章节</a>，帮助我们创建视差特性的图片资源，以及为我们提供了视察图片资源的预览应用。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_08.jpg" alt="tvOS-7"/></p>

<h3 id="toc_7">Controllers</h3>

<p>每一个购买了新Apple TV的用户，都会收到一个功能强大的新版遥控器。上一代只能上下左右简单选择方位以及只有几个简单导航按键的遥控器，而新一代的Apple TV遥控器增加了更多令人激动的新特性：</p>

<ul>
<li>玻璃触控板：位于遥控器的顶部，可以让用户在其上面进行一些手势操作，比如滑动、轻拍、点击。</li>
<li>麦克风：可以让用户通过遥控器访问Siri（Siri有使用国家的限制）以及可以通过语音控制电视的音量。</li>
<li>陀螺仪：结合动作传感器可以为用户提供非常棒的游戏体验。用户可以通过倾斜遥控器在游戏中控制方向盘开车，或者控制英雄奔跑穿越山洞。</li>
</ul>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_09.jpg" alt="tvOS-8"/></p>

<p>你可以使用你知道的处理手势操作的API去监听滑动或轻点，还有一些新的API去监听遥控器上不同的按钮，比如pressesBegan()、pressesEnded()、pressesChanged()和pressesCancelled()。</p>

<p>遥控器通过蓝牙技术与Apple TV主机交互，这意味着为蓝牙游戏控制器敞开的大门（恕我直言，用Apple的遥控器玩游戏并不是很好的选择）。Apple已经宣布<a href="https://steelseries.com/gaming-controllers/nimbus">Nimbus Steelseries Controller</a>将会支持新Apple TV。想了解更多关于这方面的信息请查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/WorkingwithGameControllers.html#//apple_ref/doc/uid/TP40015241-CH18-SW1">Working with Game Controllers</a>。</p>

<h3 id="toc_8">tvOS and Games</h3>

<p>我们衷心的希望游戏能在tvOS上火起来，Apple似乎是直接瞄准了任天堂漠不关心的一个游戏市场。</p>

<p>tvOS有很健壮的游戏技术作为支撑，SpriteKit和SceneKit都可以在tvOS中正常工作，在Keynote中Crossy Roads开发者展示了他们的tvOS游戏，该游戏使用Unity开发，所以这也暗示着在不久的将来tvOS也会支持Unity开发的游戏。</p>

<p>大多数用SceneKit开发的游戏都可以无缝移植到新Apple TV中。比如Ray就将教程中介绍过的Zombie Conga游戏移植到了新Apple TV中，花费时间还不到10分钟，几乎不需要修改任何代码。</p>

<p>-&gt; 注：游戏视频可前往原文查看，但需要科学上网。</p>

<h3 id="toc_9">Limitations</h3>

<p>或许目前关于tvOS比较有疑惑的两点就是本地存储和应用大小的限制。</p>

<h3 id="toc_10">Limitation: Local Storage</h3>

<p>关于本地存储，基本确定是没有！如果你的应用需要持久化用户的数据，那么你需要使用iCloud、CloudKit或者自己的备份服务去实现。任何试图存在Apple TV中的数据都不保证在下次打开应用时还嫩存在。如果你想同步不同设置之间的数据，那么你就需要将数据线存在某个地方，但绝不是Apple TV中。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_10-480x313.jpg" alt="tvOS-9"/></p>

<p>一定要牢记这点，它对于你设计tvOS应用的结构时很关键。这里列出了一些规则：</p>

<ul>
<li>如果你需要存储的数据量小于1MB，iCloud的key-value存储方式是一个可以选择的方案。但是要切记，iCloud KVS严格限制了只能有所属者才可以访问数据，并且不能共享给其他用户。</li>
<li>如果你需要分享事件或者数据给其他用户，CloudKit是一个不错的选择方案。</li>
<li>如果你开发的是一个跨平台的应用或者有特殊的需求，你就得使用你自己的备份服务了。</li>
</ul>

<h3 id="toc_11">Limitation: App Size</h3>

<p>另一个限制是关于应用大小的限制，规定不能超过200MB。</p>

<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/FlipTable-250x228.png" alt="tvOS-10-FlipTable"/></p>

<p>在你们掀桌之前，请回顾一下WWDC2015以及介绍过的“On-Demand Resources”相关API。这几乎像是Apple为tvOS提前铺垫的。</p>

<p>这些API通过按需下载资源文件减小应用初始安装时的大小。开发者可以在Xcode中给多媒体资源文件用标签进行标记，将应用提交后，App Store会自动根据标记将多媒体资源文件拆分为一个一个下载包。当用户在使用应用时如果需要用到某类标记的资源文件，就可以请求下载该标记的资源文件。当然你得有预期的判断，要先于用户使用资源前开始下载他们需要的资源，这样对于用户来说他们根本不会感受到因为下载资源带来的不好的用户体验。</p>

<p>举一个简单的例子，比如你有一款游戏应用有10个关卡。在用户安装该游戏时可以只包含两个关卡的多媒体资源文件。一旦用户完成了第一个关卡，你应该发送一个下载请求，下载第三个关卡的多媒体资源文件。当用户完成了第二个关卡时，第三个关卡需要的资源文件早已下载好准备妥当。在用户的整个游戏过程中，你就可以运用该机制一步一步去下载所需的资源文件。</p>

<p>虽然这种机制对于开发者来说无疑增加了工作量，但是这对用户来说是一件非常愉悦的事情。你试想一下，用户是愿意等待下载一个1GB大小的游戏呢，还是更愿意下载一个100MB大小的游戏并立即开始游戏呢。不过该机制也存在一个隐患，如果用户的网络条件很差，他们一般都更愿意在晚上挂着下载。那么如果用户在白天玩你的游戏，然后同时用龟速的网络下载后面关卡的资源文件，这简直是令人发指的用户体验。不幸的是作为tvOS开发者，在这种情形下目前也无能为力。</p>

<p>原文地址：<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions">tvOS SDK: An iOS Developer’s Initial Impressions</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-09-03-difference-between-concurrenthashmap.html">ConurrentHashMap和Hashtable的区别</a></h1>
			<p class="meta"><time datetime="2015-09-03T22:59:40+08:00" 
			pubdate data-updated="true">2015/9/3</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>集合类是Java API的核心，但是我觉得要用好它们是一种艺术。我总结了一些个人的经验，譬如使用ArrayList能够提高性能，而不再需要过时的Vector了，等等。JDK 1.5引入了一些好用的并发集合类，它们对于大型的、要求低延迟的电子商务系统来说非常的有用。这篇文章中将会看看ConcurrentHashMap和Hashtable之间的区别。</p>

<p>这篇文章是<a href="/2015-09-02-how-hashmap-works-in-java.html">HashMap的工作原理</a>以及<a href="/2015-09-02-difference-between-hashmap-and-hashtable.html">HashMap和Hashtable的区别</a>的后续。如果你已经读过的话，那么我相信你读完本篇之后会有所收获。</p>

<h3 id="toc_0">为什么我们需要ConcurrentHashMap和CopyOnWriteArrayList</h3>

<p>同步的集合类（Hashtable和Vector），同步的封装类（使用Collections.synchronizedMap()方法和Collections.synchronizedList()方法返回的对象）可以创建出线程安全的Map和List。但是有些因素使得它们不适合高并发的系统。它们仅有单个锁，对整个集合加锁，以及为了防止ConcurrentModificationException异常经常要在迭代的时候要将集合锁定一段时间，这些特性对可扩展性来说都是障碍。</p>

<p>ConcurrentHashMap和CopyOnWriteArrayList保留了线程安全的同时，也提供了更高的并发性。ConcurrentHashMap和CopyOnWriteArrayList并不是处处都需要用，大部分时候你只需要用到HashMap和ArrayList，它们用于应对一些普通的情况。</p>

<h3 id="toc_1">ConcurrentHashMap和Hashtable的区别</h3>

<p>Hashtable和ConcurrentHashMap有什么分别呢？它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-09-02-how-hashmap-works-in-java.html">HashMap的工作原理</a></h1>
			<p class="meta"><time datetime="2015-09-02T23:09:24+08:00" 
			pubdate data-updated="true">2015/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！</p>

<h3 id="toc_0">先来些简单的问题</h3>

<h4 id="toc_1">“你用过HashMap吗？” “什么是HashMap？你为什么用到它？”</h4>

<p>几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题：</p>

<h4 id="toc_2">“你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？”</h4>

<p>你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。”</p>

<p>但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法：</p>

<h4 id="toc_3">“当两个对象的hashcode相同会发生什么？”</h4>

<p>从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问：</p>

<h4 id="toc_4">“如果两个键的hashcode相同，你如何获取值对象？”</h4>

<p>面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。</p>

<p>其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！</p>

<p>许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。</p>

<p>如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。</p>

<h4 id="toc_5">“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h4>

<p>”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。</p>

<p>如果你能够回答这道问题，下面的问题来了：</p>

<h4 id="toc_6">“你了解重新调整HashMap大小存在什么问题吗？”</h4>

<p>你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。</p>

<p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：）</p>

<p>热心的读者贡献了更多的关于HashMap的问题：</p>

<ol>
<li><strong>为什么String, Interger这样的wrapper类适合作为键？</strong> String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</li>
<li><strong>我们可以使用自定义的对象作为键吗？</strong> 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。</li>
<li><p><strong>我们可以使用CocurrentHashMap来代替Hashtable吗？</strong>这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看<a href="/2015-09-03-difference-between-concurrenthashmap.html">Hashtable和ConcurrentHashMap的区别</a>。<br/>
我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点：</p></li>
</ol>

<ul>
<li>hashing的概念</li>
<li>HashMap中解决碰撞的方法</li>
<li>equals()和hashCode()的应用，以及它们在HashMap中的重要性</li>
<li>不可变对象的好处</li>
<li>HashMap多线程的条件竞争</li>
<li>重新调整HashMap的大小</li>
</ul>

<p>总结</p>

<p>HashMap的工作原理<br/>
HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。</p>

<p>当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。</p>

<p>因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。你可以查看更多的关于HashMap的文章:</p>

<ul>
<li><a href="/2015-09-02-difference-between-hashmap-and-hashtable.html">HashMap和Hashtable的区别</a></li>
<li><a href="/2015-09-02-difference-between-hashmap-and-hashset.html">HashMap和HashSet的区别</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-09-02-difference-between-hashmap-and-hashset.html">HashMap和HashSet的区别</a></h1>
			<p class="meta"><time datetime="2015-09-02T23:03:27+08:00" 
			pubdate data-updated="true">2015/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>HashMap和HashSet的区别是Java面试中最常被问到的问题。如果没有涉及到Collection框架以及多线程的面试，可以说是不完整。而Collection框架的问题不涉及到HashSet和HashMap，也可以说是不完整。HashMap和HashSet都是collection框架的一部分，它们让我们能够使用对象的集合。collection框架有自己的接口和实现，主要分为Set接口，List接口和Queue接口。它们有各自的特点，Set的集合里不允许对象有重复的值，List允许有重复，它对集合中的对象进行索引，Queue的工作原理是FCFS算法(First Come, First Serve)。</p>

<p>首先让我们来看看什么是HashMap和HashSet，然后再来比较它们之间的分别。</p>

<h3 id="toc_0">什么是HashSet</h3>

<p>HashSet实现了Set接口，它不允许集合中有重复的值，当我们提到HashSet时，第一件事情就是在将对象存储在HashSet之前，要先确保对象重写equals()和hashCode()方法，这样才能比较对象的值是否相等，以确保set中没有储存相等的对象。如果我们没有重写这两个方法，将会使用这个方法的默认实现。</p>

<p>public boolean add(Object o)方法用来在Set中添加元素，当元素值重复时则会立即返回false，如果成功添加的话会返回true。</p>

<h3 id="toc_1">什么是HashMap</h3>

<p>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许重复的键。Map接口有两个基本的实现，HashMap和TreeMap。TreeMap保存了对象的排列次序，而HashMap则不能。HashMap允许键和值为null。HashMap是非synchronized的，但collection框架提供方法能保证HashMap synchronized，这样多个线程同时访问HashMap时，能保证只有一个线程更改Map。</p>

<p>public Object put(Object Key,Object value)方法用来将元素添加到map中。</p>

<h3 id="toc_2">HashSet和HashMap的区别</h3>

<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>

<tbody>
<tr>
<td>HashMap实现了Map接口</td>
<td>HashSet实现了Set接口</td>
</tr>
<tr>
<td>HashMap储存键值对</td>
<td>HashSet仅仅存储对象</td>
</tr>
<tr>
<td>使用put()方法将元素放入map中</td>
<td>使用add()方法将元素放入set中</td>
</tr>
<tr>
<td>HashMap中使用键对象来计算hashcode值</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap比较快，因为是使用唯一的键来获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody>
</table>

<p>如果你还知道其它的什么不同点，请留言。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-09-02-difference-between-hashmap-and-hashtable.html">HashMap和Hashtable的区别</a></h1>
			<p class="meta"><time datetime="2015-09-02T23:01:13+08:00" 
			pubdate data-updated="true">2015/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>HashMap和Hashtable的比较是Java面试中的常见问题，用来考验程序员是否能够正确使用集合类以及是否可以随机应变使用多种思路解决问题。HashMap的工作原理、ArrayList与Vector的比较以及这个问题是有关Java 集合框架的最经典的问题。Hashtable是个过时的集合类，存在于Java API中很久了。在Java 4中被重写了，实现了Map接口，所以自此以后也成了Java集合框架中的一部分。Hashtable和HashMap在Java面试中相当容易被问到，甚至成为了集合框架面试题中最常被考的问题，所以在参加任何Java面试之前，都不要忘了准备这一题。</p>

<p>这篇文章中，我们不仅将会看到HashMap和Hashtable的区别，还将看到它们之间的相似之处。</p>

<h3 id="toc_0">HashMap和Hashtable的区别</h3>

<p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>

<ol>
<li>HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。</li>
<li>HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</li>
<li>另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</li>
<li>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。</li>
<li>HashMap不能保证随着时间的推移Map中的元素次序是不变的。</li>
</ol>

<h3 id="toc_1">要注意的一些重要术语：</h3>

<p>1) sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。</p>

<p>2) Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</p>

<p>3) 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</p>

<h3 id="toc_2">我们能否让HashMap同步？</h3>

<p>HashMap可以通过下面的语句进行同步：<br/>
Map m = Collections.synchronizeMap(hashMap);</p>

<h3 id="toc_3">结论</h3>

<p>Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-08-27-why-character-array-is-better-than.html">为什么存储密码字符数组比字符串更合适？</a></h1>
			<p class="meta"><time datetime="2015-08-27T22:49:24+08:00" 
			pubdate data-updated="true">2015/8/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>“为什么存储密码用字符数组比字符串更合适”这个问题是我的一个朋友在最近一次面试中提到的。那哥们应聘的是一个技术lead职位，有超过六年的工作经验。字符数组和字符串都可以用于存储文本数据，但是在选择具体哪一种时，如果你没有针对具体的情况是很难回答这个问题的。但是正如这哥们说的任何与字符串相关的问题一定可以从字符串的属性里面的线索中找到，比如不可变性。他就用这种方式去说服面试官的。这里我们就来探讨一些关于为什么你应该使用char[] 来存储密码而不是字符串。</p>

<ol>
<li><p>因为字符串是不可变对象，如果作为普通文本存储密码，那么它会一直存在内存中直至被垃圾收集器回收。因为字符串从字符串池中取出的（如果池中有该字符串就直接从池中获取，否则new 一个出来，然后把它放入池中），这样有很大的机会长期保留在内存中，这样会引发安全问题。因为任何可以访问内存的人能以明码的方式把密码dump出来。另外你还应该始终以加密而不是普通的文本来表示密码。因为字符串是不可变，因此没有任何方法可以改变其内容，任何改变都将产生一个新的字符串，而如果使用char[]，你就可以设置所有的元素为空或者为零（这里作者的意思是说，让认证完后该数组不再使用了，就可以用零或者null覆盖原来的密码，防止别人从内存中dump出来）。所以存储密码用字符数组可以明显的减轻密码被盗的危险。</p></li>
<li><p>Java官方本身也推荐字符数组，JpasswordField的方法getPassword()就是返回一个字符数组，而由于安全原因getText()方法是被废弃掉的，因为它返回一个纯文本字符串。跟随Java 团队的步伐吧，没有错。</p></li>
<li><p>字符串以普通文本打印在在log文件或控制台中也易引起危险，但是如果使用数组你不能打印数组的内容，而是它的内存地址。尽管这不是它的真正原因，但仍值得注意。</p></li>
</ol>

<pre><code>String strPassword=&quot;Unknown&quot;;
char[] charPassword= new char[]{&#39;U&#39;,&#39;n&#39;,&#39;k&#39;,&#39;w&#39;,&#39;o&#39;,&#39;n&#39;};
System.out.println(&quot;String password: &quot; + strPassword);
System.out.println(&quot;Character password: &quot; + charPassword);
 
String password: Unknown
Character password: [C@110b053
</code></pre>

<p>以上所有就是为什么字符数组比字符串保存密码要好的原因，尽管使用char[]还不足以安全。我同样建议你用hash或者密码加密代替普通文本，而且一旦认证完成尽可能快的把他清除掉。</p>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_2.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2016-12-29-wechat-small-app.html">张小龙首次公开解读小程序：1月9号上线</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-27-benefits-and-pitfalls-of-micro-service.html">微服务的好处和陷阱</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-02-douban-rexxar.html">Rexxar：豆瓣对混合开发的思考</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-10-31-close-wait-problem.html">CLOSE_WAIT 问题分析</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-10-08-swift-sizeof-into-memorylayout.html">Swift 3：sizeof移进MemoryLayout</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>