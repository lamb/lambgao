
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-02-16-golang-get-user-home-dir.html">Golang 获取用户 home 目录路径</a></h1>
			<p class="meta"><time datetime="2015-02-16T23:34:06+08:00" 
			pubdate data-updated="true">2015/2/16</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">os/user</h3>

<p>一般情况下我们可以使用 os/user 包提供的 Current() 函数来获取用户信息：</p>

<pre><code>user, err := user.Current()
if nil == err {
    return user.HomeDir, nil
}
</code></pre>

<p>但这个方式交叉编译后不能完全跨平台，在 darwin 下需要 cgo 才能正常工作。</p>

<h3 id="toc_1">改进</h3>

<p>为了解决这个问题，我们需要进行一点增强，在通过 os/user 获取失败时再通过环境变量、命令来获取：</p>

<pre><code>// Home returns the home directory for the executing user.
//
// This uses an OS-specific method for discovering the home directory.
// An error is returned if a home directory cannot be detected.
func Home() (string, error) {
    user, err := user.Current()
    if nil == err {
        return user.HomeDir, nil
    }

    // cross compile support
    
    if &quot;windows&quot; == runtime.GOOS {
        return homeWindows()
    }

    // Unix-like system, so just assume Unix
    return homeUnix()
}

func homeUnix() (string, error) {
    // First prefer the HOME environmental variable
    if home := os.Getenv(&quot;HOME&quot;); home != &quot;&quot; {
        return home, nil
    }

    // If that fails, try the shell
    var stdout bytes.Buffer
    cmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, &quot;eval echo ~$USER&quot;)
    cmd.Stdout = &amp;stdout
    if err := cmd.Run(); err != nil {
        return &quot;&quot;, err
    }

    result := strings.TrimSpace(stdout.String())
    if result == &quot;&quot; {
        return &quot;&quot;, errors.New(&quot;blank output when reading home directory&quot;)
    }

    return result, nil
}

func homeWindows() (string, error) {
    drive := os.Getenv(&quot;HOMEDRIVE&quot;)
    path := os.Getenv(&quot;HOMEPATH&quot;)
    home := drive + path
    if drive == &quot;&quot; || path == &quot;&quot; {
        home = os.Getenv(&quot;USERPROFILE&quot;)
    }
    if home == &quot;&quot; {
        return &quot;&quot;, errors.New(&quot;HOMEDRIVE, HOMEPATH, and USERPROFILE are blank&quot;)
    }

    return home, nil
}
</code></pre>

<h3 id="toc_2">参考</h3>

<ul>
<li><a href="http://stackoverflow.com/questions/7922270/obtain-users-home-directory">Obtain user’s home directory</a></li>
<li><a href="https://github.com/mitchellh/go-homedir">go-homedir</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-02-10-java-web-framework-dev-fundamentals.html">Java Web 框架开发基础</a></h1>
			<p class="meta"><time datetime="2015-02-10T23:30:09+08:00" 
			pubdate data-updated="true">2015/2/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">请求处理</h3>

<p>最常用也最简单的分发原理是根据请求 URI（request.getRequestURI()）来判断分发。</p>

<ul>
<li>一个请求处理方法可以接受多种请求 URI 的请求</li>
<li>支持 Ant 路径与正则表达式</li>
<li>请求方法指定（GET/POST/etc）</li>
</ul>

<p>@RequestProcessing(value = {&quot;/\d*&quot;, &quot;&quot;}, uriPatternsMode = URIPatternMode.REGEX, method = HTTPRequestMethod.GET)</p>

<p>在实现时，框架需要默认包含对上下文路径的处理，以便应用部署在非 ROOT 路径也能正常工作。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2015-02-10-java-web-framework-dev-fundamentals.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-01-20-how-stable-are-your-unit-tests-best-practices-to-raise-test-automation-quality.html">你的单元测试有多稳定？提升自动测试质量的最佳实践</a></h1>
			<p class="meta"><time datetime="2015-01-20T17:30:32+08:00" 
			pubdate data-updated="true">2015/1/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我们超过10K的单元测试大部分都是用JAVA的JUnit编写，并且用gradle自动构建工具运行。当我们添加越多的测试用例，就越频繁地遇到单元测试执行不稳定的问题。新添加的测试代码影响了现存的测试的执行。我们的”失败测试“(failed test)标准在它开始增加前一直表现地很不错。显然我们应该去抱怨那些糟糕的程序代码。但经过仔细的分析，我们发现造成不稳定的测试结果的真正原因。大多数由新测试造成的问题都是由于那些测试用例对测试环境作了一些不利的影响，因此也影响了其他测试的执行。</p>

<p>在这篇文章中，我会展示我们是怎么找出这些特定的失败测试的根因，并且由此得出的对测试环境友好的单元测试设计的最佳实践。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2015-01-20-how-stable-are-your-unit-tests-best-practices-to-raise-test-automation-quality.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-12-22-golang-linux-namespaces.html">使用 Golang 操作 Linux Namespaces</a></h1>
			<p class="meta"><time datetime="2014-12-22T23:15:39+08:00" 
			pubdate data-updated="true">2014/12/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">Linux 命名空间简介</h3>

<p>Linux Namespaces（Linux 命名空间）机制提供了进程使用操作系统资源时的隔离方式，是基于内核实现轻量级虚拟化（容器化，例如 docker）的实现基础。</p>

<p>具体来说就是当我们创建一个进程时，可以给进程设置 flag 组合来构建进程的命名空间，处于不同命名空间的进程是相互隔离的。</p>

<h3 id="toc_1">命名空间分类</h3>

<p>目前我们可以设置如下几种命名空间，它们分别从不同的资源纬度进行隔离。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-12-22-golang-linux-namespaces.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-11-26-docker-first-step.html">Docker 初探</a></h1>
			<p class="meta"><time datetime="2014-11-26T23:10:04+08:00" 
			pubdate data-updated="true">2014/11/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">原则</h3>

<ul>
<li>不是虚拟机，而是带独立文件系统、网络的进程（Container not VM）</li>
<li>如果在 container 中创建进程，则该进程跑在 host 上</li>
<li>使用非 root 用户运行容器（在 Dockerfile 中先创建用户）</li>
<li>Dockerfile 中尽量减少层，比如 RUN 后的命令进行 &amp;&amp; 合并</li>
</ul>

<h3 id="toc_1">安装</h3>

<p>使用 docker 官方在线脚本进行安装：curl -sSL <a href="https://get.docker.com/">https://get.docker.com/</a> | sh 或 wget -qO- <a href="https://get.docker.com/">https://get.docker.com/</a> | sh</p>

<h3 id="toc_2">docker run</h3>

<ul>
<li>-u {username} 以指定用户运行容器。为安全起见，一定不要用 root 用户跑容器。</li>
<li>在 Dockerfile 中 RUN useradd {username} 建立用户，host 上也建立一个相应用户。</li>
<li>-v /host:/container 挂载 host 目录到容器中，要挂载多个目录的话 -v 多次。</li>
<li>-p ip:hostPort:containerPort 将容器使用的端口暴露到 host 端口上，要暴露多个端口的话 -p 多次。</li>
</ul>

<h3 id="toc_3">体验</h3>

<ul>
<li>Docker 降低了应用的更新/部署难度，Dockerfile -&gt; Image -&gt; Pull -&gt; Run</li>
<li>Docker Hub 集成了 GitHub，项目代码提交后自动构建 Image</li>
<li>从 Docker Hub 上 pull 略慢，但总的来说效率还是高于手工部署的方式且不易出错</li>
<li>使用最新 Docker，以前的坑大（比如 1.2 前 pull 失败会 stop 容器）</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-11-20-watchkit-initial-impressions.html">WatchKit初探</a></h1>
			<p class="meta"><time datetime="2014-11-20T23:25:58+08:00" 
			pubdate data-updated="true">2014/11/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">整体功能预览</h3>

<p>总体而言，WatchKit第一版SDK提供的功能远远超出了我的期望。因为我原本以为第一版WatchKit可能侧重于对iOS Today Extension功能的延伸，而不是真正开发Watch App。所以当知道真相后，我即惊讶又感到高兴，第一版WatchKit并不是我所想的那样，它可以为Watch App创建全新的交互界面，而且可以通过iOS App Extension去控制他们。</p>

<p><img src="/resource/image/2014-11-20-watchkit-initial-impressions/1.jpg" alt="image1"/></p>

<p>所以我们能做的并不只是一个简单的所谓iOS Apple Watch Extension的玩意，而是有很多新的功能需要我们去挖掘。目前提供的比如特定的UI控制方式 、Glance、可自定义的Notification、和Handoff的深度结合、图片缓存等等，作为开发者，这些功能已经让我为之兴奋了。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-11-20-watchkit-initial-impressions.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-10-21-swift-failable-initializers.html">Swift 可失败构造器（Failable Initializers）</a></h1>
			<p class="meta"><time datetime="2014-10-21T23:18:46+08:00" 
			pubdate data-updated="true">2014/10/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Xcode6.1中Swift的最新版本是1.1，在该版本中引入了一个新的特性：可失败构造器。通过构造器初始化实际上是给class或struct的每一个存储属性（参数）提供初始值，进行对象实例化的过程。在一些情况下，初始化的过程是有可能失败的。比如，实例化一个对象，在实例化的过程中需要访问资源文件，就像从文件中加载图片一样：</p>

<pre><code>NSImage(contentsOfFile: &quot;swift.png&quot;)
</code></pre>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-10-21-swift-failable-initializers.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-10-21-linux-kernel-network-turning.html">Linux 内核网络参数</a></h1>
			<p class="meta"><time datetime="2014-10-21T23:08:57+08:00" 
			pubdate data-updated="true">2014/10/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>net.ipv4.tcp_fin_timeout：表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间</li>
<li>net.ipv4.tcp_keepalive_time：表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时</li>
<li>net.ipv4.tcp_mem：第一个数字表示，当 tcp 使用的 page 少于该值时，kernel 不对其进行任何的干预；第二个数字表示，当 tcp 使用了超过该值的 pages 时，kernel 会进入 “memory pressure” 压力模式；第三个数字表示，当 tcp 使用的 pages 超过该值时会报：Out of socket memory</li>
<li>net.ipv4.tcp_tw_reuse：表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</li>
<li>net.ipv4.tcp_timestamps：表示是否启用以一种比超时重发更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项</li>
<li>net.ipv4.tcp_synack_retries：参数的值决定了内核放弃连接之前发送SYN+ACK包的数量</li>
<li>net.ipv4.tcp_syn_retries：表示在内核放弃建立连接之前发送SYN包的数量</li>
<li>net.ipv4.tcp_tw_recycle：用于设置启用timewait快速回收</li>
<li>net.ipv4.tcp_max_tw_buckets：用来设定timewait的数量 net.ipv4.ip_local_port_range：用来设定允许系统打开的端口范围</li>
<li>net.core.rmem_max：最大的TCP数据接收窗口（字节）</li>
<li>net.core.wmem_max：最大的TCP数据发送窗口（字节）</li>
<li>net.core.netdev_max_backlog：在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</li>
<li>net.core.somaxconn：定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数</li>
<li>net.ipv4.tcp_max_orphans：用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立连接将立即被复位并打印出警告信息。这个限制只是为了防止简单的DoS攻击。不能过分依靠这个限制甚至人为减小这个值，更多的情况下应该增加这个值</li>
<li>net.ipv4.tcp_max_syn_backlog：对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字</li>
<li>net.core.wmem_default：默认的TCP数据发送窗口大小（字节）</li>
<li>net.core.rmem_default：默认的TCP数据接收窗口大小（字节）</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-10-08-tuple-in-swift.html">Swift中的元组（Tuples）</a></h1>
			<p class="meta"><time datetime="2014-10-08T23:11:55+08:00" 
			pubdate data-updated="true">2014/10/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">创建元组</h3>

<p>在Swift中创建元组的方式很简单，它的语法有点类似数组，但是需要把方括号替换为圆括号：</p>

<pre><code>let firstHighScore = (&quot;Mary&quot;, 9001)
</code></pre>

<p>与数组不同的是，元组中的元素可以是任意类型。上面代码中firstHighScore元组就包含一个String类型的元素和一个Int类型的元素。</p>

<p>另外，在创建元组时你还可以给元组中的元素命名：</p>

<pre><code>let secondHighScore = (name: &quot;James&quot;, score: 4096)
</code></pre>

<p>这样可以让我们在使用元组的时候明确的指定某个元素，非常有用。在后面的文章中大家可以看到给元素命名的好处。</p>

<p>以上就是创建元组的两种方式，非常简单和简洁。你不需要像创建struct一样写出它的结构和内部属性，也不需要像创建class一样要写初始化方法。你只需要把你想用的、任何类型的值放在圆括号内，用逗号隔开即可。如果你愿意你还可以给每个元素命名，提高元组使用效率。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-10-08-tuple-in-swift.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-18-write-doc-via-gitbook.html">使用 GitBook 写文档</a></h1>
			<p class="meta"><time datetime="2014-09-18T23:05:19+08:00" 
			pubdate data-updated="true">2014/9/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>最近发现很多技术书籍都放在 GitBook 上提供给人们阅读，刚好 Wide 也需要写文档，索性就尝试使用 GitBook 来做。</p>

<h3 id="toc_0">GitBook 简介</h3>

<p>GitBook 是一个通过 Git 和 Markdown 来撰写书籍的工具，最终可以生成 3 种格式：</p>

<ul>
<li>静态站点：包含了交互功能（例如搜索、书签）的站点</li>
<li>PDF：PDF 格式的文件</li>
<li>eBook：ePub 格式的电子书文件</li>
</ul>

<p>GitBook 是免费且开源的，项目地址：<a href="https://github.com/GitbookIO/gitbook">https://github.com/GitbookIO/gitbook</a></p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-09-18-write-doc-via-gitbook.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-11-swift-final.html">Swift中的final修饰符</a></h1>
			<p class="meta"><time datetime="2014-09-11T23:08:41+08:00" 
			pubdate data-updated="true">2014/9/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Swift中的final修饰符可以防止类（class）被继承，还可以防止子类重写父类的属性、方法以及下标。需要注意的是，final修饰符只能用于类，不能修饰结构体（struct）和枚举（enum），因为结构体和枚举只能遵循协议（protocol）。虽然协议也可以遵循其他协议，但是它并不能重写遵循的协议的任何成员，这就是结构体和枚举不需要final修饰的原因。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-09-11-swift-final.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-02-optionals-case-study.html">Swift中Optional类型的使用案例分析：valuesForKeys</a></h1>
			<p class="meta"><time datetime="2014-09-02T22:53:15+08:00" 
			pubdate data-updated="true">2014/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这篇文章将带我们探索在Swift中如何使用Optional类型保证强类型的安全性。我们将创建一个Swift版本的Objective-C的API。虽然在Swift中这个API存在的意义不是很大，但是这将会是一个很有趣的例子。</p>

<p>在Objective-C中，NSDictionary类有一个方法，名为-objectsForKeys:notFoundMarker:，它的作用是根据第一个NSArray类型参数中的值作为该字典的key，查找这些key对应的字典中的值，并放到一个新的NSArray中返回，如果找不到对应的值，那么就返回第二个参数指定的对象。在官方文档中对该方法有这么一句描述“返回的数组中的第N个对象，对应着第一个数组参数中的第N个值”。假如说以第一个数组参数中的第三个值作为key在字典中查不到值怎么办呢？这时候就需要notFoundMarker参数登场了。这种情况下就会返回notFoundMarker参数指定的对象了。在Foundation框架中还有专门针对该情况适用的一个类，那就是NSNull，就是当你也没有备选返回对象的时候，就可以返回NSNull对象。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-09-02-optionals-case-study.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-01-closure-expressions-in-swift.html">Swift中的闭包（Closure）</a></h1>
			<p class="meta"><time datetime="2014-09-01T22:57:30+08:00" 
			pubdate data-updated="true">2014/9/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>闭包在Swift中非常有用。通俗的解释就是一个Int类型里存储着一个整数，一个String类型包含着一串字符，同样，闭包是一个包含着函数的类型。有了闭包，你就可以处理很多在一些古老的语言中不能处理的事情。这是因为闭包使用的多样性，比如你可以将闭包赋值给一个变量，你也可以将闭包作为一个函数的参数，你甚至可以将闭包作为一个函数的返回值。它的强大之处可见一斑。</p>

<p>在Swift的很多文档教材中都说函数是“一等公民”，起初我还不是很理解“一等公民”是什么意思，但当我理解了闭包以及它的强大功能后，我恍然大悟、茅塞顿开、醍醐灌顶。原来闭包的这些特性就是“一等公民”的特性啊！参见维基百科<a href="http://en.wikipedia.org/wiki/First-class_citizen">First-class citizen</a>。</p>

<p>Swift中的闭包类似Objective-C中的Block。其实，如果你想在Swift中实现Objective-C里的Block功能，你可以直接使用闭包来代替。Block和闭包的区别只是语法的不同而已，而且闭包的可读性比较强。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-09-01-closure-expressions-in-swift.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-27-change-ubuntu-display-resolution.html">修改 Ubuntu 分辨率</a></h1>
			<p class="meta"><time datetime="2014-08-27T23:02:01+08:00" 
			pubdate data-updated="true">2014/8/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>通常我们可以在 Settings -&gt; Hardware -&gt; Display 中选择适合的分辨率，但有些情况下这里没有列出合适的分辨率，此时我们可以通过命令调整显示分辨率。</p>

<ol>
<li><p>先通过 xrandr 获取当前的显示设备名</p></li>
<li><p>然后通过 cvt 命令获取需要的显示模式编辑行</p></li>
<li><p>新建显示模式 xrandr --newmode &quot;1368x768_60.00&quot; 85.25 1368 1440 1576 1784 768 771 781 798 -hsync +vsync</p></li>
<li><p>添加显示模式 xrandr --addmode VBOX0 &quot;1368x768_60.00&quot;</p></li>
<li><p>应用显示模式 xrandr --output VBOX0 --mode &quot;1368x768_60.00&quot;</p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-18-swift-value-and-reference-types.html">Swift中的值类型和引用类型</a></h1>
			<p class="meta"><time datetime="2014-08-18T22:49:02+08:00" 
			pubdate data-updated="true">2014/8/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Swift中，类型分为两类：第一种是值类型，该类型的每个实例持有数据的副本，并且该副本对于每个实例来说是独一无二的一份，比如结构体（struct）、枚举（enum）、元组（tuple）都是值类型。第二种是参照类型，该类型的实例共享数据唯一的一份副本（在native层面说的话，就是该类型的每个实例都指向内存中的同一个地址），比如类（class）就是参照类型。在这篇文章中，我们将深入探讨值类型和参照类型的使用价值，以及如何在某种场景下选择正确的类型。</p>



		</div>

		 
		 <footer>
      	<a rel="full-article" href="2014-08-18-swift-value-and-reference-types.html#more">read more &rarr;</a>
    	</footer>
    	

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_4.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_2.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2016-12-29-chrome-plugin.html">Chrome插件：网易云音乐一键全赞</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-29-wechat-small-app.html">张小龙首次公开解读小程序：1月9号上线</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-27-benefits-and-pitfalls-of-micro-service.html">微服务的好处和陷阱</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-02-douban-rexxar.html">Rexxar：豆瓣对混合开发的思考</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-10-31-close-wait-problem.html">CLOSE_WAIT 问题分析</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>