
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  金氧
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="金氧" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/solarized_light.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>

  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">金氧</a></h1>
  
    <h2></h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:lambgao.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

  <li id=""><a target="_blank" href="https://github.com/lamb">Github@Lamb</a></li>

  <li id=""><a target="_blank" href="https://twitter.com/lambgao">Twitter@Lamb</a></li>

  <li id=""><a target="_blank" href="http://weibo.com/lambsand">微博@金氧</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-02-10-java-web-framework-dev-fundamentals.html">Java Web 框架开发基础</a></h1>
			<p class="meta"><time datetime="2015-02-10T23:30:09+08:00" 
			pubdate data-updated="true">2015/2/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">请求处理</h3>

<p>最常用也最简单的分发原理是根据请求 URI（request.getRequestURI()）来判断分发。</p>

<ul>
<li>一个请求处理方法可以接受多种请求 URI 的请求</li>
<li>支持 Ant 路径与正则表达式</li>
<li>请求方法指定（GET/POST/etc）</li>
</ul>

<p>@RequestProcessing(value = {&quot;/\d*&quot;, &quot;&quot;}, uriPatternsMode = URIPatternMode.REGEX, method = HTTPRequestMethod.GET)</p>

<p>在实现时，框架需要默认包含对上下文路径的处理，以便应用部署在非 ROOT 路径也能正常工作。</p>

<h3 id="toc_1">请求与响应</h3>

<p>对于请求的处理是分为两部分的：操作（Action）、渲染（Render）。<br/>
操作部分相当于业务逻辑实现，例如入参校验，服务调用；渲染部分则是针对响应对象的，是需要进行统一抽象的。</p>

<p>通过渲染器进行响应输出，渲染器主要逻辑包括：</p>

<ul>
<li>设置响应头</li>
<li>生成响应内容</li>
<li>渲染，即 Response 写回</li>
</ul>

<p>应该提供多种响应渲染器（例如 HTML、图片、JSON 等），方便应用直接使用。</p>

<p>另外，为了方便扩展渲染器，可以提供模版方法 beforeRender 和 afterRender。</p>

<h3 id="toc_2">模版处理</h3>

<p>模版引擎有两个接口最为常用：</p>

<ul>
<li>模版目录加载设置</li>
<li>获取模版</li>
</ul>

<p>应用调用模版目录加载设置接口确定模版文件目录，如果有动态切换场景（例如换皮肤），则也调用该接口。实现时这个接口必须使用 ServletContex 作为参数来定位当前运行的 Web 应用，因为用户在部署 WAR 时可能会不展开，此时使用 Servlet API 是获取不到正确的 WAR 绝对路径的。</p>

<p>另外，框架可提供一个 boolean hasExpression(Template template, String expression) 接口，用于判断指定的模版中是否定义了某个表达式。<br/>
这个接口可用于应用实现一些灵活的“按需加载”功能，没有表达式就执行业务逻辑实现（不加载/组装数据），方便应用进行特殊逻辑处理或性能优化。</p>

<h3 id="toc_3">事件机制</h3>

<p>事件机制本质上是观察者模式的实现，需要包含同步事件和异步事件。框架本身提供一些内置的事件，用于扩展解耦。</p>

<h3 id="toc_4">扩展点</h3>

<p>扩展点可以使用模版方法实现或事件机制实现的。框架在请求-响应这个主流程不同阶段的处理中应该提供一些扩展点，例如：</p>

<ul>
<li>请求处理前</li>
<li>服务调用前、后</li>
<li>数据存取（Datastore，SQL）执行前、后</li>
<li>渲染前、渲染后</li>
<li>请求处理后</li>
<li>自动缓存清空前</li>
</ul>

<p>在请求-响应处理顶层流程中，提供模版方法进行分发、渲染等逻辑的接口，这样方便与其他框架对接；<br/>
而在具体的渲染逻辑中则可以触发事件，方便框架用户进行事件监听并扩展。</p>

<h3 id="toc_5">依赖注入</h3>

<p>单例生存周期的依赖注入必不可少，其他生存周期（请求、会话等）不常用，因为有状态的服务端设计并不常用。</p>

<p>容器管理对象后，通过动态代理实现 AOP，为声明式事务管理、方法调用织入提供基础。</p>

<h3 id="toc_6">插件</h3>

<p>插件执行是事件触发的，相同的事件类型一次可以触发多个插件执行，执行顺序按照插件注册顺序。</p>

<p>插件是需要可以完成完整业务功能的，包括了服务端逻辑执行、视图渲染、 插件数据存储等。</p>

<h3 id="toc_7">ORM</h3>

<p>不要过度设计和封装（反面教材 Hibernate，正面教材 MyBatis），但需要提供：</p>

<ul>
<li>连接池切换机制</li>
<li>连接获取接口</li>
<li>编程式/声明式事务，可配置传播属性</li>
</ul>

<p>实现时进行简单的数据行-对象映射处理即可，CRUD 和简单 Query 可以支持大部分业务场景，较复杂的业务可以直接上 SQL。</p>

<h3 id="toc_8">工具</h3>

<ul>
<li>分页、ID 生成、序列化、反射、堆栈、秒表等</li>
<li>日志库封装</li>
<li>缓存、HTTP Client、邮件、任务队列、定时任务、图片处理等</li>
</ul>

<h3 id="toc_9">构建</h3>

<p>在构建阶段，框架需要做字节码增强，例如一些注解的功能实现。<br/>
除此以外，框架可以提供一些构建工具，例如静态资源压缩合并插件。</p>

<h3 id="toc_10">错误页面处理</h3>

<p>Servlet 规范本身已经定义了统一的错误页面处理（web.xml <error-page>）机制，框架的请求分发逻辑中可以通过<br/>
request.getAttribute(&quot;javax.servlet.error.status_code&quot;); 来判断是否是错误页面的请求。</p>

<h3 id="toc_11">容器兼容</h3>

<p>虽然容器都是实现 Servlet 规范的，但是一些细节还是不相同，需要框架做统一处理：</p>

<ul>
<li>有可能需要考虑容器的虚拟文件系统实现（例如 jboss-vfs）</li>
<li>有些容器自带了依赖注入 CDI 实现，可能会与框架实现冲突</li>
<li>静态资源转发使用容器的性能更好，但是不同容器的 Servlet 处理不同 （Default Servlet Name）</li>
</ul>

<h3 id="toc_12">参考</h3>

<ul>
<li>Servlet 规范、依赖注入规范等</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2015-01-20-how-stable-are-your-unit-tests-best-practices-to-raise-test-automation-quality.html">你的单元测试有多稳定？提升自动测试质量的最佳实践</a></h1>
			<p class="meta"><time datetime="2015-01-20T17:30:32+08:00" 
			pubdate data-updated="true">2015/1/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>我们超过10K的单元测试大部分都是用JAVA的JUnit编写，并且用gradle自动构建工具运行。当我们添加越多的测试用例，就越频繁地遇到单元测试执行不稳定的问题。新添加的测试代码影响了现存的测试的执行。我们的”失败测试“(failed test)标准在它开始增加前一直表现地很不错。显然我们应该去抱怨那些糟糕的程序代码。但经过仔细的分析，我们发现造成不稳定的测试结果的真正原因。大多数由新测试造成的问题都是由于那些测试用例对测试环境作了一些不利的影响，因此也影响了其他测试的执行。</p>

<p>在这篇文章中，我会展示我们是怎么找出这些特定的失败测试的根因，并且由此得出的对测试环境友好的单元测试设计的最佳实践。</p>

<h3 id="toc_0">这一切都因为缺少单元测试时间</h3>

<p>上个星期，我们发现一组测试没有毫无预兆就失败了。我自愿参加分析。</p>

<p>一组验证ThreadPool实现的重要且必须行为的单元测试。特别是，定时任务必须在特定异常抛出后继续运行。为了测试它，必须要有另外一个定时任务，抛出特定的异常。然后测试会在第一次因为异常失败后等待第二次执行。</p>

<p>在某些机器上运行这些测试，它们会在重新运行时超时。尽管有各种各样的异常处理器可以记录异常，但没有任何输出。只有这样一条消息输出：</p>

<pre><code>Exception: java.lang.NullPointerException thrown from the UncaughtExceptionHandler in thread “pool-unit-test-thread-1″
</code></pre>

<p>然后，在eclipse中运行时，这种情况永远都不可能重现，它只会出现在我们使用gradle来跑这些test的时候。</p>

<p>下一步：我配置gradle打开调试端口，然后使用eclipse连接以确定原因。这才发现NullPointerException是在gradle的某处代码中抛出。我下载了源代码，发现System.getProperty(“line.separator”)返回null，并且被取消引用。</p>

<p>有了这些信息，我检查代码，并且迅速发现另外一个校验不同平台上的字符串格式的测试在修改line.separtor属性时有不良影响。在测试完成后调用的System.clearProperty(“line.separator”)，它无意中把该属性设置为null。在这种情况下，当下个测试运行时，由于它使用System.setOut重定向到控制台输出，日志信息会被写出到控制台，gradle代码会被调用。这种顺序的调用会导致gradle在获取line.separator属性值是抛出NullPointerException。注意，执行的顺序很重要，因此在ThreadPool测试时只是偶尔会出现。</p>

<p>通常一系列的处理器都可以捕获到它，但由于它们也写出到控制台，当它们遇到NullPointerException时，会向上抛出。</p>

<p>这个错误的快速的解决方式是去除clearProperty这个调用，而换用上一个line.separator属性的值。但我们是否可以做到更好呢？</p>

<h3 id="toc_1">单元测试的副作用</h3>

<p>上面的部分错误是本来并且应该由测试自动化去处理的，JVM通常会重用同一个项目内的对象。因此理想情况下的单元测试应该对测试环境没有副作用，可以避免类似的错误。</p>

<p>测试环境包括各种可以影响之后执行的测试的资源，如在文件系统中创建文件或者上面的情况，修改java系统属性。对于文件类的，Junit提供了TemporaryFolder规则用于创建临时文件，所以我们这里开发了一个属性的类似机制。</p>

<p>解决方案：单元测试中恰当使用系统属性</p>

<p>通常情况下，假设我们要开发一个测试用例，需要设置Java系统变量为一个特定值，可能会如下：</p>

<p>Test.java</p>

<pre><code>@Before
public void setup() {
  System.setProperty(&quot;prop&quot;, &quot;true&quot;);
}
@Test
// use that prop.
</code></pre>

<p>但当其他在其之后运行的测试都运行在同一个JVM下，这个属性值还是会保留被设的值，并且会影响在后面运行的测试用例行为。所以，让我们来改进一下：</p>

<p>Test.java</p>

<pre><code>private String oldValue;
@Before
public void setup() {
  // setProperty returns the old value of that property.
  oldValue = System.setProperty(&quot;prop&quot;, &quot;true&quot;);
}
 
@After
public void teardown() {
  System.setProperty(&quot;prop&quot;, oldValue);
}
@Test
// use that prop..
</code></pre>

<p>看起来挺不错吧，不是吗？但还是存在一个问题：如果属性值没有设置，在setup中的setProperty返回null，而teardown会抛出一个NullPointerException。所以正确的使系统属性维持不变的单元测试应该是：</p>

<p>Test.java</p>

<pre><code>private String oldValue;
@Before
public void setup() {
  // setProperty returns the old value of that property.
  oldValue = System.setProperty(&quot;prop&quot;, &quot;true&quot;);
}
 
@After
public void teardown() {
  if( oldValue == null ) {
    System.clearProperty(&quot;prop&quot;);
  } else {
    System.setProperty(&quot;prop&quot;, oldValue);
  }
}
@Test
// Use that property..
</code></pre>

<p>这会有点啰嗦..基于Java 7的try-with-resources 语句的帮助类实现了同样的功能：</p>

<p>Test.java</p>

<pre><code>private ScopedProperty property;
@Before
public void setup() {
  property = new ScopedProperty(&quot;prop&quot;, &quot;true&quot;);
}
@After
public void teardown() {
  // Does same things like above.
  property.close();
}
@Test
// use that prop..
</code></pre>

<p>或者：</p>

<p>Test.java</p>

<pre><code>@Test
public void test() {
  try(ScopedProperty prop = new ScopedProperty(&quot;prop&quot;, &quot;true&quot;)) {
    // use that prop..
  }
}
</code></pre>

<p>当然，最好还是直接实现Junit规则，在这种情况下你不需要写@After。例如：</p>

<p>Test.java</p>

<pre><code>@ClassRule
public static ScopedPropertyRule prop = new ScopedPropertyRule(&quot;prop&quot;, &quot;true&quot;);
@Test
public void test1() {
 // use that prop..
}
@Test
public void test2() {
// use that prop..}
</code></pre>

<p>属性在@BeforeClass中进行设置，但会在@AfterClass中恢复成原始的状态。</p>

<p>结论：无副作用的测试可以提升自动化测试质量</p>

<p>要避免由于执行顺序引起的测试错误，单元测试必须做到没有副作用。现实世界的例子中证明这个话题的关联性。更深入这个练习，我们开发了一些用于系统属性的帮助类。相同的原理同样适用于其他环境对象，例如线程属性，Java安全管理器和类似ScopedProperty和ScopedPropertyRule之类的类，这些都可以很容易的实现。当我们在不断努力提升自动测试测试质量时，我对其他最佳实践保持兴趣。给我们留言，说一下你在开发团队里面的工作。（感谢Reinhold Füreder对Junit规则的引入!）</p>

<h3 id="toc_2">附录</h3>

<p>ScopedProperty.java</p>

<pre><code>/**
  * A helper to switch a system property value and restore the previous one.
  *
  * When used in try-with-resources, restores the values automatically.
  */
public class ScopedProperty implements AutoCloseable {
 
    private final String key;
    private final String oldValue;
 
  /**
     *
     * @param key The System.setProperty key
     * @param value The System.setProperty value to switch to.
     */
    public ScopedProperty(final String key, final String value) {
        this.key = key;
        oldValue = System.setProperty(key, value);
    }
 
    @Override
    public void close() {
        // Can&#39;t use setProperty(key, null) -&gt; Throws NullPointerException.
        if( oldValue == null ) {
            // Previously there was no entry.
            System.clearProperty(key);
        } else {
            System.setProperty(key, oldValue);
        }
    }
}
</code></pre>

<p>这里的ScopedProperty实现了AutoCloseable来完成try-with-ressouces语句</p>

<p>ScopedPropertyRule.java</p>

<pre><code>/**
 * A JUnit test rule, which changes a property value within a test
 * and restores the original one afterwards.
 * See {@link ScopedProperty}.
 */
public class ScopedPropertyRule extends ExternalResource {
 
    private final String key;
    private final String value;
    private ScopedProperty scopedProperty;
 
    public ScopedPropertyRule(final String key, final String value) {
        this.key =key;
        this.value = value;
    }
 
    @Override
    protected void before() throws Throwable {
        scopedProperty = new ScopedProperty(key, value);
    }
 
    @Override
    protected void after() {
        scopedProperty.close();
    }
}
</code></pre>

<p>这个类使用了ExternalResource来实现Junit测试规则</p>

<p>原文链接： <a href="http://apmblog.compuware.com/2014/02/25/how-stable-are-your-unit-tests-best-practices-to-raise-test-automation-quality/">compuware</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-12-22-golang-linux-namespaces.html">使用 Golang 操作 Linux Namespaces</a></h1>
			<p class="meta"><time datetime="2014-12-22T23:15:39+08:00" 
			pubdate data-updated="true">2014/12/22</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">Linux 命名空间简介</h3>

<p>Linux Namespaces（Linux 命名空间）机制提供了进程使用操作系统资源时的隔离方式，是基于内核实现轻量级虚拟化（容器化，例如 docker）的实现基础。</p>

<p>具体来说就是当我们创建一个进程时，可以给进程设置 flag 组合来构建进程的命名空间，处于不同命名空间的进程是相互隔离的。</p>

<h3 id="toc_1">命名空间分类</h3>

<p>目前我们可以设置如下几种命名空间，它们分别从不同的资源纬度进行隔离。</p>

<h4 id="toc_2">CLONE_NEWPID</h4>

<p>该标识用于创建一个新的 PID 命名空间，新进程将成为命名空间里的第一个进程。</p>

<p>一个 PID 命名空间为进程提供了一个独立的 PID 环境，其内部的 PID 将从 1 开始，<br/>
在该命名空间内创建的进程都将产生一个在该命名空间内独立的 PID。后续在该命名空间创建的进程都将作为 PID=1 的进程的子进程，当该进程被结束时，该命名空间内所有的进程都会被结束。</p>

<p>PID 命名空间是层次性的，如果新创建一个命名空间，则该命名空间将会是创建该命名空间的进程属于的命名空间的子命名空间。子命名空间中的进程对于父命名空间是可见的，一个进程将拥有不止一个 PID，在其所在的命名空间以及所有直系祖先命名空间中都将有一个 PID。</p>

<p>系统启动时，内核将创建一个默认的 PID 命名空间，该命名空间是所有以后创建的命名空间的祖先，因此系统所有的进程在该命名空间都是可见的。</p>

<h4 id="toc_3">CLONE_NEWIPC</h4>

<p>该标识创建一个新的 IPC 命名空间，新进程将成为命名空间里的第一个进程。</p>

<p>一个 IPC 命名空间有一组 System V IPC objects 标识符构成，这标识符由 IPC 相关的系统调用创建。</p>

<p>在一个 IPC 命名空间里面创建的 IPC object 对该命名空间内的所有进程可见，但是对其他命名空间不可见。这样就使得不同命名空间之间的进程不能直接通信，就像是在不同的系统里一样。当一个 IPC 命名空间被销毁，该命名空间内的所有 IPC object 会被内核自动销毁。</p>

<p>PID 命名空间和 IPC 命名空间可以组合起来一起使用，只需在创建进程时，同时指定 CLONE_NEWPID和 CLONE_NEWIPC，这样新创建的命名空间既是一个独立的 PID 空间又是一个独立的 IPC 空间。不同命名空间中的进程彼此不可见，也不能互相通信，这样就实现了进程的运行时隔离。</p>

<h4 id="toc_4">CLONE_NEWNS</h4>

<p>该标识创建了一个新的 mount 命名空间。</p>

<p>每个进程都存在于一个 mount 命名空间里面，mount 命名空间为进程提供了一个文件层次视图。如果不设定这个标识，子进程和父进程将共享一个 mount 命名空间，其后子进程调用 mount 或 umount 将会影响到所有该命名空间内的进程。如果子进程在一个独立的 mount 命名空间里面，就可以调用 mount 或 umount 建立一份新的文件层次视图。</p>

<p>该标识配合 pivot_root 系统调用，可以为进程创建一个独立的目录空间。</p>

<h4 id="toc_5">CLONE_NEWNET</h4>

<p>该标识创建了一个新的 Network 命名空间，为进程提供了一份独立的网络环境，就跟一个独立的系统网络一样。包括网络设备接口，IPv4 和 IPv6 协议栈，IP 路由表，防火墙规则，sockets 等等。</p>

<p>虚拟网络设备（virtual network device）提供了一种类似管道的抽象，可以在不同的命名空间之间建立隧道。利用虚拟化网络设备，可以建立到其他命名空间中的物理设备的桥接。</p>

<p>当一个 Network 命名空间被销毁时，物理设备会被自动移回 init Network 命名空间，即系统最开始的命名空间。</p>

<h4 id="toc_6">CLONE_NEWUTS</h4>

<p>该标识创建了一个新的 UTS 命名空间。一个 UTS 命名空间就是一组被 uname 返回的标识符。</p>

<p>新的 UTS 命名空间中的标识符通过复制调用进程所属的命名空间的标识符来初始化。新创建的进程可以通过相关系统调用改变这些标识符，比如调用 sethostname 来改变该命名空间的 hostname。这一改变对该命名空间内的所有进程可见。</p>

<p>CLONE_NEWUTS 和 CLONE_NEWNET 一起使用，可以虚拟出一个有独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。</p>

<h4 id="toc_7">CLONE_NEWUSER</h4>

<p>该标识创建了一个新的 User 命名空间，用于隔离用户和用户组 ID。</p>

<p>换句话说，同一个进程的 uid 和 gid 在命名空间内外可以不同。就是说，host 环境下的普通用户可以是某个命名空间的 root 用户，以此来完成一些需要 root 权限的操作。</p>

<h3 id="toc_8">代码示例</h3>

<p>上述命名空间可以进行组合使用，全部使用的话相当于完整的进程隔离。在介绍完概念后，下面我们来介绍在 Golang 中为进程设置命名空间的方法。</p>

<p>syscall、os/exec 对 Linux 命名空间的支持是 Go 1.4 引入的，细节请参考该 <a href="https://github.com/golang/go/issues/8447">issue</a>。</p>

<pre><code>import (
    &quot;os/exec&quot;
    &quot;syscall&quot;
)

func setNamespace(cmd *exec.Cmd) {
    // XXX: keep move with Go 1.4 and later&#39;s

    cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
    cmd.SysProcAttr.Cloneflags = syscall.CLONE_NEWUSER | syscall.CLONE_NEWNS | syscall.CLONE_NEWUTS | syscall.CLONE_NEWPID | syscall.CLONE_NEWIPC | syscall.CLONE_NEWNET
    cmd.SysProcAttr.Credential = &amp;syscall.Credential{
        Uid: 0,
        Gid: 0,
    }

    cmd.SysProcAttr.UidMappings = []syscall.SysProcIDMap{{ContainerID: 0, HostID: 1001, Size: 1}}
    cmd.SysProcAttr.GidMappings = []syscall.SysProcIDMap{{ContainerID: 0, HostID: 1001, Size: 1}}
}
</code></pre>

<p>上面的示例代码将待执行的 cmd 放到一个完全新的命名空间中，并设置该进程在新命名空间中以 root 用户执行。而这个 root 用户则是映射到 host 上用户 id 为 1001、组 id 为 1001 的用户。</p>

<p>这样是为了：</p>

<ul>
<li>cmd 是以 root 执行的</li>
<li>cmd 在 host 上权限受限于 uid=1001、gid=1001</li>
</ul>

<p>也就相当于 cmd 进程认为自己是以 root 执行的，但其实最终的操作受制于 1001 这个用户。</p>

<h3 id="toc_9">总结</h3>

<p>Linux 命名空间历时 10 多年时间（2002-2013）陆续实现了 6 个命名空间，从而使进程在使用操作系统资源时的隔离成为可能。</p>

<p>Go 1.4 加入了对命名空间的支持，使我们可以在创建进程是通过设置克隆标识（CLONE_XXX）组合来实现进程命名空间设置。</p>

<p>命名空间支持对于一些应用场景非常有效，例如需要在服务器上执行用户自编程序，启动这些可能不安全的程序进程时通过设置命名空间而进行安全隔离。</p>

<h3 id="toc_10">参考</h3>

<ul>
<li><a href="http://www.cnblogs.com/lisperl/archive/2012/05/03/2480316.html">Linux Namespaces机制</a></li>
<li><a href="http://kernel.taobao.org/index.php/Monthly_Kernel_Reports">淘宝内核组月报</a></li>
<li><a href="http://lsword.github.io/2013/09/20.html">Linux中的namespaces</a></li>
<li><a href="https://github.com/golang/go/issues/8447">Golang Issue: syscall, os/exec: Support for User Namespaces</a></li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-11-26-docker-first-step.html">Docker 初探</a></h1>
			<p class="meta"><time datetime="2014-11-26T23:10:04+08:00" 
			pubdate data-updated="true">2014/11/26</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">原则</h3>

<ul>
<li>不是虚拟机，而是带独立文件系统、网络的进程（Container not VM）</li>
<li>如果在 container 中创建进程，则该进程跑在 host 上</li>
<li>使用非 root 用户运行容器（在 Dockerfile 中先创建用户）</li>
<li>Dockerfile 中尽量减少层，比如 RUN 后的命令进行 &amp;&amp; 合并</li>
</ul>

<h3 id="toc_1">安装</h3>

<p>使用 docker 官方在线脚本进行安装：curl -sSL <a href="https://get.docker.com/">https://get.docker.com/</a> | sh 或 wget -qO- <a href="https://get.docker.com/">https://get.docker.com/</a> | sh</p>

<h3 id="toc_2">docker run</h3>

<ul>
<li>-u {username} 以指定用户运行容器。为安全起见，一定不要用 root 用户跑容器。</li>
<li>在 Dockerfile 中 RUN useradd {username} 建立用户，host 上也建立一个相应用户。</li>
<li>-v /host:/container 挂载 host 目录到容器中，要挂载多个目录的话 -v 多次。</li>
<li>-p ip:hostPort:containerPort 将容器使用的端口暴露到 host 端口上，要暴露多个端口的话 -p 多次。</li>
</ul>

<h3 id="toc_3">体验</h3>

<ul>
<li>Docker 降低了应用的更新/部署难度，Dockerfile -&gt; Image -&gt; Pull -&gt; Run</li>
<li>Docker Hub 集成了 GitHub，项目代码提交后自动构建 Image</li>
<li>从 Docker Hub 上 pull 略慢，但总的来说效率还是高于手工部署的方式且不易出错</li>
<li>使用最新 Docker，以前的坑大（比如 1.2 前 pull 失败会 stop 容器）</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-11-20-watchkit-initial-impressions.html">WatchKit初探</a></h1>
			<p class="meta"><time datetime="2014-11-20T23:25:58+08:00" 
			pubdate data-updated="true">2014/11/20</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">整体功能预览</h3>

<p>总体而言，WatchKit第一版SDK提供的功能远远超出了我的期望。因为我原本以为第一版WatchKit可能侧重于对iOS Today Extension功能的延伸，而不是真正开发Watch App。所以当知道真相后，我即惊讶又感到高兴，第一版WatchKit并不是我所想的那样，它可以为Watch App创建全新的交互界面，而且可以通过iOS App Extension去控制他们。</p>

<p><img src="/resource/image/2014-11-20-watchkit-initial-impressions/watchkit-initial-impressions-1.jpg" alt="pi" class="mw_img_center" style="width:1px;display: block; clear:both; margin: 0 auto;"/></p>

<p>所以我们能做的并不只是一个简单的所谓iOS Apple Watch Extension的玩意，而是有很多新的功能需要我们去挖掘。目前提供的比如特定的UI控制方式 、Glance、可自定义的Notification、和Handoff的深度结合、图片缓存等等，作为开发者，这些功能已经让我为之兴奋了。</p>

<h3 id="toc_1">Apple Watch的架构</h3>

<p>WatchKit带给我的惊讶之一是它的架构。目前Watch App的运行是由两部分相互结合进行工作的:</p>

<p><img src="/resource/image/2014-11-20-watchkit-initial-impressions/watchkit-initial-impressions-2.jpg" alt="pi" class="mw_img_center" style="width:2px;display: block; clear:both; margin: 0 auto;"/></p>

<ul>
<li>你的Apple Watch主要包含用户界面元素文件（Storyboard文件和静态的图片文件）和处理用户的输入行为。并不会真正在Apple Watch中运行代码。换句话说，Apple Watch仅是一个“视图”容器。</li>
<li>你的iPhone包含所有的逻辑代码用于响应用户在Apple Watch上产生的诸如应用启动、点击按钮、滑动滑杆等行为。换言之，iPhone包含了控制器和模型。</li>
</ul>

<p>有趣的是Apple Watch和iPhone的这种交互是在幕后自动完成的。你要做的工作只是在Storyboard中设置好UI的Outlet，然后其他的事都由WatchKit SDK在幕后通过蓝牙技术自动进行交互。即使iPhone和Apple Watch是两个独立的设备，你也只需要关注你本地的代码以及Outlet的连接情况，这真是一件很酷的事情。</p>

<h3 id="toc_2">WatchKit布局</h3>

<p>一个令我惊讶的是Watch App的UI布局方式，我们不能再用AutoLayout进行布局了。取而代之的是一种新的布局方式Group，你需要将界面元素比如按钮、Label添加到Group中，然后Group会自动为你添加的界面元素在其内部进行布局。</p>

<p><img src="/resource/image/2014-11-20-watchkit-initial-impressions/watchkit-initial-impressions-3.jpg" alt="pi" class="mw_img_center" style="width:3px;display: block; clear:both; margin: 0 auto;"/></p>

<p>你可以将一个Group嵌入到另一个Group中，用于实现较为复杂一点的界面布局，并在Group中还可以设置背景色、边距、圆角半径等属性。</p>

<p>这让我想起了Java中的<a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html">BoxLayout</a>或者XAML中的<a href="http://msdn.microsoft.com/en-us/library/ms754152.aspx">StackPanel</a>。</p>

<h3 id="toc_3">Glances和Notifications</h3>

<p>Watch App中最酷的功能我觉得就是Glances和Notifications了。我个人认为，Apple Watch的应用中最有用的功能之一就是能让用户很方便的（比如一抬手）就能看到自己感兴趣的事物的提醒通知，比如有人在Twitter中提及到了你或者比特币现在的价位等等。</p>

<p><img src="/resource/image/2014-11-20-watchkit-initial-impressions/watchkit-initial-impressions-4.jpg" alt="pi" class="mw_img_center" style="width:4px;display: block; clear:both; margin: 0 auto;"/></p>

<p>Glances和Notifications能为你带来什么呢？</p>

<ul>
<li>Glances能让你在应用中快速预览信息，有点像iOS8中的Today Extension。</li>
<li>Notifications能让你在Apple Watch中接收到各类通知。Apple Watch中的通知分为两种级别。第一种是提示，只显示应用图标和简单的文本信息。当你抬起手腕或者点击屏幕时就会进入到第二种级别，你就可以看到该通知更多详细的信息，甚至有交互按钮。
在Glance和Notification这两种情形下，你都可以点击屏幕进入到对应的Watch App中，并且使用Handoff。你甚至可以将特定的View Controller作为Glance或Notification的内容发送给用户。</li>
</ul>

<p>我预期在未来几个月我们会在Glance和Notification上面投入较大的时间。</p>

<h3 id="toc_4">动画</h3>

<p>Apple Watch中不支持动画，这多少让人觉得有点奇怪。如果你希望某个UI元素具有动画效果，你必须要生成一堆图片，这些图片的内容是连续动画每一帧的内容，然后循环显示这些图片，感觉又回到了GIF动画时代。所以在Apple Watch中不支持iOS中UIView或CALayer这种动画，只支持帧动画。</p>

<p>举个例子，你们可以看看Apple的<a href="https://developer.apple.com/library/prerelease/ios/samplecode/Lister/Introduction/Intro.html">Lister example</a>示例，你会发现Apple通过360张图片来实现一个画圆的动画效果。</p>

<p><img src="/resource/image/2014-11-20-watchkit-initial-impressions/watchkit-initial-impressions-5.jpg" alt="pi" class="mw_img_center" style="width:5px;display: block; clear:both; margin: 0 auto;"/></p>

<p>这显然是一个灾难性的工作量，不过如果需要，也可以借助某些工具去生成一个动画需要的所有图片。不过，因为Apple Watch的容量很悠闲，所以你要谨慎加入帧动画，因为需要大量图片占用内存，除非有画龙点睛的动画，否则还是尽量少使用动画。</p>

<h3 id="toc_5">设计资源</h3>

<p>如果你是一名设计者（或者对设计有浓厚的兴趣爱好），一下两点建议对你有很好的帮助：</p>

<p>放下你手中所有的事情，阅读Apple提供的针对Apple Watch的<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/WatchHumanInterfaceGuidelines/index.html">Human Interface Guidelines (HIG)</a>。里面有非常不错的指导和参考能帮助你理解Apple Watch UI设计中你有疑惑的地方，因为设计Apple Watch App是一个全新的世界。<br/>
你一定要下载<a href="https://developer.apple.com/watchkit/#agreement">Apple Watch Design Resources</a>。这里有大量关于设计Apple Watch App的PSD素材，比如UI控制模型、颜色、元素间距的指导、笔画粗细的指导等等，有很多有用的东西，给我留下了非常深刻的印象，这里强烈推荐。</p>

<p>原文地址：<a href="http://www.raywenderlich.com/89473/watchkit-initial-impressions">WatchKit: Initial Impressions</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-10-21-swift-failable-initializers.html">Swift 可失败构造器（Failable Initializers）</a></h1>
			<p class="meta"><time datetime="2014-10-21T23:18:46+08:00" 
			pubdate data-updated="true">2014/10/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Xcode6.1中Swift的最新版本是1.1，在该版本中引入了一个新的特性：可失败构造器。通过构造器初始化实际上是给class或struct的每一个存储属性（参数）提供初始值，进行对象实例化的过程。在一些情况下，初始化的过程是有可能失败的。比如，实例化一个对象，在实例化的过程中需要访问资源文件，就像从文件中加载图片一样：</p>

<pre><code>NSImage(contentsOfFile: &quot;swift.png&quot;)
</code></pre>

<p>如果该文件不存在或者因为某种原因不允许访问，那么NSImage的初始化过程就会失败。在Swift 1.1版本中，像这种情况可以通过可失败构造器进行捕获。如果在构造一个对象时使用可失败构造器，那么当对象构造成功时返回该对象，当对象构造失败时则返回nil。因此可以直接用条件判断语句使用可失败构造器来实例化对象：</p>

<pre><code>if let image = NSImage(contentsOfFile: &quot;swift.png&quot;) {
    // loaded the image successfully
} else {
    // could not load the image
}
</code></pre>

<p>init初始化方法可以通过在init关键字后面加上?或!将其变为可失败初始化方法，这样就表示某对象的初始化方法会产生两种结果。比如，将Int类型的init初始化方法变为可失败初始化方法，然后执行String类型转换：</p>

<pre><code>extension Int {
    init?(fromString: String) { 
        if let i = fromString.toInt() {
            // Initialize
            self = i
        } else { 
            // return nil, discarding self is implied
            return nil
        }
    }
}
</code></pre>

<p>在可失败构造器或可失败初始化方法中，一旦返回nil就代表构造失败或初始化失败，不会再返回其他的值。在上述的示例中，当String不能解析为Integer时会导致初始化失败，返回nil，否则返回解析成功后的值。</p>

<p>可失败构造器/初始化方法解决了以前在Swift中只能通过工厂方法捕获构造或初始化失败情况的问题。比如，一个枚举，通过fromRaw工厂方法通过一个原始值来寻找它所对应的枚举成员，返回类型为可选枚举类型。即如果该原始值对应的枚举成员存在，那么返回该枚举成员，如果不存在则返回nil。现在，Swift编译器结合可失败构造器，通过可失败的初始化方法用switch语句判断原始值对应的枚举成员，如果没有对应的则返回nil：</p>

<pre><code>enum Color : Int {
    case Red = 0, Green = 1, Blue = 2

    // implicitly synthesized
    var rawValue: Int { /* returns raw value for current case */ }

    // implicitly synthesized
    init?(rawValue: Int) {
        switch rawValue { 
            case 0: self = .Red
            case 1: self = .Green
            case 2: self = .Blue
            default: return nil
        }
    }
}
</code></pre>

<p>使用可失败构造器可极大程度的统一Swift中的构造对象语法，消除了构造器与工厂方法之间混乱、重复的冗余语法，使Swift更加简洁。随着可失败构造器这一特性的加入，Swift将对大多数Cocoa中带NSError参数的工厂初始化方法进行调整，从而加强Swift中构造对象语法的统一性，给开发者带来更好的开发体验。</p>

<p>原文地址：<a href="https://developer.apple.com/swift/blog/?id=17">Failable Initializers</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-10-21-linux-kernel-network-turning.html">Linux 内核网络参数</a></h1>
			<p class="meta"><time datetime="2014-10-21T23:08:57+08:00" 
			pubdate data-updated="true">2014/10/21</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<ul>
<li>net.ipv4.tcp_fin_timeout：表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间</li>
<li>net.ipv4.tcp_keepalive_time：表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时</li>
<li>net.ipv4.tcp_mem：第一个数字表示，当 tcp 使用的 page 少于该值时，kernel 不对其进行任何的干预；第二个数字表示，当 tcp 使用了超过该值的 pages 时，kernel 会进入 “memory pressure” 压力模式；第三个数字表示，当 tcp 使用的 pages 超过该值时会报：Out of socket memory</li>
<li>net.ipv4.tcp_tw_reuse：表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭</li>
<li>net.ipv4.tcp_timestamps：表示是否启用以一种比超时重发更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项</li>
<li>net.ipv4.tcp_synack_retries：参数的值决定了内核放弃连接之前发送SYN+ACK包的数量</li>
<li>net.ipv4.tcp_syn_retries：表示在内核放弃建立连接之前发送SYN包的数量</li>
<li>net.ipv4.tcp_tw_recycle：用于设置启用timewait快速回收</li>
<li>net.ipv4.tcp_max_tw_buckets：用来设定timewait的数量 net.ipv4.ip_local_port_range：用来设定允许系统打开的端口范围</li>
<li>net.core.rmem_max：最大的TCP数据接收窗口（字节）</li>
<li>net.core.wmem_max：最大的TCP数据发送窗口（字节）</li>
<li>net.core.netdev_max_backlog：在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</li>
<li>net.core.somaxconn：定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数</li>
<li>net.ipv4.tcp_max_orphans：用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立连接将立即被复位并打印出警告信息。这个限制只是为了防止简单的DoS攻击。不能过分依靠这个限制甚至人为减小这个值，更多的情况下应该增加这个值</li>
<li>net.ipv4.tcp_max_syn_backlog：对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字</li>
<li>net.core.wmem_default：默认的TCP数据发送窗口大小（字节）</li>
<li>net.core.rmem_default：默认的TCP数据接收窗口大小（字节）</li>
</ul>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-10-08-tuple-in-swift.html">Swift中的元组（Tuples）</a></h1>
			<p class="meta"><time datetime="2014-10-08T23:11:55+08:00" 
			pubdate data-updated="true">2014/10/8</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<h3 id="toc_0">创建元组</h3>

<p>在Swift中创建元组的方式很简单，它的语法有点类似数组，但是需要把方括号替换为圆括号：</p>

<pre><code>let firstHighScore = (&quot;Mary&quot;, 9001)
</code></pre>

<p>与数组不同的是，元组中的元素可以是任意类型。上面代码中firstHighScore元组就包含一个String类型的元素和一个Int类型的元素。</p>

<p>另外，在创建元组时你还可以给元组中的元素命名：</p>

<pre><code>let secondHighScore = (name: &quot;James&quot;, score: 4096)
</code></pre>

<p>这样可以让我们在使用元组的时候明确的指定某个元素，非常有用。在后面的文章中大家可以看到给元素命名的好处。</p>

<p>以上就是创建元组的两种方式，非常简单和简洁。你不需要像创建struct一样写出它的结构和内部属性，也不需要像创建class一样要写初始化方法。你只需要把你想用的、任何类型的值放在圆括号内，用逗号隔开即可。如果你愿意你还可以给每个元素命名，提高元组使用效率。</p>

<h3 id="toc_1">从元组中读元素</h3>

<p>从元组中读取元素有几种方式，但一般我们会选择最适合当前应用场景的方式，并且确保选择的方式是在当前情况下最简单的一种。</p>

<h4 id="toc_2">元组元素没有命名</h4>

<p>如果我们没有给元组的元素命名，我们可以用点语法，通过定义好的元组变量或常量获取它的第1个到第n个元素：</p>

<pre><code>let firstHighScore = (&quot;Mary&quot;, 9001)
firstHighScore.0            // Mary
firstHighScore.1        // 9001
</code></pre>

<p>如果你觉得上述这种方法会造成语义的不明确，那么我们还可以将元组赋值给一个带有元素名称的元组（元素名称个数要对应）：</p>

<pre><code>let (firstName, firstScore) = firstHighScore
firstName       // Mary
firstScore      // 9001
</code></pre>

<p>如果你只想读取firstHighScore元组中的分数，那么你可以这样写：</p>

<pre><code>let (_, firstScore) = firstHighScore
firstScore      // 9001
</code></pre>

<h4 id="toc_3">元组元素有命名</h4>

<p>如果我们已经给元组中的元素命名了名称，那么我们可以这样写：</p>

<pre><code>let secondName = secondHighScore.name
let secondScore = secondHighScore.score
secondName      // James
secondScore     // 4096
</code></pre>

<h3 id="toc_4">将元组作为函数返回值</h3>

<p>我们可以将元组作为函数的返回值，下面这个函数的返回值就是我们之前定义过的secondHighScore元组：</p>

<pre><code>func getAHighScore() -&gt; (name: String, score: Int)
{
    let theName = &quot;Patricia&quot;
    let theScore = 3894
    
    return (theName, theScore)
}
</code></pre>

<p>为什么说上述函数的返回值是secondHighScore元组呢？因为getAHighScore函数返回的元组元素个数、元素名称、元素类型均和secondHighScore相同。</p>

<p>其实将元组作为函数的返回值时也可以不必对元素进行命名，只要你明白每个元素代表的含义即可：</p>

<pre><code>func getAHighScore() -&gt; (String, Int)
{
    let theName = &quot;Patricia&quot;
    let theScore = 3894
    
    return (theName, theScore)
}
</code></pre>

<p>如果你不确定返回的元组一定不为nil，那么你可以返回一个可选的元组类型：</p>

<pre><code>func maybeGetHighScore() -&gt; (String, Int)?
{
    return nil
}
</code></pre>

<p>因为是可选的元组类型，所以当返回的元组不为nil时，你需要对元组进行解包：</p>

<pre><code>if let possibleScore = maybeGetHighScore()
{
    possibleScore.0
    possibleScore.1
}
else
{
    println(&quot;Nothing Here&quot;)
}
</code></pre>

<p>注意：当你定义了一个没有返回值的函数时，其实该函数是返回一个空的元组()。</p>

<h3 id="toc_5">元组的访问级别</h3>

<p>元组的访问级别取决于它包含的元素。比如元组里的元素都是private级别的，那么该元组也是private级别的。但这里有一个遵循最小的原则，也就是说如果一个元组中有两个元素，一个为private级别，另一个为public级别，那么该元组遵循最小原则，它的访问级别为private。</p>

<h3 id="toc_6">元组是值类型</h3>

<p>关于值类型和引用类型的知识这里不再累赘，我们通过一个代码示例来看看元组是哪种类型：</p>

<pre><code>var someScore = (&quot;John&quot;, 55)
 
var anotherScore = someScore
anotherScore.0 = &quot;Robert&quot;
 
 
println(anotherScore.0)  //Outputs:  &quot;Robert&quot;
println(someScore.0)     //Outputs:  &quot;John&quot;
</code></pre>

<p>通过上述的代码示例可以看出，我把someScore元组赋值给了anotherScore，然后修改了anotherScore的第1个元素的值，最后分别打印了someScore和anotherScore第1个元素的值。someScore元组第一个元素的值为Robert，而anotherScore元组第一个元素的值仍然为John。由此可见元组是值类型。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-18-write-doc-via-gitbook.html">使用 GitBook 写文档</a></h1>
			<p class="meta"><time datetime="2014-09-18T23:05:19+08:00" 
			pubdate data-updated="true">2014/9/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>最近发现很多技术书籍都放在 GitBook 上提供给人们阅读，刚好 Wide 也需要写文档，索性就尝试使用 GitBook 来做。</p>

<h3 id="toc_0">GitBook 简介</h3>

<p>GitBook 是一个通过 Git 和 Markdown 来撰写书籍的工具，最终可以生成 3 种格式：</p>

<ul>
<li>静态站点：包含了交互功能（例如搜索、书签）的站点</li>
<li>PDF：PDF 格式的文件</li>
<li>eBook：ePub 格式的电子书文件</li>
</ul>

<p>GitBook 是免费且开源的，项目地址：<a href="https://github.com/GitbookIO/gitbook">https://github.com/GitbookIO/gitbook</a></p>

<h4 id="toc_1">Git 方式</h4>

<p>GitBook 使用 Git 进行写作内容管理。</p>

<ul>
<li>从用户的角度看，这样能够方便地进行多人协作（连程序源代码都能管好，书籍自然不在话下），还不用学习额外概念或用法</li>
<li>从设计实现的角度看，这样能够合理利用已有工具（不重复造轮）满足产品需求，甚至扩展性更好（Git 相关服务能够利用的太多了）</li>
</ul>

<p>正所谓：“人法地，地法天，天法道，道法自然”啊。</p>

<h4 id="toc_2">Markdown</h4>

<p>GitBook 不只是利用了 Git，目前非常流行的 Markdown 也被运用其中。</p>

<p>使用 Markdown 最大的好处就是简单：</p>

<ul>
<li>语法简单，并且能够形象地表达出意图（例如无序列表使用 * ，强调使用 ** ，一个 # 表示 H1、两个 # 表示 H2）</li>
<li>不干扰写作者：语法标记在视觉上对写作者的负面影响不大（不像 HTML 满屏的 &lt;&gt;）</li>
</ul>

<p>总之，Markdown 就是能够让写作者更专注于内容创作。</p>

<p>不过 GitBook 不只是简单地使用 Markdown，使用 Markdown 编写的内容只是源格式，最终的目标格式可以为 PDF、ePub 等。</p>

<h3 id="toc_3">静态站点</h3>

<p>在本地编写完内容后我们需要将内容提交到 GitBook 上进行书籍的构建。GitBook 会将书籍构建为 4 种格式（JSON、ePub、PDF、Website）。 其中我们最常用的应该是静态站点，这样能够方便传播。</p>

<h3 id="toc_4">客户端编辑器</h3>

<p>可以使用 GitBook 的官方编辑器来进行写作、发布等管理，非常方便。</p>

<h3 id="toc_5">其他</h3>

<p>GitBook 还有很多功能，例如：</p>

<ul>
<li>自定义静态站点域名</li>
<li>多语言支持</li>
<li>书籍私有</li>
<li>自定义封面（弄个漂亮的书皮吧）</li>
<li>交互式练习、提问（这个用于写问答类书籍或习题类书籍会很有用）</li>
</ul>

<h3 id="toc_6">题外话</h3>

<p>GitHub、GitBook、GitXXX 都很流行啊，为什么呢？</p>

<p>Git 已经不只是一个版本控制系统了，它的分布式协作方式正在潜移默化地影响着很多程序的设计，最终影响了很多在线服务的提供方式。这样一种私有-公有可控的网络信息架构是非常值得我们学习并实践的，这样架构的各类产品将越来越多。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-11-swift-final.html">Swift中的final修饰符</a></h1>
			<p class="meta"><time datetime="2014-09-11T23:08:41+08:00" 
			pubdate data-updated="true">2014/9/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>Swift中的final修饰符可以防止类（class）被继承，还可以防止子类重写父类的属性、方法以及下标。需要注意的是，final修饰符只能用于类，不能修饰结构体（struct）和枚举（enum），因为结构体和枚举只能遵循协议（protocol）。虽然协议也可以遵循其他协议，但是它并不能重写遵循的协议的任何成员，这就是结构体和枚举不需要final修饰的原因。</p>

<h3 id="toc_0">final修饰符的几点使用原则</h3>

<ul>
<li>final修饰符只能修饰类，表明该类不能被其他类继承，也就是它没资格当父类。</li>
<li>final修饰符也可以修饰类中的属性、方法和下标，但前提是该类并没有被final修饰过。</li>
<li>final不能修饰结构体和枚举。</li>
</ul>

<p>代码示例</p>

<pre><code>final class Train {
    //Todo...
}

class MaglevTrain: Train {  // 编译失败
    //Todo...
}
</code></pre>

<p>上面代码中，因为Train类被final修饰过，所以当MaglevTrain类继承了Train后，编译器会提示错误。</p>

<pre><code>class Train {
    final func method() {
        //Todo...   
    }
}

class MaglevTrain: Train {  
    override func method() {  // 编译失败
        //Todo...
    }
}
</code></pre>

<p>上面的代码中，因为Train类中的method方法被final修饰过，所以当子类MaglevTrain重写父类的method方法时，编译器会提示错误。</p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-02-optionals-case-study.html">Swift中Optional类型的使用案例分析：valuesForKeys</a></h1>
			<p class="meta"><time datetime="2014-09-02T22:53:15+08:00" 
			pubdate data-updated="true">2014/9/2</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>这篇文章将带我们探索在Swift中如何使用Optional类型保证强类型的安全性。我们将创建一个Swift版本的Objective-C的API。虽然在Swift中这个API存在的意义不是很大，但是这将会是一个很有趣的例子。</p>

<p>在Objective-C中，NSDictionary类有一个方法，名为-objectsForKeys:notFoundMarker:，它的作用是根据第一个NSArray类型参数中的值作为该字典的key，查找这些key对应的字典中的值，并放到一个新的NSArray中返回，如果找不到对应的值，那么就返回第二个参数指定的对象。在官方文档中对该方法有这么一句描述“返回的数组中的第N个对象，对应着第一个数组参数中的第N个值”。假如说以第一个数组参数中的第三个值作为key在字典中查不到值怎么办呢？这时候就需要notFoundMarker参数登场了。这种情况下就会返回notFoundMarker参数指定的对象了。在Foundation框架中还有专门针对该情况适用的一个类，那就是NSNull，就是当你也没有备选返回对象的时候，就可以返回NSNull对象。</p>

<p>在Swift中，Dictionary类型并没有类似objectsForKeys的方法。所以接下来的练习中，我们将使用类型的扩展机制为Dictionary类型添加一个类似objectsForKeys的方法，为保持Swift的风格我们起名为valuesForKeys:notFoundMarker:。</p>

<pre><code>extension Dictionary {
    func valuesForKeys(keys: [K], notFoundMarker: V) -&gt; [V] {
        // To be implemented
    }
}
</code></pre>

<p>在Swift中实现该方法与Objective-C有点不同，因为Swift中强类型的特性使返回的数组中只能包含某一种类型的元素，也就是说我们不能在一个字符串数组中添加一个NSNull类型的元素，这就使notFoundMarker的参数类型显得非常尴尬。这怎么解决呢？别着急，在Swift中我们有更好的选择：我们可以返回一个Optional类型的数组。从Dictionary中查出的值全部被包在Optional类型中，这样当使用的key没有对应值的时候，我们就可以使用nil来替代NSNull类型了。</p>

<pre><code>extension Dictionary {
    func valuesForKeys(keys: [Key]) -&gt; [Value?] {
        var result = [Value?]()
        result.reserveCapacity(keys.count)
        for key in keys {
            result.append(self[key])
        }
        return result
    }
}
</code></pre>

<p>注意：此时可能已经有人认为Dictionary类型中的这个方法可能没必要写的这么繁琐，你们可能已经想到了这种情形：</p>

<pre><code>extension Dictionary {
    func valuesForKeys(keys: [Key]) -&gt; [Value?] {
        return keys.map { self[$0] }
    }
}
</code></pre>

<p>这段代码和上面那段代码的作用和结果是完全一样的，当keys调用map方法时，其实已经将查出的所有值都包在了Optional类型中了。这就足以说明了为什么Swift中类型的API都那么短小精干，因为实现复杂逻辑就像上述代码中直接调用map方法一样简单。</p>

<p>现在我们可以试着用我们扩展的方法做一些例子：</p>

<pre><code>let dict = [&quot;A&quot;: &quot;Amir&quot;, &quot;B&quot;: &quot;Bertha&quot;, &quot;C&quot;: &quot;Ching&quot;]

dict.valuesForKeys([&quot;A&quot;, &quot;C&quot;])
// [Optional(&quot;Amir&quot;), Optional(&quot;Ching&quot;)]

dict.valuesForKeys([&quot;B&quot;, &quot;D&quot;])
// [Optional(&quot;Bertha&quot;), nil]

dict.valuesForKeys([])
// []
</code></pre>

<h3 id="toc_0">内嵌Optional类型</h3>

<p>现在我们来看看使用last属性返回数组的最后一个元素会发生什么？</p>

<pre><code>dict.valuesForKeys([&quot;A&quot;, &quot;C&quot;]).last
// Optional(Optional(&quot;Ching&quot;))

dict.valuesForKeys([&quot;B&quot;, &quot;D&quot;]).last
// Optional(nil)

dict.valuesForKeys([]).last
// nil
</code></pre>

<p>看着结果我们是不是觉得很奇怪呢？我们在上述代码的第一种情况下得到了嵌套的Optional类型，而在第二种情况下缺得到了包含nil的Optional类型，为什么得到的不是Optional(&quot;Ching&quot;)和nil呢？</p>

<p>冷静下来，我们回忆一下last属性的是如何申明的：</p>

<pre><code>var last: T? { get }
</code></pre>

<p>恍然大悟，原来last属性的类型是Optional类型，这也就是说如果T是Optional类型的话，那么T?自然就是Optional(Optional)了，也就是T??。所以上面的情况就很容易解释了，因为T的类型是Optional(String)，所以我们得到的结果就是Optional(Optional(String))。</p>

<p>那么Optional(nil)这种情况如何解释呢？为什么不是Optional(Optional(nil))呢？</p>

<p>我们现在Objective-C中执行一下上面那三种情况看一看：</p>

<pre><code>[dict valuesForKeys:@[@&quot;A&quot;, @&quot;C&quot;] notFoundMarker:[NSNull null]].lastObject
// @&quot;Ching&quot;

[dict valuesForKeys:@[@&quot;B&quot;, @&quot;D&quot;] notFoundMarker:[NSNull null]].lastObject
// NSNull

[dict valuesForKeys:@[] notFoundMarker:[NSNull null]].lastObject
// nil
</code></pre>

<p>我们看到，不论在Swift中还是在Objective-C中，当第一个参数的数组是空数组的时候，取最后一个元素的返回结果都是nil，意思就是“数组是空数组，那么最后一个元素肯定不存在啦”。那么在Swift中返回Optional(nil)和在Objective-C中返回NSNull的情况表明这个所谓的最后一个元素在数组中其实是存在的，只不过它就代表没有。当这种情况发生时，Objective-C只能用一个占位符对象来表示，而在Swift中就可以用一个系统类型来表示。</p>

<h3 id="toc_1">提供默认值</h3>

<p>如果我们想当在Dictionary中查不到对应值的时候返回一个我们指定的默认值要怎么做呢？其实这也很简单：</p>

<pre><code>extension Dictionary {
    func valuesForKeys(keys: [Key], notFoundMarker: Value) -&gt; [Value] {
        return self.valuesForKeys(keys).map { $0 ?? notFoundMarker }
    }
}


dict.valuesForKeys([&quot;B&quot;, &quot;D&quot;], notFoundMarker: &quot;Anonymous&quot;)
// [&quot;Bertha&quot;, &quot;Anonymous&quot;]
</code></pre>

<p>当Objective-C只能用占位符对象来做到这一点的时候，Swift却可以使用系统类型来呈现，并且提供了丰富的语法支持多样化的返回结果。</p>

<p>原文地址：<a href="https://developer.apple.com/swift/blog/?id=12">Optionals Case Study: valuesForKeys</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-09-01-closure-expressions-in-swift.html">Swift中的闭包（Closure）</a></h1>
			<p class="meta"><time datetime="2014-09-01T22:57:30+08:00" 
			pubdate data-updated="true">2014/9/1</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>闭包在Swift中非常有用。通俗的解释就是一个Int类型里存储着一个整数，一个String类型包含着一串字符，同样，闭包是一个包含着函数的类型。有了闭包，你就可以处理很多在一些古老的语言中不能处理的事情。这是因为闭包使用的多样性，比如你可以将闭包赋值给一个变量，你也可以将闭包作为一个函数的参数，你甚至可以将闭包作为一个函数的返回值。它的强大之处可见一斑。</p>

<p>在Swift的很多文档教材中都说函数是“一等公民”，起初我还不是很理解“一等公民”是什么意思，但当我理解了闭包以及它的强大功能后，我恍然大悟、茅塞顿开、醍醐灌顶。原来闭包的这些特性就是“一等公民”的特性啊！参见维基百科<a href="http://en.wikipedia.org/wiki/First-class_citizen">First-class citizen</a>。</p>

<p>Swift中的闭包类似Objective-C中的Block。其实，如果你想在Swift中实现Objective-C里的Block功能，你可以直接使用闭包来代替。Block和闭包的区别只是语法的不同而已，而且闭包的可读性比较强。</p>

<h3 id="toc_0">函数是闭包吗？</h3>

<p>虽然你还没有意识到，但我们确实已经在Swift中这么用了。Swift中的函数就是闭包，在Apple的官方文档中有这样的描述：</p>

<p>闭包有三种形式：</p>

<ol>
<li>全局函数是一个有名字但不会捕获任何值的闭包。</li>
<li>嵌套函数是一个有名字并可以捕获到其封闭函数域内的值的闭包。</li>
<li>闭包表达式是一个利用轻量级语法所写的，可以捕获其上下文中变量或常量值的匿名闭包。</li>
</ol>

<p>今天，我们要讨论的是第三种形式，尤其讨论它是如何将繁复的、可读性比较差的业务逻辑代码压缩成高可读性、简明明了的形式。</p>

<p>大家还记得数组的map方法么？它的参数就是一个闭包，它会将数组里的每一个元素放在闭包中进行处理，然后返回一个新的数组，甚至是与原数组不同元素类型的新数组。</p>

<p>map函数的原型如下：</p>

<pre><code>func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; [U]
</code></pre>

<p>我们可以看到该函数使用了泛型。(T) -&gt; U是一个泛型闭包，它的意思就是类型T将会在闭包中进行逻辑处理，然后返回U类型。最后map函数会返回一个U类型的数组。</p>

<p>用一个例子来说明。今天我办生日聚会，要迎接很多人，并且为每个人都准备了一句欢迎词。我们要怎么做呢？首先我们将迎接的人放进一个数组名叫guestList，然后用一个名叫greetPeople的函数为每个人生成欢迎词：</p>

<pre><code>func greetPeople(person: String) -&gt; String
{
    return &quot;Hello, \(person)!&quot;
}


let guestList = [&quot;Chris&quot;, &quot;Jill&quot;, &quot;Tim&quot;]
let fullGreetings = guestList.map(greetPeople)
</code></pre>

<p>然后将greetPeople函数作为guestList数组的map函数的参数传入，并返回一个新的数组fullGreetings，这个数组就包含了每个人的欢迎词。</p>

<p>如果我们想展示一下每个人的欢迎词，我们甚至可以这样写：</p>

<pre><code>fullGreetings.map(println)
</code></pre>

<p>这时也许有人要质疑了，println函数不是没有返回值么？那么map函数会返回什么呢？其实每一个没有返回值的函数，都会返回一个空的元组（tuple），所以说上述代码的返回值其实是Array&lt;()&gt;。</p>

<p>上面的例子中我们就是将一个全局函数greetPeople作为一个闭包来使用的。</p>

<h3 id="toc_1">简明扼要的闭包表达式</h3>

<p>其实Swift已经为我们提供了很多简化的语法，可以让我们保证代码的高可读性和维护性。还用上面的例子来说明，对于greetPeople这个全局函数来说，其实只需要使用一次，所以我们没必要单独定义这个函数。我们可以直接使用闭包表达式来处理：</p>

<pre><code>let fullGreetings = guestList.map({(person: String) -&gt; String in return &quot;Hello, \(person)!&quot;})
</code></pre>

<p>闭包表达式其实是函数的字面值，官方一般称之为匿名函数。一般当我们需要使用函数快速的实现一个简短的处理逻辑并且只使用一次的时候，我们可以省去函数名，使用简化的语法。上面的代码中可以看到关键字in之前是闭包表达式的参数和返回值，in之后是闭包表达式实际处理逻辑的代码区域。</p>

<p>下面我们将使用Swift更多的特性来进一步简化闭包表达式。</p>

<p>我们知道Swift中有类型推断的特性，所以我们可以取掉参数类型：</p>

<pre><code>let fullGreetings = guestList.map({(person) -&gt; String in return &quot;Hello, \(person)!&quot; })
</code></pre>

<p>像我们示例中的这种单一闭包表达式，编译器可以根据in之前的返回值类型和return之后的返回数据类型自动判断，所以我们可以省略返回值和return关键字：</p>

<pre><code>let fullGreetings = guestList.map({person in &quot;Hello, \(person)!&quot; })
</code></pre>

<p>其实在Swift中还提供了参数的简写方式：\(0代表第一个参数、\)1代表第二个参数以此类推。所以我们又可以将参数名称省略：</p>

<pre><code>let fullGreetings = guestList.map({ &quot;Hello, \($0)!&quot; })
</code></pre>

<p>当函数的最后一个参数是闭包时，可以将闭包写在()之外，这也是Swift的一个特性，所以我们还可以继续简化：</p>

<pre><code>let fullGreetings = guestList.map(){ &quot;Hello, \($0)!&quot; }
</code></pre>

<p>当函数有且仅有一个参数，并该参数是闭包时，不但可以将闭包写在()外，还可以省略()：</p>

<pre><code>let fullGreetings = guestList.map{ &quot;Hello, \($0)!&quot; }
</code></pre>

<p>到目前为止，示例中的闭包表达式已经被我们根据Swift的特性，简化为简明扼要、高可读性的闭包表达式了，是不是很酷呢！</p>

<p>参考原文：<a href="http://www.codingexplorer.com/closure-expressions-swift/?utm_source=feedly&amp;utm_reader=feedly&amp;utm_medium=rss&amp;utm_campaign=closure-expressions-swift">Closure Expressions in Swift</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-27-change-ubuntu-display-resolution.html">修改 Ubuntu 分辨率</a></h1>
			<p class="meta"><time datetime="2014-08-27T23:02:01+08:00" 
			pubdate data-updated="true">2014/8/27</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>通常我们可以在 Settings -&gt; Hardware -&gt; Display 中选择适合的分辨率，但有些情况下这里没有列出合适的分辨率，此时我们可以通过命令调整显示分辨率。</p>

<ol>
<li><p>先通过 xrandr 获取当前的显示设备名</p></li>
<li><p>然后通过 cvt 命令获取需要的显示模式编辑行</p></li>
<li><p>新建显示模式 xrandr --newmode &quot;1368x768_60.00&quot; 85.25 1368 1440 1576 1784 768 771 781 798 -hsync +vsync</p></li>
<li><p>添加显示模式 xrandr --addmode VBOX0 &quot;1368x768_60.00&quot;</p></li>
<li><p>应用显示模式 xrandr --output VBOX0 --mode &quot;1368x768_60.00&quot;</p></li>
</ol>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-18-swift-value-and-reference-types.html">Swift中的值类型和引用类型</a></h1>
			<p class="meta"><time datetime="2014-08-18T22:49:02+08:00" 
			pubdate data-updated="true">2014/8/18</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Swift中，类型分为两类：第一种是值类型，该类型的每个实例持有数据的副本，并且该副本对于每个实例来说是独一无二的一份，比如结构体（struct）、枚举（enum）、元组（tuple）都是值类型。第二种是参照类型，该类型的实例共享数据唯一的一份副本（在native层面说的话，就是该类型的每个实例都指向内存中的同一个地址），比如类（class）就是参照类型。在这篇文章中，我们将深入探讨值类型和参照类型的使用价值，以及如何在某种场景下选择正确的类型。</p>

<h3 id="toc_0">它们有什么不同？</h3>

<p>值类型最基本的特点就是复制，这影响到它的赋值、初始化、传参等操作。来看看下面的代码示例：</p>

<pre><code>// 值类型示例
struct S { var data: Int = -1 }
var a = S()
var b = a                       // a复制一份，并将副本赋值给了b
a.data = 42                     // a的数据改变了，但是b的并没有改变
println(&quot;\(a.data), \(b.data)&quot;) // prints &quot;42, -1&quot;
</code></pre>

<p>参照类型的复制行为其实是隐式的创建了一个共享的实例，作为原始类型的参照。下面的例子中，两个变量都会参照唯一的那个共享实例的数据，所当改变这两个变量中任何一个的数据，都会同样作用于原始类型的数据：</p>

<pre><code>// 参照类型示例
class C { var data: Int = -1 }
var x = C()
var y = x       // 将x赋值给y
x.data = 42     // 修改了x的数据，其实是修改了参照数据，那么y的数据也会改变 
println(&quot;\(x.data), \(y.data)&quot;) // prints &quot;42, 42&quot;
</code></pre>

<h3 id="toc_1">Mutation在安全性中的角色</h3>

<p>选择值类型的一个很重要的原因是可以让你比较容易的理解和掌控你的代码。如果你使用值类型，那么都是唯一的数据值、类型的副本在和你打交道，你对数据的修改只作用于数据所属的类型实例，所以你可以不用担心因为你在某个地方对数据的修改而影响到其他地方的数据。这在多线程环境中非常有用，因为在多线程下，不同的线程有可能会在你不知情的情况下改变数据。发生这种Bug后，调试起来就非常困难。</p>

<p>因为值类型和参照类型的表象区别就在于当你修改类型实例的数据时，它们对原始类型数据的处理方式不同。但是有一种情况，值类型和参照类型的处理方式却又相似，那就是当类型实例的数据为只读的时候。在不存在修改的情况下，值类型和参照类型就没什么区别了。</p>

<p>你可能会觉得这一点很有用，假如说一个class是完全不能被重定义的，那么就比较符合使用Cocoa的NSObject对象的一些习惯，并能很好的保持原本的语义。今天，在Swift你可以通过定义不可改变的存储属性来创建一个不可重定义的类，这样可以避免暴露出的API被修改。事实上，许多普通的Cocoa框架里的类，比如NSURL，都被定义成了不可重定义的类。尽管如此，Swift目前还不提供任何机制像结构体（struct）和枚举（enum）一样去强制使一个class成为不可重定义的类（比如像子类）。</p>

<h3 id="toc_2">如何选择正确的类型？</h3>

<p>如果你想创建一个新类型，那么你应该选择值类型还是参照类型呢？当你使用Cocoa框架时，很多API都是NSObject的子类，那么你就必须要使用参照类型，也就是class。在其他情况下，这里有一些指导建议你可以参考：</p>

<p>使用值类型的情形：</p>

<ul>
<li>使用==运算符比较实例数据的时候。</li>
<li>你想单独复制一份实例数据的时候。</li>
<li>当在多线程环境下操作数据的时候。</li>
</ul>

<p>使用参照类型（比如class）的情形：</p>

<ul>
<li>当使用===运算符判断两个对象是否引用同一个对象实例的时候。</li>
<li>当上下文需要创建一个共享的、可变的对象时。</li>
</ul>

<p>在Swift中，Array、String、Dictionary都是值类型。它们的使用方式类似C语言中得int，每一个实例都有一份数据。你不需要进行显示的复制操作去防止数据在你不知情的情况下被修改。更重要的是，你可以跨线程进行传参而不需要考虑同步的问题，因为传递值类型很安全。秉着高安全性的精神，这种类型划分模式能帮助你在Swift中写出更加有可预测性的代码。</p>

<p>原文地址：<a href="https://developer.apple.com/swift/blog/?id=10">Value and Reference Types</a></p>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="2014-08-13-swift-nil-coalescing.html">Swift中 Nil Coalescing 运算符的使用技巧</a></h1>
			<p class="meta"><time datetime="2014-08-13T22:43:15+08:00" 
			pubdate data-updated="true">2014/8/13</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<p>在Swift官方《The Swift Programming Language》文档的Basic Operators一节中添加了Nil Coalescing Operator小结，介绍了一个新的运算符Nil Coalescing，符号是??，它的表现形成如下：</p>

<pre><code>let c = a ?? b
</code></pre>

<p>这个运算符有两个条件：</p>

<ul>
<li>a必须是Optional类型的。</li>
<li>b的类型必须要和a解包后的值类型一致。</li>
</ul>

<p>符合这两个条件后，我们来解释一下上述这行代码，意思就是c的值是a或b中一个的值，但有前提条件，就是当a解包后值不为nil时，那么就将a解包后的值赋值给c，如果a解包后值为nil，那么就将b的值赋值给c。</p>

<p>我们还可以用三目运算来更形象的解释这个运算符：</p>

<pre><code>let c = a != nil ? a! : b
</code></pre>

<p>从上面的代码我们很容易理解，当a的值不等于nil时，将a解包后的值赋值给c，否则将b的值赋值给c。</p>

<p>我们来看看官方给的代码示例：</p>

<pre><code>let defaultColorName = &quot;red&quot;
var userDefinedColorName: String?   // 默认值为nil

var colorNameToUse = userDefinedColorName ?? defaultColorName
// 因为userDefinedColorName的值是nil，所以colorNameToUse的值为&quot;red&quot;


userDefinedColorName = &quot;green&quot;
colorNameToUse = userDefinedColorName ?? defaultColorName
// 因为userDefinedColorName的值不为nil，所以colorNameToUse的值为&quot;green&quot;
</code></pre>

<p>大家看到这应该对Nil Coalescing这个运算符有比较清晰的理解了，但在实际运用中，我们还需要注意以下几点。</p>

<h3 id="toc_0">编译器中的类型匹配原则</h3>

<p><em>原谅我在末尾加的;，编码习惯而已 = =||</em></p>

<p>我们先来看一段代码：</p>

<pre><code>let a: Int? = nil;
let b: Int? = 7;

let c = a != nil ? a! : b; // 因为a的默认值为nil，所以c的值为{Some 7}
let d = a ?? b; // 这里d的值为nil，这是怎么回事？
</code></pre>

<p>首先我们需要注意的是，在官方文档中有这么一句话：“The expression b must match the type that is stored inside a”。但是上面的代码示例中，我们的b是Int?类型，那么此时我们的编译器会怎么处理呢？我们通过自己实现一个Nil Coalescing运算符来说明，代码片段如下：</p>

<pre><code>infix operator ??? {
    associativity right;
    precedence 110;
}

func ???&lt;T&gt;(a: T?, b: @autoclosure () -&gt; T) -&gt; T {
    return a != nil ? a! : b();
}

let d = a ??? b; // 这里d的值仍然是nil
</code></pre>

<p>从上面的代码片段中我们可以看出，a的类型是根据传入的b的类型决定的，所以当我们传入的b是Int?类型时，编译器其实将a的类型自动转换为Int??类型了，也就是Optional(a)，那么我们就能解释let d = a ?? b;这行代码。因为a == nil但是Optional(a) != nil，所以d = Optional(a)!，d的值为nil。</p>

<h3 id="toc_1">Nil Coalescing运算符返回值的类型</h3>

<p>我们先看示例代码片段：</p>

<pre><code>let a: Int? = nil;
let b: Int? = 5;
let c: Int? = 6;

// 因为a的默认值为nil，所以将b的值赋值给x，x的值为{Some 5}，类型为Int?
let x = a != nil ? a! : b;
// 因为c的值不为nil，所以将c解包后的值赋值给y，但是y的值却是{Some 6}，而不是6，这是怎么回事？
let y = c != nil ? c! : b;
</code></pre>

<p>根据上面我们提到的编译器中类型判断的原则就可以理解了，因为b的类型是Int?，所以在编译时c的类型已经成了Int??,所以为Int??解包的类型就是Int?了。</p>

<p>如果我们声明变量y的类型，编译器就要提出抗议了：</p>

<pre><code>// 如何a为Int?类型，那么编译器就不会通过，因为会导致赋值运算符两边类型不等
let x: Int = a != nil ? a! : b;

// 这种写法和上面一样，都不会编译通过
let y: Int = a ?? b;
</code></pre>


		</div>

		

	</article>
  
	<div class="pagination">
	 <a class="prev" href="all_4.html">&larr; Older</a> 
<a href="archives.html">Blog Archives</a>
	 <a class="next" href="all_2.html">Newer &rarr;</a>  
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="2016-12-29-wechat-small-app.html">张小龙首次公开解读小程序：1月9号上线</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-27-benefits-and-pitfalls-of-micro-service.html">微服务的好处和陷阱</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-12-02-douban-rexxar.html">Rexxar：豆瓣对混合开发的思考</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-10-31-close-wait-problem.html">CLOSE_WAIT 问题分析</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="2016-10-08-swift-sizeof-into-memorylayout.html">Swift 3：sizeof移进MemoryLayout</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>

  
    




</body>
</html>